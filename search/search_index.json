{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Formal Methods","text":""},{"location":"#fm-crypto","title":"FM Crypto","text":"<p>The FM Crypto section contains notes on using the Lean proof assistant to formally state and prove some basic theorems in cryptography.</p> <p>The associated Lean programs are at https://github.com/formalverification/lean4crypto.</p>"},{"location":"contributors/","title":"Contributors","text":"<p>William DeMeo</p> <p>If you have contributed to the contents of this site and you're not mention here, please contact williamdemeo at gmail or create a new issue  in the formalmethods.io GitHub repository.</p>"},{"location":"license/","title":"License","text":"<p>formalmethods.io \u00a9 2025 by William DeMeo is licensed under CC BY-NC-SA 4.0</p>"},{"location":"mkdocs/","title":"MkDocs","text":""},{"location":"mkdocs/#references","title":"References","text":"<ul> <li>MkDocs</li> <li>MkDocs Material</li> <li>Getting Started with Material for MkDocs, by James Willet.</li> </ul>"},{"location":"crypto/otp/2025Jun19-notes/","title":"Basic Probability in Lean4: a primer for paranoids and pedants","text":"<p>We will demonstrate not only how to prove properties in Lean but also why the methods work, connecting the seemingly magical world of tactics to the solid ground of proof objects, with which we are more familiar from Agda.</p> <p>We'll start by reviewing a concrete, fundamental example from last time: computing the probability of choosing a specific key at random.</p> <p>This will allow us to bring the ideas down to earth and immediately dive into and discuss the tactic vs. proof object dichotomy.</p>"},{"location":"crypto/otp/2025Jun19-notes/#part-1-a-concrete-first-proof","title":"Part 1: A Concrete First Proof","text":"<p>Let's start with the</p> <p>Claim. The probability of randomly choosing a specific 3-bit key is 1/8.</p> <p>In Lean, the theorem and its tactic-based proof are very concise.</p> <pre><code>import Mathlib.Probability.Distributions.Uniform\n\n-- (Assuming a file OTP.Basic with the definition of Key)\nopen OTP\n-- Recall, we define `Key n` as vectors of booleans.\n-- This is equivalent to `Fin n \u2192 Bool` or other n-bit types.\n\n-- Here is the uniform distribution over keys of length n.\nnoncomputable def \u03bcK {n : \u2115} : PMF (Key n) := PMF.uniformOfFintype (Key n)\n\n-- Our claim: the probability of choosing key [true, false, true] is 1/8.\nexample : \u03bcK \u27e8[true, false, true], rfl\u27e9 = (1/8 : ENNReal) :=\n -- and here's the tactic-based proof in Lean:\n  by simp [\u03bcK, PMF.uniformOfFintype_apply]; rfl\n</code></pre> <p>This is great for a user who knows what <code>simp</code> means and does, but it may seem like a magical incantation for the newcomer.</p> <p>So, let's unpack it.</p>"},{"location":"crypto/otp/2025Jun19-notes/#deconstructing-simp","title":"Deconstructing <code>simp</code>","text":"<p>The <code>simp</code> tactic is an automated rewriter.</p> <p>It tries to simplify the main goal by applying a list of theorems (called a \"simpset\") from left to right, over and over, until no more simplifications can be made.</p> <p>When you write <code>simp [foo, bar]</code>, you are telling Lean:</p> <p>\"Please use your standard simpset, plus the definitions/lemmas <code>foo</code> and <code>bar</code> to the set of tools you can use to simplify or reduce the goal.\"</p>"},{"location":"crypto/otp/2025Jun19-notes/#step-1-unfolding-the-definition-of-k","title":"Step 1: Unfolding the Definition of <code>\u03bcK</code>","text":"<p>Let's break down the proof step-by-step, showing the tactic at each stage, and then discuss the proof object it's building.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 \u03bcK \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>Here, <code>\u22a2</code> indicates the goal we are trying to prove.</p> <p>The Tactic <code>simp [\u03bcK]</code> or <code>rw [\u03bcK]</code></p> <p>tells Lean to substitute <code>\u03bcK</code> with its definition.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>\u22a2 PMF.uniformOfFintype (Key 3) \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre>"},{"location":"crypto/otp/2025Jun19-notes/#why-this-works","title":"Why this works","text":"<p>Looking under the hood,</p> <ul> <li> <p><code>\u03bcK</code> is defined as <code>PMF.uniformOfFintype (Key n)</code>.</p> </li> <li> <p><code>simp</code> (and the more targeted <code>rw</code>) can access all definitions in context.</p> </li> <li> <p>It sees the term <code>\u03bcK</code> in the goal and replaces it with its definition; a   simple substitution.</p> </li> </ul>"},{"location":"crypto/otp/2025Jun19-notes/#the-equivalent-proof-term","title":"The Equivalent Proof Term","text":"<p>In a term-based proof, the substitution is achieved using functions that show equality is respected by function application.</p> <p>If we have a proof <code>h : \u03bcK = PMF.uniformOfFintype (Key 3)</code>, we can use it to rewrite the goal.</p> <p>The definition itself provides this proof <code>h</code>. The core idea is <code>Eq.subst</code> or <code>Eq.rec</code>.</p> <p>A proof term for just this step would look like this:</p> <pre><code>-- Let P be the property we are trying to prove for the definition.\n-- P := \u03bb x =&gt; x \u27e8[true, false, true], _\u27e9 = 1/8\n-- Our goal is `P (\u03bcK)`\n-- The definition of \u03bcK gives us `proof_of_definition : \u03bcK = PMF.uniformOfFintype (Key 3)`\n\n-- The new proof term is:\nEq.subst proof_of_definition (new_goal : P (PMF.uniformOfFintype (Key 3)))\n</code></pre> <p>...which is a bit clunky.</p> <p>A more common term-based idiom is to simply start with the definition already unfolded.</p> <p>The tactic <code>rw</code> is essentially a mechanical way of applying <code>Eq.subst</code>.</p>"},{"location":"crypto/otp/2025Jun19-notes/#step-2-unfolding-definition-of-uniform-pmf","title":"Step 2: Unfolding Definition of Uniform PMF","text":"<p>Now we apply the definition of what <code>uniformOfFintype</code> evaluates to for a given input.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 PMF.uniformOfFintype (Key 3) \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>The Tactic <code>simp [PMF.uniformOfFintype_apply]</code></p> <p>The lemma <code>PMF.uniformOfFintype_apply</code> states:</p> <p>If <code>a</code> is an inhabitant of the finite type <code>\u03b1</code>, then</p> <p><code>PMF.uniformOfFintype \u03b1 a</code> is equal to <code>(Fintype.card \u03b1)\u207b\u00b9</code>.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>\u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre>"},{"location":"crypto/otp/2025Jun19-notes/#why-this-works_1","title":"Why this works","text":"<p>Looking under the hood,</p> <ul> <li> <p><code>simp</code> finds a lemma <code>PMF.uniformOfFintype_apply</code> in the library;</p> </li> <li> <p>This lemma matches the pattern <code>PMF.uniformOfFintype (Key 3) ...</code> on the lhs of our goal;</p> </li> <li> <p><code>simp</code> using the lemma to rewrites the lhs as <code>(Fintype.card (Key 3))\u207b\u00b9</code>.</p> </li> </ul>"},{"location":"crypto/otp/2025Jun19-notes/#the-equivalent-proof-term_1","title":"The Equivalent Proof Term","text":"<p>This is a direct application of the lemma.</p> <p>The proof term for the rewrite is <code>PMF.uniformOfFintype_apply (Key 3) \u27e8...\u27e9</code>.</p> <p>Applying this equality to our goal transforms it.</p> <p>A proof would look like:</p> <pre><code>-- h\u2081 : PMF.uniformOfFintype (Key 3) \u27e8...\u27e9 = (Fintype.card (Key 3))\u207b\u00b9\n-- This comes from the lemma PMF.uniformOfFintype_apply\n-- We use this to transform the goal into proving:\n-- \u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> <p>This is again a form of <code>Eq.subst</code>.</p> <p>The <code>rw</code> tactic is the most direct parallel: <code>rw [PMF.uniformOfFintype_apply]</code>.</p>"},{"location":"crypto/otp/2025Jun19-notes/#step-3-computing-the-cardinality-and-final-simplification","title":"Step 3: Computing the Cardinality and Final Simplification","text":"<p>This is where <code>simp</code> really shines by combining computation and proof.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> <p>The Tactic <code>simp; rfl</code></p> <p>We don't need to provide any more lemmas. The rest is handled by Lean's built-in capabilities.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <p>The goal is solved!</p>"},{"location":"crypto/otp/2025Jun19-notes/#why-this-works_2","title":"Why this works","text":"<p>Looking under the hood,</p> <ol> <li> <p>Typeclass Inference. Lean needs to know the size of <code>Key 3</code>. The type <code>Key 3</code>,     which is <code>Vector Bool 3</code>, has an instance of the <code>Fintype</code> typeclass. This     instance provides a computable function to get the number of elements.</p> </li> <li> <p>Computation. The <code>simp</code> tactic (or the <code>norm_num</code> tactic it calls internally)     executes the cardinality function, simplifying <code>Fintype.card (Key 3)</code> to <code>8</code>. The     goal becomes <code>(8 : ENNReal)\u207b\u00b9 = 1/8</code>.</p> </li> <li> <p>Normalization. The <code>simp</code> engine has lemmas about <code>ENNReal</code> arithmetic.     It knows that <code>8\u207b\u00b9</code> is the same as <code>1/8</code>.</p> </li> <li> <p>Reflexivity. The goal becomes <code>1/8 = 1/8</code>. <code>simp</code> reduces both sides to the     same term, and the final <code>rfl</code> tactic confirms this equality and closes the goal.</p> </li> </ol>"},{"location":"crypto/otp/2025Jun19-notes/#the-equivalent-proof-term_2","title":"The Equivalent Proof Term","text":"<p>A term-based proof must explicitly provide proofs for each of these steps.</p> <pre><code>-- A lemma that proves card (Key 3) = 8\nhave card_proof : Fintype.card (Key 3) = 8 := by-- ... proof using vector cardinality lemmas\n\n-- We use this proof to rewrite the goal\n-- The goal becomes \u22a2 8\u207b\u00b9 = 1/8\n-- This is true by reflexivity, since 8\u207b\u00b9 is just notation for 1/8 in ENNReal.\n-- The final term is:\nrfl\n</code></pre> <p>The <code>simp</code> tactic automated the process of finding <code>card_proof</code>, applying it, and then seeing that the result was definitionally equal.</p> <p>The full proof term generated by our original <code>by simp [...]</code> is effectively a  composition of all these steps, applying congruence lemmas (<code>congr_arg</code>) and  transitivity (<code>Eq.trans</code>) to chain all the intermediate equalities together into one  grand proof that the starting expression equals the final one.</p>"},{"location":"crypto/otp/2025Jun19-notes/#summary-agda-perspective","title":"Summary &amp; Agda Perspective","text":"Tactic Proof Step What it Does Underlying Proof Term Concept <code>by simp [\u03bcK, ...]</code> A powerful, automatic rewrite sequence. A complex, generated term chaining together multiple equalities; a function that takes no arguments and returns a proof of <code>LHS = RHS</code>. <code>rw [\u03bcK]</code> Replaces <code>\u03bcK</code> with its definition. Application of <code>Eq.subst</code> or <code>Eq.rec</code> using definitional equality of <code>\u03bcK</code>. <code>rw [lem]</code> Rewrites goal using a proven lemma <code>lem : A = B</code>. Application of <code>Eq.subst</code> using lemma <code>lem</code> as proof of equality. <code>rfl</code> Solves a goal of the form <code>A = A</code>. The constructor for equality, <code>Eq.refl A</code>; it's a direct proof object. <ul> <li> <p>From an Agda perspective, a tactic proof is essentially a program that writes a    proof term, which is why tactic writing is metaprogramming.</p> </li> <li> <p><code>simp</code> is a very high-level command, like a call to a complex library, while <code>rw</code>    and <code>rfl</code> are more like fundamental operations.</p> </li> </ul> <p>This first example was heavy on <code>simp</code>. Next, let's tackle a proof that requires more manual, step-by-step tactics like <code>intro</code>, <code>apply</code>, and <code>let</code>, which have even clearer one-to-one correspondences with proof-term constructs like <code>fun</code>, function application, and <code>let ... in ...</code>.</p>"},{"location":"crypto/otp/2025Jun19-notes/#part-2-deconstructing-a-compositional-proof-with-bind-and-pure","title":"Part 2: Deconstructing a Compositional Proof with <code>bind</code> and <code>pure</code>","text":"<p>For our next step, we move beyond proofs that are solved by a single <code>simp</code> command and into a more structured proof that requires several foundational tactics.</p> <p>We will prove a fundamental property about the ciphertext distribution <code>\u03bcC</code>, which we defined last time using <code>bind</code> and <code>pure</code>.</p> <p>This give us the perfect opportunity to explore tactics like <code>rw</code>, <code>intro</code>, and <code>apply</code>, and examine their corresponding proof term constructions.</p>"},{"location":"crypto/otp/2025Jun19-notes/#recall-construction-of-c","title":"Recall construction of <code>\u03bcC</code>","text":"<p>Last time we saw that the ciphertext distribution <code>\u03bcC</code> can be constructed by chaining two probabilistic processes:</p> <ol> <li> <p>Sample a message <code>m</code> and a key <code>k</code> from their joint distribution <code>\u03bcMK</code>.</p> </li> <li> <p>Deterministically compute the ciphertext <code>c = encrypt m k</code>.</p> </li> </ol> <p>We captured this nicely in Lean as follows:</p> <pre><code>\u03bcC = bind \u03bcMK (\u03bb mk =&gt; pure (encrypt mk.1 mk.2))\n</code></pre> <p>Let's prove a theorem that shows what this actually means when we compute the probability of a specific ciphertext <code>c</code>.</p> <p>The law of total probability says that <code>P(C=c)</code> is the sum of probabilities of all <code>(m, k)</code> pairs that produce <code>c</code>.</p> <p>Theorem</p> <pre><code>\u03bcC c = \u2211' (\u27e8m , k\u27e9 : Plaintext n \u00d7 Key n), if encrypt m k = c then \u03bcMK \u27e8m , k\u27e9 else 0\n</code></pre> <p>Proving this will require unpacking the meaning of <code>bind</code> and <code>pure</code>.</p>"},{"location":"crypto/otp/2025Jun19-notes/#step-0-setup-for-the-proof","title":"Step 0: Setup for the Proof","text":"<p>First we add the necessary definitions to our Lean file.</p> <p>We need <code>Plaintext</code>s, an encryption function, and the distributions <code>\u03bcMK</code> and <code>\u03bcC</code>.</p> <p>For simplicity, we use a simple xor for encryption and assume a uniform distribution for messages.</p> <pre><code>/-!\n## Part 2: Deconstructing `bind` and `pure`\n-/\n\n-- Assume a uniform distribution on messages for this example.\nnoncomputable def \u03bcM {n : \u2115} : PMF (Plaintext n) := PMF.uniformOfFintype (Plaintext n)\n\n-- The joint distribution assumes independence of message and key.\n-- This is a manual construction of the product distribution P(m, k) = P(m) * P(k).\nnoncomputable def \u03bcMK {n : \u2115} : PMF (Plaintext n \u00d7 Key n) :=\n  PMF.bind \u03bcM (\u03bb m =&gt; PMF.map (\u03bb k =&gt; (m, k)) \u03bcK)\n\n-- The ciphertext distribution, built with bind and pure.\nnoncomputable def \u03bcC {n : \u2115} : PMF (Ciphertext n) :=\n  PMF.bind \u03bcMK (\u03bb \u27e8m, k\u27e9 =&gt; PMF.pure (encrypt m k))\n</code></pre> <p>The law of total probability says that <code>P(C=c)</code> is the sum of probabilities of all <code>(m, k)</code> pairs that produce <code>c</code>.</p> <p>Theorem</p> <p><code>\u03bcC c = \u2211' (mk : Plaintext n \u00d7 Key n), if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0</code></p>"},{"location":"crypto/otp/2025Jun19-notes/#the-proof-step-by-step","title":"The Proof Step-by-Step","text":"<p>Here is the complete, corrected proof in Lean: <pre><code>open Classical\ntheorem \u03bcC_apply_eq_sum {n : \u2115} (c : Ciphertext n) :\n  \u03bcC c = \u2211' mk : Plaintext n \u00d7 Key n, if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0\n  := by\n  rw [\u03bcC, PMF.bind_apply]\n  simp only [PMF.pure_apply, mul_boole]\n  congr 1\n  ext mk\n  simp only [eq_comm]\n</code></pre></p>"},{"location":"crypto/otp/2025Jun19-notes/#step-1-unfold-bind","title":"Step 1: Unfold <code>bind</code>","text":"<p>Tactics. <code>rw [\u03bcC, PMF.bind_apply]</code></p> <ul> <li> <p><code>rw [\u03bcC]</code>: as before, this is a substitution.</p> <p>It replaces <code>\u03bcC</code> with its definition, <code>PMF.bind \u03bcMK ...</code>.</p> <p>The proof term equivalent is <code>Eq.subst</code>.</p> </li> <li> <p><code>rw [PMF.bind_apply]</code>: this is the core of Step 1.</p> <p><code>PMF.bind_apply</code> is a theorem in Mathlib that states:</p> <pre><code>(PMF.bind p f) y = \u2211' x, p x * (f x) y\n</code></pre> <p>This is a formal expression of the law of total probability.</p> <p><code>rw</code> finds this lemma and mechanically rewrites the lhs of our goal to match it.</p> </li> </ul>"},{"location":"crypto/otp/2025Jun19-notes/#step-1-unfold-pure","title":"Step 1: Unfold <code>pure</code>","text":"<p>\ud83e\udd45 Goal State \ud83e\udd45</p> <pre><code>n : \u2115\nc : Ciphertext n\n\u22a2 \u2211' (a : Plaintext n \u00d7 Key n),\n    \u03bcMK a * (match a with | (m, k) =&gt; PMF.pure (encrypt m k)) c\n= \u2211' (mk : Plaintext n \u00d7 Key n), if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0\n</code></pre> <p>Tactics. <code>simp only [PMF.pure_apply, mul_boole]</code></p> <ul> <li><code>PMF.pure_apply</code> says <code>(pure a) b</code> is 1 if <code>a = b</code> and 0 otherwise.</li> </ul> <p><code>simp</code> is smart enough to apply this inside the summation.</p> <ul> <li><code>mul_boole</code> simplifies multiplication with the indicator function.</li> </ul> <p>It turns the <code>if</code> into a multiplication by <code>1</code> or <code>0</code>.</p> <p>\ud83e\udd45 Goal State After the Tactics \ud83e\udd45</p> <pre><code>\u22a2 (\u2211' mk, if c = encrypt mk.1 mk.2 then \u03bcMK mk else 0)\n= (\u2211' mk, if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0)\n</code></pre> <p>Now the only difference between the two sides is the order of the equality:</p> <p><code>c = ...</code> versus <code>... = c</code>.</p>"},{"location":"crypto/otp/2025Jun19-notes/#step-2-aligning-the-summations","title":"Step 2: Aligning the Summations","text":"<p>We need to show the bodies of the two summations are equal.</p> <p>Tactics. <code>congr 1; ext mk</code></p> <ul> <li> <p><code>congr 1</code>. This \"congruence\" tactic focuses the proof on the first arguments of the   equality\u2014in this case, the functions inside the summations <code>\u2211'</code>.</p> </li> <li> <p><code>ext mk</code>. This \"extensionality\" tactic then states we can prove the two functions   are equal by proving they are equal for an arbitrary input, which it names <code>mk</code>.</p> </li> </ul> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>mk: Plaintext n \u00d7 Key n\n\u22a2 (if c = encrypt mk.1 mk.2 then \u03bcMK mk else 0) = (if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0)\n</code></pre>"},{"location":"crypto/otp/2025Jun19-notes/#step-3-finishing-with-eq_comm","title":"Step 3: Finishing with <code>eq_comm</code>","text":"<p>Now we just resolve the switched equality.</p> <p>Tactic. <code>simp only [eq_comm]</code></p> <ul> <li>The lemma <code>eq_comm</code> states that <code>a = b</code> is equivalent to <code>b = a</code>. <code>simp</code> uses this   to rewrite the goal, making the two sides identical and closing the proof.</li> </ul>"},{"location":"crypto/otp/2025Jun19-notes/#part-3-proving-a-cryptographic-property-one-time-pad","title":"Part 3: Proving a Cryptographic Property (One-Time Pad)","text":"<p>The standard way to prove the perfect secrecy of OTP is to show that for any fixed plaintext <code>m</code>, the conditional distribution of ciphertexts is uniform.</p>"},{"location":"crypto/otp/2025Jun19-notes/#step-0-setup-for-the-proof_1","title":"Step 0: Setup for the Proof","text":"<p>We define the conditional distribution <code>\u03bcC_M m</code> by mapping the encryption function over the uniform key distribution.</p> <pre><code>-- The distribution of ciphertexts, conditioned on a fixed message `m`.\nnoncomputable def \u03bcC_M {n : \u2115} (m : Plaintext n) : PMF (Ciphertext n) :=\n  PMF.map (encrypt m) \u03bcK\n</code></pre> <p>Our goal is to prove that this distribution is uniform.</p> <p>Theorem: <code>\u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)</code></p>"},{"location":"crypto/otp/2025Jun19-notes/#a-detour-into-equivalences","title":"A Detour into Equivalences (<code>\u2243</code>)","text":"<p>Key mathematical insight: for a fixed <code>m</code>, the function <code>encrypt m</code> is a bijection.</p> <p>In Lean, such a bijection is captured by the type <code>Equiv</code>, written <code>\u03b1 \u2243 \u03b2</code>.</p>"},{"location":"crypto/otp/2025Jun19-notes/#what-is-an-equiv","title":"What is an <code>Equiv</code>?","text":"<p>An <code>Equiv</code> is a structure that bundles a function, its inverse, and proofs that they are indeed inverses of each other. It represents an isomorphism between types.</p> <p>The formal definition in Mathlib is: <pre><code>structure Equiv (\u03b1 : Sort*) (\u03b2 : Sort*) where\n  toFun    : \u03b1 \u2192 \u03b2        -- The forward function\n  invFun   : \u03b2 \u2192 \u03b1        -- The inverse function\n  left_inv  : Function.LeftInverse invFun toFun   -- proof of invFun (toFun x) = x\n  right_inv : Function.RightInverse invFun toFun  -- proof of toFun (invFun y) = y\n</code></pre></p>"},{"location":"crypto/otp/2025Jun19-notes/#how-to-construct-an-equiv-intro","title":"How to Construct an <code>Equiv</code> (Intro)","text":"<p>There are two main ways to build an equivalence.</p> <ol> <li> <p>From an Involutive Function (High-Level)</p> <p>If a function is its own inverse, like <code>not</code> or our <code>encrypt m</code>, you can use the constructor <code>Equiv.ofInvolutive</code>.</p> <pre><code>-- Helper lemma: For a fixed message m, encryption is its own inverse.\nlemma encrypt_involutive {n : \u2115} (m : Plaintext n) :\n  Function.Involutive (encrypt m) := by ...\n\n-- We build the Equiv directly from this property.\ndef encrypt_equiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n :=\n  Equiv.ofInvolutive (encrypt m) (encrypt_involutive m)\n</code></pre> </li> <li> <p>By Hand (Low-Level)</p> <p>You can construct one by providing all four fields. This is useful for simple cases.</p> <pre><code>-- An equivalence between Bool and Bool using `not`.\ndef not_equiv : Bool \u2243 Bool where\n  toFun    := not\n  invFun   := not\n  left_inv  := Bool.not_not\n  right_inv := Bool.not_not\n</code></pre> </li> </ol>"},{"location":"crypto/otp/2025Jun19-notes/#how-to-use-an-equiv-elim","title":"How to Use an <code>Equiv</code> (Elim)","text":"<p>Once you have an <code>Equiv</code>, you can use it in several ways.</p> <ol> <li> <p>As a Function. Lean knows how to treat an <code>Equiv</code> <code>e</code> as a function. You can just write <code>e x</code>.</p> </li> <li> <p>Accessing the Inverse. The inverse is available as <code>e.symm</code>. So you can write <code>e.symm y</code>.</p> </li> <li> <p>Using the Proofs. The proofs <code>e.left_inv</code> and <code>e.right_inv</code> are powerful tools for rewriting.</p> </li> </ol> <pre><code>example (e : \u03b1 \u2243 \u03b2) (x : \u03b1) : e.symm (e x) = x := by\n  -- The goal is exactly the statement of the left_inv property.\n  simp [e.left_inv]\n</code></pre> <ul> <li> <p>Understanding how to construct and use equivalences is crucial for many proofs    involving bijections.</p> </li> <li> <p>The final step of our OTP theorem would be to find the right Mathlib lemma that    uses this <code>encrypt_equiv</code> to prove that the <code>map</code> of a uniform distribution is    still uniform.</p> </li> </ul>"},{"location":"crypto/otp/2025Jun19-notes/#next","title":"Next","text":"<ol> <li> <p>A detailed Markdown explanation of our proof for <code>otp_perfect_secrecy_lemma</code>.</p> </li> <li> <p>An explanation for why <code>encrypt_equiv</code> must be <code>noncomputable</code> while <code>xorEquiv</code> is not.</p> </li> </ol> <p>Let's tackle the <code>noncomputable</code> question first, as it's a deep and important concept in Lean.</p>"},{"location":"crypto/otp/2025Jun19-notes/#computable-vs-noncomputable-definitions","title":"Computable vs. Noncomputable Definitions","text":"<p>The reason one definition is <code>noncomputable</code> and the other is not comes down to how the inverse function is provided.</p> <p>It's a classic case of being constructive versus classical.</p>"},{"location":"crypto/otp/2025Jun19-notes/#def-xorequiv-constructive","title":"<code>def xorEquiv</code> (Constructive)","text":"<pre><code>def xorEquiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n where\n  toFun     := encrypt m\n  invFun    := vec_xor m -- We explicitly provide the inverse function\n  left_inv  := by ...\n  right_inv := by ...\n</code></pre> <p>Here, we create the <code>Equiv</code> structure by hand. We provide all four components:</p> <ol> <li> <p><code>toFun</code>: The forward function, <code>encrypt m</code>.</p> </li> <li> <p><code>invFun</code>: The inverse function, <code>vec_xor m</code>. We explicitly construct and provid this function.</p> </li> <li> <p><code>left_inv</code>: A proof that <code>vec_xor m (encrypt m k) = k</code>.</p> </li> <li> <p><code>right_inv</code>: A proof that <code>encrypt m (vec_xor m c) = c</code>.</p> </li> </ol> <p>Because every component is explicitly defined and computable, the entire <code>xorEquiv</code> definition is computable.</p>"},{"location":"crypto/otp/2025Jun19-notes/#noncomputable-def-encrypt_equiv-classical","title":"<code>noncomputable def encrypt_equiv</code> (Classical)","text":"<pre><code>noncomputable def encrypt_equiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n :=\n  Equiv.ofBijective (encrypt m) (encrypt_bijective m)\n</code></pre> <p>Here, we use the high-level constructor <code>Equiv.ofBijective</code>. We provide it with:</p> <ol> <li> <p>A function, <code>encrypt m</code>.</p> </li> <li> <p>A proof, <code>encrypt_bijective m</code>, which proves that the function is both injective and surjective.</p> </li> </ol> <p>But notice what's missing: we never told Lean what the inverse function is!</p> <p>The <code>Equiv.ofBijective</code> constructor has to create the inverse function for us.</p> <p>How does it do that?  It uses the proof of surjectivity.</p> <p>A proof of <code>Surjective (encrypt m)</code> says \"for every ciphertext <code>c</code>, there exists a key <code>k</code> such that <code>encrypt m k = c</code>.\"</p> <p>To define an inverse function, Lean must choose such a <code>k</code> for each <code>c</code>.</p> <p>This act of choosing an object from a proof of its existence requires the axiom of choice (<code>Classical.choice</code>).</p> <p>In Lean's constructive logic, any definition that depends on the axiom of choice is marked as <code>noncomputable</code>.</p> <p>In short:</p> <ul> <li> <p><code>xorEquiv</code> is computable because we did the work of providing the inverse function constructively.</p> </li> <li> <p><code>encrypt_equiv</code> is noncomputable because we asked Lean to conjure the inverse function out of a classical existence proof, forcing it to use the noncomputable axiom of choice.</p> </li> </ul>"},{"location":"crypto/otp/2025Jun19-notes/#explaining-the-otp_perfect_secrecy_lemma-proof","title":"Explaining the <code>otp_perfect_secrecy_lemma</code> Proof","text":"<p>Theorem to Prove:</p> <pre><code>theorem otp_perfect_secrecy_lemma {n : \u2115} :\n    \u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> <p>The Proof, Explained: <pre><code>theorem otp_perfect_secrecy_lemma {n : \u2115} :\n    \u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n) := by\n  intro m\n  have h\u03bc : \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n) := by\n    apply map_uniformOfFintype_equiv (xorEquiv m)\n  simp [h\u03bc, PMF.uniformOfFintype_apply]\n</code></pre></p> <ul> <li> <p>Tactic <code>intro m</code></p> <ul> <li>What it does: The proof begins by addressing the \"for all <code>m</code>\" part of the theorem.</li> </ul> <p>The <code>intro</code> tactic introduces an arbitrary but fixed message <code>m</code> that we can work with for the rest of the proof.</p> <ul> <li> <p>Goal State:</p> <pre><code>m: Plaintext n\n\u22a2 \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> </li> </ul> </li> <li> <p>Tactic <code>have h\u03bc : ... := by ...</code></p> <ul> <li> <p>What it does: This is the main logical step. The <code>have</code> tactic lets us prove a helper fact, or lemma, which we can then use to prove our main goal. Here, we are proving a fact named <code>h\u03bc</code>. Coincidentally, <code>h\u03bc</code> is the exact statement of our main goal.</p> </li> <li> <p>The Sub-Proof: The proof of <code>h\u03bc</code> is <code>apply map_uniformOfFintype_equiv (xorEquiv m)</code>. This applies the helper lemma you proved earlier, which states that mapping a uniform distribution over an equivalence (<code>xorEquiv m</code>) results in a uniform distribution. This single line brilliantly captures the core mathematical argument.</p> </li> <li> <p>Goal State (after the <code>have</code> block is complete):</p> <pre><code>m: Plaintext n\nh\u03bc: \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n\u22a2 \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> </li> </ul> </li> <li> <p>Tactic <code>simp [h\u03bc, PMF.uniformOfFintype_apply]</code></p> <ul> <li> <p>What it does: This tactic finishes the proof using the fact <code>h\u03bc</code> we just proved. The <code>simp [h\u03bc]</code> part tells Lean to rewrite the goal using <code>h\u03bc</code>.</p> </li> <li> <p>How it Works: <code>simp</code> sees <code>\u03bcC_M m</code> on the left side of the goal <code>\u22a2</code> and sees the hypothesis <code>h\u03bc</code> which states <code>\u03bcC_M m = ...</code>. It substitutes the left side with the right side of <code>h\u03bc</code>.</p> </li> <li> <p>Goal State (after <code>simp [h\u03bc]</code>):</p> <pre><code>\u22a2 PMF.uniformOfFintype (Ciphertext n) = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> </li> <li> <p>This goal is true by reflexivity, and <code>simp</code> is able to solve it completely. (The extra <code>PMF.uniformOfFintype_apply</code> is not strictly necessary here, as <code>h\u03bc</code> is sufficient, but it doesn't hurt). A more direct way to finish after the <code>have</code> block would simply be <code>exact h\u03bc</code>.</p> </li> </ul> </li> </ul>"},{"location":"crypto/otp/WhyExtendedNNReals/","title":"Deep Dive","text":""},{"location":"crypto/otp/WhyExtendedNNReals/#why-use-0-for-the-codomain-of-a-distribution","title":"Why use [0, \u221e] for the codomain of a distribution?","text":"<ul> <li>Probabilities should be in [0, 1] by definition.</li> <li>If p + q &gt; 1, then p + q isn't a probability of anything.</li> <li>A rich type system should enforce this constraint.</li> <li>Having to prove preservation of [0, 1] keeps us mathematically honest.</li> </ul> <p>So why did Mathlib choose <code>ENNReal</code>?  The reasons are probably subtle, but we can at least speculate and provide some food for thought and further discussion.</p> <ol> <li> <p>Integration with Measure Theory. (pardon the pun)</p> <p>In measure theory, measures assign values in [0,\u221e] to sets.</p> <p>The measure of a set <code>S</code>, denoted <code>\u03bc S</code>, is an extended nonnegative real.</p> <p>A measure <code>\u03bc</code> is called a probability measure if <code>\u03bc univ = 1</code>.</p> <p>The designers of Mathlib likely wanted PMFs that integrate seamlessly with the measure theory library, where <code>ENNReal</code> is standard.</p> <p>Measures and outer measures in Mathlib</p> <pre><code>/-- An outer measure is a countably subadditive monotone function that sends `\u2205` to `0`.\n-/\nstructure OuterMeasure (\u03b1 : Type*) where\n  protected measureOf : Set \u03b1 \u2192 \u211d\u22650\u221e\n  protected empty : measureOf \u2205 = 0\n  protected mono : \u2200 {s\u2081 s\u2082}, s\u2081 \u2286 s\u2082 \u2192 measureOf s\u2081 \u2264 measureOf s\u2082\n  protected iUnion_nat : \u2200 s : \u2115 \u2192 Set \u03b1, Pairwise (Disjoint on s) \u2192\n    measureOf (\u22c3 i, s i) \u2264 \u2211' i, measureOf (s i)\n\n/-- A measure is defined to be an outer measure that is countably additive on\nmeasurable sets, with the assumption that the outer measure is the canonical\nextension of the restricted measure.\n-/\nstructure Measure (\u03b1 : Type*) [MeasurableSpace \u03b1] extends OuterMeasure \u03b1\n  where m_iUnion \u2983f : \u2115 \u2192 Set \u03b1\u2984 :\n  (\u2200 i, MeasurableSet (f i)) \u2192 Pairwise (Disjoint on f) \u2192\n    toOuterMeasure (\u22c3 i, f i) = \u2211' i, toOuterMeasure (f i)\n\nclass IsProbabilityMeasure (\u03bc : Measure \u03b1) : Prop where\n  measure_univ : \u03bc univ = 1\n</code></pre> </li> <li> <p>Division Conventions</p> <p><code>ENNReal</code> has specific conventions that make probability formulas work. These would be messier and require more special case analysis with a [0, 1] type.</p> <p>Division in <code>EENReal</code></p> <pre><code>-- In ENNReal:\n0 / 0 = 0    -- Makes conditional probability P(A|B) work when P(B) = 0\nx / \u221e = 0    -- Handles certain limit cases\nx / 0 = \u221e    -- for x &gt; 0\n</code></pre> </li> </ol>"},{"location":"crypto/otp/WhyExtendedNNReals/#the-pragmatic-compromise","title":"The Pragmatic Compromise","text":"<p>Philosophically, a <code>Probability</code> type should be:</p> <pre><code>def Probability := {x : \u211d // 0 \u2264 x \u2227 x \u2264 1}\n</code></pre> <p>And operations should return proofs:</p> <pre><code>def prob_or (p q : Probability) (h : disjoint) : Probability :=\n  \u27e8p.val + q.val, by proof_that_sum_le_1\u27e9\n</code></pre> <p>Mathlib probably chose <code>ENNReal</code> for pragmatic reasons:</p> <ol> <li>Compatibility with measure theory (the bigger framework)</li> <li>Computational convenience (limits and sums \"just work\")</li> <li>Mathematical practice (probabilists often work with unnormalized measures)</li> </ol> <p>But this loses \"type safety.\" A more principled approach might have:</p> <pre><code>-- The \"right\" design?\nstructure PMF (\u03b1 : Type*) where\n  val : \u03b1 \u2192 Probability  -- Each value is certified in [0,1]\n  has_sum_one : \u2211 val = 1\n</code></pre>"},{"location":"crypto/otp/WhyExtendedNNReals/#final-thoughts","title":"Final Thoughts","text":""},{"location":"crypto/otp/WhyExtendedNNReals/#honest-bottom-line","title":"Honest Bottom Line","text":"<p>A real tension in library design:</p> <ul> <li>Type safety says: enforce invariants in types</li> <li>Pragmatism says: make it compatible with existing math</li> <li>Mathlib chose pragmatism over purity here</li> </ul>"},{"location":"crypto/otp/WhyExtendedNNReals/#summary","title":"Summary","text":"<ul> <li> <p>Mathlib uses [0, \u221e] for probability values, which might seem wrong---probabilities    should be in [0,1]!</p> </li> <li> <p>A pragmatic choice for integration with measure theory and handling limits.</p> </li> <li> <p>In a perfect world, we might use a <code>Probability</code> type that restricts inhabitants    to [0, 1].</p> </li> <li> <p>Mathlib prioritizes compatibility with the broader mathematical ecosystem over type safety here.</p> </li> </ul>"},{"location":"crypto/otp/a-first-proof/","title":"A Fist Concrete Proof","text":"<p>We will demonstrate not only how to prove properties in Lean but also why the methods work, connecting the seemingly magical world of tactics to the solid ground of proof objects, with which we are more familiar from Agda.</p> <p>We'll start by reviewing a concrete, fundamental example: computing the probability of choosing a specific binary vector (key) at random.</p> <p>This will allow us to bring the ideas down to earth and immediately dive into and discuss the tactic vs. proof object dichotomy.</p> <p>Let's start with the</p> <p>Claim. The probability of randomly choosing a specific 3-bit key is 1/8.</p> <p>In Lean, the theorem and its tactic-based proof are very concise.</p> <p>But before we get to the proof, we need to formally state the claim!</p> <p>For this we first define the uniform distribution over keys as follows.</p> <pre><code>import Mathlib.Probability.Distributions.Uniform\n\n-- (Assuming a file OTP.Basic with the definition of Key)\nopen OTP\n-- Recall, we define `Key n` as vectors of booleans.\n-- This is equivalent to `Fin n \u2192 Bool` or other n-bit types.\n\n-- Here is the uniform distribution over keys of length n.\nnoncomputable def \u03bcK {n : \u2115} : PMF (Key n) := PMF.uniformOfFintype (Key n)\n</code></pre> <p>Now we can state the claim along with its short proof.</p> <pre><code>-- Claim: the probability of choosing key [true, false, true] is 1/8.\nexample : \u03bcK \u27e8[true, false, true], rfl\u27e9 = (1/8 : ENNReal) :=\n -- and here's the tactic-based proof in Lean:\n  by simp [\u03bcK, PMF.uniformOfFintype_apply]; rfl\n</code></pre> <p>This is great for a user who knows what <code>simp</code> means and does, but it may seem like a magical incantation for the newcomer. So we should unpack it.</p> <p>Also, we should address the following natural question after dissecting the proof.</p> <p>Why is our uniform distribution marked <code>noncomputable</code>?</p>"},{"location":"crypto/otp/a-first-proof/#dissecting-the-proof","title":"Dissecting the Proof","text":""},{"location":"crypto/otp/a-first-proof/#deconstructing-simp","title":"Deconstructing <code>simp</code>","text":"<p>The <code>simp</code> tactic is an automated rewriter.</p> <p>It tries to simplify the main goal by applying a list of theorems (called a \"simpset\") from left to right, over and over, until no more simplifications can be made.</p> <p>When you write <code>simp [foo, bar]</code>, you are telling Lean:</p> <p>\"Please use your standard simpset, plus the definitions/lemmas <code>foo</code> and <code>bar</code> to the set of tools you can use to simplify or reduce the goal.\"</p>"},{"location":"crypto/otp/a-first-proof/#step-1-unfolding-the-definition-of-k","title":"Step 1: Unfolding the Definition of <code>\u03bcK</code>","text":"<p>Let's break down the proof step-by-step, showing the tactic at each stage, and then discuss the proof object it's building.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 \u03bcK \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>Here, <code>\u22a2</code> indicates the goal we are trying to prove.</p> <p>The Tactic <code>simp [\u03bcK]</code> or <code>rw [\u03bcK]</code></p> <p>tells Lean to substitute <code>\u03bcK</code> with its definition.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>\u22a2 PMF.uniformOfFintype (Key 3) \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre>"},{"location":"crypto/otp/a-first-proof/#why-this-works","title":"Why this works","text":"<p>Looking under the hood,</p> <ul> <li> <p><code>\u03bcK</code> is defined as <code>PMF.uniformOfFintype (Key n)</code>.</p> </li> <li> <p><code>simp</code> (and the more targeted <code>rw</code>) can access all definitions in context.</p> </li> <li> <p>It sees the term <code>\u03bcK</code> in the goal and replaces it with its definition; a   simple substitution.</p> </li> </ul> The Equivalent Proof Term <p>In a term-based proof, the substitution is achieved using functions that show equality is respected by function application.</p> <p>If we have a proof <code>h : \u03bcK = PMF.uniformOfFintype (Key 3)</code>, we can use it to rewrite the goal.</p> <p>The definition itself provides this proof <code>h</code>. The core idea is <code>Eq.subst</code> or <code>Eq.rec</code>.</p> <p>A proof term for just this step would look like this:</p> <pre><code>-- Let P be the property we are trying to prove for the definition.\n-- P := \u03bb x =&gt; x \u27e8[true, false, true], _\u27e9 = 1/8\n-- Our goal is `P (\u03bcK)`\n-- The definition of \u03bcK gives us `proof_of_definition : \u03bcK = PMF.uniformOfFintype (Key 3)`\n\n-- The new proof term is:\nEq.subst proof_of_definition (new_goal : P (PMF.uniformOfFintype (Key 3)))\n</code></pre> <p>...which is a bit clunky.</p> <p>A more common term-based idiom is to simply start with the definition already unfolded.</p> <p>The tactic <code>rw</code> is essentially a mechanical way of applying <code>Eq.subst</code>.</p> Lean Feature: revealing proof terms <p>We can get Lean to reveal proof objects that are generated by tactics, and sometimes the result is even readable and comprehensible by mortal human beings.</p> <p>The Feature</p> <p>Lean has a tactic called <code>show_term</code>.</p> <p>It executes the tactics within it and then, instead of closing the goal, it prints the raw proof term that was generated.</p> <p>How to Demonstrate It:</p> <ol> <li> <p>Pick a simple proof, like our very first one.</p> </li> <li> <p>In VS Code, change the proof to</p> <pre><code>-- Our theorem: The probability of the key [true, false, true] is 1/8.\nexample : \u03bcK \u27e8[true, false, true], rfl\u27e9 = (1/8 : ENNReal) := by\n  show_term -- Add this tactic\n    simp [\u03bcK, PMF.uniformOfFintype_apply]; rfl\n</code></pre> </li> <li> <p>When the cursor is on the <code>show_term</code> line, the \"Lean Infoview\" panel will display the generated proof term.</p> </li> <li> <p>Warning (and the point)</p> <p>The term is long, ugly, and full of machine-generated names.</p> <p>It looks something like <code>Eq.trans (PMF.uniformOfFintype_apply ... ) (congr_arg Inv.inv (Fintype.card_vector ...))</code>.</p> </li> <li> <p>Explanation</p> <p>For Agda developers, it's natural to ask: where is the proof object?</p> <p>Tactic proofs generate proof objects. We can ask Lean to show us the term it generated using the <code>show_term</code> tactic.</p> <p>Apparently, the result is extremely verbose and not really meant for human consumption.</p> <p>This is the fundamental trade-off: tactics let us write short, conceptual proofs at the expense of creating these complex, machine-readable proof terms under the hood.</p> </li> </ol>"},{"location":"crypto/otp/a-first-proof/#step-2-unfolding-definition-of-uniform-pmf","title":"Step 2: Unfolding Definition of Uniform PMF","text":"<p>Now we apply the definition of what <code>uniformOfFintype</code> evaluates to for a given input.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 PMF.uniformOfFintype (Key 3) \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>The Tactic <code>simp [PMF.uniformOfFintype_apply]</code></p> <p>The lemma <code>PMF.uniformOfFintype_apply</code> states:</p> <p>If <code>a</code> is an inhabitant of the finite type <code>\u03b1</code>, then</p> <p><code>PMF.uniformOfFintype \u03b1 a</code> is equal to <code>(Fintype.card \u03b1)\u207b\u00b9</code>.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>\u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre>"},{"location":"crypto/otp/a-first-proof/#why-this-works_1","title":"Why this works","text":"<p>Looking under the hood,</p> <ul> <li> <p><code>simp</code> finds a lemma <code>PMF.uniformOfFintype_apply</code> in the library;</p> </li> <li> <p>This lemma matches the pattern <code>PMF.uniformOfFintype (Key 3) ...</code> on the lhs of our goal;</p> </li> <li> <p><code>simp</code> using the lemma to rewrites the lhs as <code>(Fintype.card (Key 3))\u207b\u00b9</code>.</p> </li> </ul> The Equivalent Proof Term <p>This is a direct application of the lemma.</p> <p>The proof term for the rewrite is <code>PMF.uniformOfFintype_apply (Key 3) \u27e8...\u27e9</code>.</p> <p>Applying this equality to our goal transforms it.</p> <p>A proof would look like:</p> <pre><code>-- h\u2081 : PMF.uniformOfFintype (Key 3) \u27e8...\u27e9 = (Fintype.card (Key 3))\u207b\u00b9\n-- This comes from the lemma PMF.uniformOfFintype_apply\n-- We use this to transform the goal into proving:\n-- \u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> <p>This is again a form of <code>Eq.subst</code>.</p> <p>The <code>rw</code> tactic is the most direct parallel: <code>rw [PMF.uniformOfFintype_apply]</code>.</p>"},{"location":"crypto/otp/a-first-proof/#step-3-computing-the-cardinality-and-final-simplification","title":"Step 3: Computing the Cardinality and Final Simplification","text":"<p>This is where <code>simp</code> really shines by combining computation and proof.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> <p>The Tactic <code>simp; rfl</code></p> <p>We don't need to provide any more lemmas. The rest is handled by Lean's built-in capabilities.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <p>The goal is solved!</p>"},{"location":"crypto/otp/a-first-proof/#why-this-works_2","title":"Why this works","text":"<p>Looking under the hood,</p> <ol> <li> <p>Typeclass Inference. Lean needs to know the size of <code>Key 3</code>. The type <code>Key 3</code>,     which is <code>Vector Bool 3</code>, has an instance of the <code>Fintype</code> typeclass. This     instance provides a computable function to get the number of elements.</p> </li> <li> <p>Computation. The <code>simp</code> tactic (or the <code>norm_num</code> tactic it calls internally)     executes the cardinality function, simplifying <code>Fintype.card (Key 3)</code> to <code>8</code>. The     goal becomes <code>(8 : ENNReal)\u207b\u00b9 = 1/8</code>.</p> </li> <li> <p>Normalization. The <code>simp</code> engine has lemmas about <code>ENNReal</code> arithmetic.     It knows that <code>8\u207b\u00b9</code> is the same as <code>1/8</code>.</p> </li> <li> <p>Reflexivity. The goal becomes <code>1/8 = 1/8</code>. <code>simp</code> reduces both sides to the     same term, and the final <code>rfl</code> tactic confirms this equality and closes the goal.</p> </li> </ol> The Equivalent Proof Term <p>A term-based proof must explicitly provide proofs for each of these steps.</p> <pre><code>-- A lemma that proves card (Key 3) = 8\nhave card_proof : Fintype.card (Key 3) = 8 := by-- ... proof using vector cardinality lemmas\n\n-- We use this proof to rewrite the goal\n-- The goal becomes \u22a2 8\u207b\u00b9 = 1/8\n-- This is true by reflexivity, since 8\u207b\u00b9 is just notation for 1/8 in ENNReal.\n-- The final term is:\nrfl\n</code></pre> <p>The <code>simp</code> tactic automated the process of finding <code>card_proof</code>, applying it, and then seeing that the result was definitionally equal.</p> <p>The full proof term generated by our original <code>by simp [...]</code> is effectively a  composition of all these steps, applying congruence lemmas (<code>congr_arg</code>) and  transitivity (<code>Eq.trans</code>) to chain all the intermediate equalities together into one  grand proof that the starting expression equals the final one.</p> <p>Why <code>noncomputable</code>?</p> <p>This is subtle! Even though we're dealing with finite types, these definitions are <code>noncomputable</code> because:</p> <ol> <li> <p>Real Number Arithmetic</p> <pre><code>noncomputable def \u03bcK {n : \u2115} : PMF (Key n) := uniformOfFintype (Key n)\n</code></pre> <p>The probability values are in <code>\u211d\u22650\u221e</code> (extended non-negative reals), not rationals:</p> <ul> <li><code>1/2\u207f</code> is computed as real division, not rational division</li> <li>Real arithmetic is inherently noncomputable in constructive mathematics</li> <li>Even though we \"know\" the answer is rational, the type system uses reals</li> </ul> </li> <li> <p>Infinite Summations</p> <p>Even for finite types, PMF uses infinite summation machinery:</p> <pre><code>\u2211' a : \u03b1, p a  -- This is an infinite sum operator\n</code></pre> <ul> <li>The <code>\u2211'</code> notation works for both finite and infinite types.</li> <li>It's defined using limits and topology.</li> <li>Even when <code>\u03b1</code> is finite, we use the general machinery.</li> </ul> </li> <li> <p>Classical Logic</p> <p>PMF operations often use classical logic (excluded middle):</p> <pre><code>open Classical  -- Needed for many probability operations\n</code></pre> <p>This makes things noncomputable in Lean's constructive logic.</p> </li> </ol>"},{"location":"crypto/otp/a-first-proof/#why-can-we-still-prove-18","title":"Why Can We Still Prove <code>= 1/8</code>?","text":"<p>Here's the beautiful part:</p> <p>noncomputable doesn't mean we can't reason about values!</p>"},{"location":"crypto/otp/a-first-proof/#proofs-vs-computation","title":"Proofs vs Computation","text":"<pre><code>-- We can't compute this:\n#eval \u03bcK \u27e8[true, false, true], by decide\u27e9  -- Error: noncomputable\n\n-- But we CAN prove this:\nexample : \u03bcK \u27e8[true, false, true], by decide\u27e9 = 1/8 := by\n  simp [\u03bcK, uniformOfFintype_apply]\n  -- Proves that (card (Key 3))\u207b\u00b9 = 8\u207b\u00b9 = 1/8\n</code></pre>"},{"location":"crypto/otp/a-first-proof/#whats-happening","title":"What's Happening?","text":"<ol> <li> <p>Definitional unfolding: Even though <code>\u03bcK</code> is noncomputable, we can unfold its definition in proofs.</p> </li> <li> <p>Symbolic reasoning: We prove <code>1/card(Key 3) = 1/8</code> symbolically, not by computation.</p> </li> <li> <p>Type class inference: Lean knows <code>Fintype (Key 3)</code> and can reason about cardinalities.</p> </li> <li> <p>Real number lemmas: Mathlib has lemmas about real arithmetic that we use in proofs.</p> </li> </ol>"},{"location":"crypto/otp/a-first-proof/#the-philosophical-point","title":"The Philosophical Point","text":"<p>The separation of computation and reasoning is fundamental.</p> <ul> <li>Computation: Running an algorithm to get a concrete answer.</li> <li>Reasoning: Proving properties about mathematical objects.</li> </ul> <p>In formal mathematics, we often work with noncomputable objects (like real numbers, infinite sets, choice functions) but can still prove precise theorems about them.</p>"},{"location":"crypto/otp/a-first-proof/#summary","title":"Summary","text":"<ul> <li> <p>In Lean, probability distributions are functions from outcomes to probabilities, bundled with a proof that probabilities sum to 1.</p> </li> <li> <p>Even though we work with finite spaces, these are marked <code>noncomputable</code> because they use real number arithmetic and infinite summation machinery.</p> </li> <li> <p>This doesn't limit our reasoning---we can still prove exact results like \"each key has probability 1/8.\"</p> </li> <li> <p>The distinction between computation and proof is fundamental: we reason symbolically about these mathematical objects without needing to compute their values.</p> </li> <li> <p>Practical Analogy</p> <ul> <li>Computable: a calculator gives you 0.125 when you type 1 \u00f7 8.</li> <li>Noncomputable with proofs: we can show algebraically that 1/8 = 0.125 without calculating</li> </ul> <p>PMFs in Lean are the second kind---we work with them symbolically and prove properties, rather than computing decimal expansions.</p> </li> </ul>"},{"location":"crypto/otp/a-first-proof/#proof-term-perspective","title":"Proof Term Perspective","text":"Tactic Proof Step What it Does Underlying Proof Term Concept <code>by simp [\u03bcK, ...]</code> A powerful, automatic rewrite sequence. A complex, generated term chaining together multiple equalities; a function that takes no arguments and returns a proof of <code>LHS = RHS</code>. <code>rw [\u03bcK]</code> Replaces <code>\u03bcK</code> with its definition. Application of <code>Eq.subst</code> or <code>Eq.rec</code> using definitional equality of <code>\u03bcK</code>. <code>rw [lem]</code> Rewrites goal using a proven lemma <code>lem : A = B</code>. Application of <code>Eq.subst</code> using lemma <code>lem</code> as proof of equality. <code>rfl</code> Solves a goal of the form <code>A = A</code>. The constructor for equality, <code>Eq.refl A</code>; it's a direct proof object. <ul> <li> <p>From a constructive \"proof term\" perspective, a tactic proof is essentially a program that writes a    proof term, thus tactic writing is metaprogramming.</p> </li> <li> <p><code>simp</code> is a very high-level command, like a call to a complex library, while <code>rw</code>    and <code>rfl</code> are more like fundamental operations.</p> </li> </ul> <p>This first example was heavy on <code>simp</code>. Next, let's tackle a proof that requires more manual, step-by-step tactics like <code>intro</code>, <code>apply</code>, and <code>let</code>, which have even clearer one-to-one correspondences with proof-term constructs like <code>fun</code>, function application, and <code>let ... in ...</code>.</p>"},{"location":"crypto/otp/basic-probability-in-lean/","title":"Probability in L\u2203\u2200N","text":""},{"location":"crypto/otp/basic-probability-in-lean/#definition-of-probability","title":"\ud83c\udfb2 Definition of Probability","text":"<ul> <li> <p>\u03a9 denotes an outcome space</p> </li> <li> <p>\u03c9 \u2208 \u03a9 denotes an outcome (e.g., of an experiment, trial, etc.)</p> </li> <li> <p>An event \ud835\udc38 is a set of outcomes: \ud835\udc38 \u2286 \u03a9</p> </li> <li> <p>A probability mass function (pmf), or probability measure, on an outcome space is    a function \u2119 : \u03a9 \u2192 \u211d such that, for all events \ud835\udc38\u2080, \ud835\udc38\u2081, \u2026</p> <ul> <li>\u2119 \u2205 = 0 and \u2119 \u03a9 = 1</li> <li>0 \u2264 \u2119 \ud835\udc38\u1d62 \u2264 1</li> <li>\ud835\udc38\u1d62 \u2286 \ud835\udc38\u2c7c \u2192 \u2119 \ud835\udc38\u1d62 \u2264 \u2119 \ud835\udc38\u2c7c (monotone)</li> <li>\u2119(\u22c3 \ud835\udc38\u1d62) \u2264 \u2211 \u2119 \ud835\udc38\u1d62 (subadditive)</li> </ul> </li> </ul> <p>Mathlib's definition</p> <p>It's slightly more direct: it's a function <code>f : \u03b1 \u2192 NNReal</code> (non-negative reals) along with a proof <code>h : tsum f = 1</code> (the sum of <code>f a</code> over all <code>a : \u03b1</code> is 1). The other properties above (like monotonicity, probability of empty set being 0, etc.) can be derived from this.</p>"},{"location":"crypto/otp/basic-probability-in-lean/#distributions","title":"Distributions","text":""},{"location":"crypto/otp/basic-probability-in-lean/#what-is-a-pmf","title":"What is a PMF?","text":"<p>In Lean/Mathlib, a <code>PMF \u03b1</code> (Probability Mass Function) is defined as follows:</p> <pre><code>/-- A probability mass function, or discrete probability measures is\n  a function `\u03b1 \u2192 \u211d\u22650\u221e` such that the values have (infinite) sum `1`. -/\n\ndef PMF.{u} (\u03b1 : Type u) : Type u :=\n  { f : \u03b1 \u2192 \u211d\u22650\u221e // HasSum f 1 }\n</code></pre> <p>So a PMF is a pair</p> <ol> <li> <p>A function assigning probabilities to outcomes.</p> </li> <li> <p>A proof that these probabilities form a valid distribution.</p> </li> </ol> <p>Syntax: <code>{ _ // _ }</code></p> <p>In Lean the mathematical expression <code>{x : P x}</code> is written <code>{ x // P x }</code>.</p> <p>Example: <code>{n : Nat // n % 2 = 0}</code> is the type of even natural numbers.</p>"},{"location":"crypto/otp/basic-probability-in-lean/#crypto-distributions","title":"Crypto Distributions","text":"<ul> <li> <p><code>\u03bcM : PMF (Plaintext n)</code></p> <ul> <li>Type: A function <code>\u03bcM : Plaintext n \u2192 \u211d\u22650\u221e</code>, along with proof of <code>HasSum \u03bcM 1</code>.</li> <li>Meaning: For any n-bit message <code>m</code>, <code>\u03bcM m = P(M = m)</code>, the prob message <code>m</code> is sent.</li> <li>Example: If all messages equally likely, <code>\u03bcM m = 1/2^n</code> for all <code>m</code>.</li> </ul> </li> <li> <p><code>\u03bcK : PMF (Key n)</code></p> <ul> <li>Type: A function <code>\u03bcK : Key n \u2192 \u211d\u22650\u221e</code>, along with proof of <code>HasSum \u03bcK 1</code>.</li> <li>Meaning: For any n-bit key <code>k</code>, <code>\u03bcK k</code> is its probability, <code>P(K = k)</code>.</li> <li>Definition: <code>uniformOfFintype</code> makes <code>\u03bcK k = 1/2^n</code> for all <code>k</code></li> </ul> </li> <li> <p><code>\u03bcMK : PMF (Plaintext n \u00d7 Key n)</code></p> <ul> <li>Type: A function <code>\u03bcMK : Plaintext n \u00d7 Key n \u2192 \u211d\u22650\u221e</code>, with proof of <code>HasSum \u03bcMK 1</code>.</li> <li>Meaning: For message <code>m</code> and key <code>k</code>, <code>\u03bcMK (m, k)</code> = the joint prob <code>P(M = m, K = k)</code>.</li> <li>Value: <code>\u03bcMK (m, k) = \u03bcM m * \u03bcK k</code> (independence!)</li> </ul> </li> <li> <p><code>\u03bcC : PMF (Ciphertext n)</code></p> <ul> <li>Type: A function <code>\u03bcC : Ciphertext n \u2192 \u211d\u22650\u221e</code>,  along with proof of <code>HasSum \u03bcC 1</code>.</li> <li>Meaning: For any n-bit ciphertext <code>c</code>, <code>\u03bcC c</code> is probability of observing <code>c</code>.</li> <li>Computed: By summing over all <code>(m, k)</code> pairs that produce <code>c</code></li> </ul> </li> <li> <p><code>\u03bcC_M : Plaintext n \u2192 PMF (Ciphertext n)</code></p> <ul> <li>Type: A function that takes a message and returns a distribution on <code>Ciphertext n</code>.</li> <li>Meaning: For fixed message <code>m</code>, <code>\u03bcC_M m = P(C | M = m)</code>.</li> <li>Value: <code>(\u03bcC_M m) c = if \u2203k. encrypt m k = c then 1/2^n else 0</code></li> </ul> </li> </ul>"},{"location":"crypto/otp/basic-probability-in-lean/#mathlib-specifics","title":"Mathlib Specifics","text":"<p><code>Probability/ProbabilityMassFunction/</code></p> <p>\ud83d\udcc1 <code>Mathlib/Probability/ProbabilityMassFunction/Basic.lean</code></p> <ul> <li> <p>Often imported as <code>PMF</code>.</p> </li> <li> <p>It's the main tool for defining discrete random variables and their distributions.</p> </li> </ul> <p>\ud83d\udd11\ufe0f Key Concepts</p> <ul> <li> <p><code>PMF \u03b1</code> represents a probability mass function (pmf) over a type <code>\u03b1</code>;    it's a function <code>\u03b1 \u2192 NNReal</code> (non-negative reals) where the sum over all <code>a : \u03b1</code> is 1.</p> </li> <li> <p><code>PMF.pure (a : \u03b1)</code> is a pmf with all mass at <code>a</code> (prob 1 for <code>a</code>, 0 otherwise).</p> </li> <li> <p><code>PMF.bind (p : PMF \u03b1) (f : \u03b1 \u2192 PMF \u03b2)</code> is used for creating dependent r.v.s;    given a r.v. <code>p</code> and function <code>f</code> mapping outcomes of <code>p</code> to new r.v.s, <code>bind</code> gives the resulting distribution on <code>\u03b2</code>.</p> </li> <li> <p><code>PMF.map (f : \u03b1 \u2192 \u03b2) (p : PMF \u03b1)</code>: If we apply a function <code>f</code> to the outcomes    of a r.v. <code>p</code>, <code>map</code> gives the pmf of the results.</p> </li> </ul>"},{"location":"crypto/otp/basic-probability-in-lean/#conditional-probability-in-mathlib","title":"Conditional Probability in Mathlib","text":"<p>\ud83d\udcc1 <code>Mathlib/Probability/ConditionalProbability.lean</code></p> <p><code>Probability.ConditionalProbability</code></p> <ul> <li> <p><code>cond</code> is the conditional probability measure of measure <code>\u03bc</code> on set <code>s</code></p> </li> <li> <p>it is <code>\u03bc</code> restricted to <code>s</code> and scaled by the inverse of <code>\u03bc s</code> (to make it a    probability measure): <code>(\u03bc s)\u207b\u00b9 \u2022 \u03bc.restrict s</code></p> </li> <li> <p><code>cond (p : PMF \u03b1) (E : Set \u03b1)</code> gives the conditional pmf given an event <code>E</code> &lt;&lt;== check this!!</p> </li> </ul> <p>we'll use it to define \\(P(M=m \\; | \\; C=c)\\)</p> <p>Other notable files</p> <ul> <li><code>Probability/ConditionalExpectation.lean</code> conditional expectation</li> <li><code>Probability/CondVar.lean</code> conditional variance</li> <li><code>Probability/Independence/Conditional.lean</code> conditional independence</li> </ul>"},{"location":"crypto/otp/bind_and_pure/","title":"Joint Distributions with <code>bind</code> and <code>pure</code>","text":""},{"location":"crypto/otp/bind_and_pure/#constructing-deterministic-distributions-with-pure","title":"Constructing deterministic distributions with <code>pure</code>","text":"<p><code>pure a</code> creates a probability distribution that always returns <code>a</code> with probability 1.</p> <pre><code>pure : \u03b1 \u2192 PMF \u03b1\npure a = the distribution where P(X = a) = 1 and P(X = b) = 0 for all b \u2260 a\n</code></pre> <p>Interpretation</p> <p>If a random variable, <code>X : \u03a9 \u2192 \u03b1</code>, has PMF <code>pure a</code>, then it's not random at all!</p> <p>It's a constant function: <code>X(\u03c9) = a</code> for all <code>\u03c9 \u2208 \u03a9</code>.</p>"},{"location":"crypto/otp/bind_and_pure/#example","title":"Example","text":"<pre><code>def always_true : PMF Bool := pure true\n-- This distribution gives: P(true) = 1, P(false) = 0\n</code></pre>"},{"location":"crypto/otp/bind_and_pure/#in-our-code","title":"In our code","text":"<pre><code>pure (encrypt m k)\n</code></pre> <p>creates a distribution that always returns the specific ciphertext <code>encrypt m k</code> with probability 1.</p>"},{"location":"crypto/otp/bind_and_pure/#composing-random-processes-with-bind","title":"Composing random processes with <code>bind</code>","text":"<p><code>bind</code> chains two random processes together:</p> <ol> <li>First, sample from one distribution.</li> <li>Based on that result, sample from another distribution.</li> </ol> <pre><code>bind : PMF \u03b1 \u2192 (\u03b1 \u2192 PMF \u03b2) \u2192 PMF \u03b2\n</code></pre> <p>Interpretation</p> <p>Think of <code>bind p f</code> as a two-step random process:</p> <ol> <li>Sample <code>x</code> from distribution <code>p</code>.</li> <li>Use <code>x</code> to choose a new distribution <code>f x</code>.</li> <li>Sample from <code>f x</code> to get the final result.</li> </ol>"},{"location":"crypto/otp/bind_and_pure/#example_1","title":"Example","text":"<pre><code>-- Roll a die, then flip that many coins and count heads.\ndef roll_then_flip : PMF Nat :=\n  bind die_roll (\u03bb n =&gt; flip_n_coins n)\n</code></pre>"},{"location":"crypto/otp/bind_and_pure/#breaking-down-our-expression","title":"Breaking Down Our Expression","text":"<pre><code>\u03bcC = bind \u03bcMK (\u03bb (m, k) =&gt; pure (encrypt m k))\n</code></pre> <p>This means:</p> <ol> <li>First step: sample a pair <code>(m, k)</code> from the joint distribution <code>\u03bcMK</code></li> <li>Second step: Return <code>encrypt m k</code> with probability 1</li> </ol> <p>Since the second step is deterministic (<code>pure</code>), this simplifies to:</p> <p>Sample <code>(m, k)</code> from <code>\u03bcMK</code> and output <code>encrypt m k</code>.</p>"},{"location":"crypto/otp/bind_and_pure/#why-use-bind-and-pure","title":"Why Use <code>bind</code> and <code>pure</code>?","text":"<p>To build complex probability distributions from simple ones:</p> <pre><code>-- Without bind/pure (conceptually):\n\u03bcC c = \u03a3 {P(M=m, K=k) : (m, k) is such that c = encrypt m k}\n\n-- With bind/pure:\n\u03bcC = bind \u03bcMK (\u03bb (m, k) =&gt; pure (encrypt m k))\n</code></pre> <p>The <code>bind</code>/<code>pure</code> formulation is cleaner and more compositional.</p>"},{"location":"crypto/otp/bind_and_pure/#the-general-pattern","title":"The General Pattern","text":"<pre><code>bind p (\u03bb x =&gt; pure (f x)) = map f p\n</code></pre> <p>When the second step is deterministic (using <code>pure</code>), <code>bind</code> reduces to <code>map</code>.</p> <p>So we could also write: <pre><code>\u03bcC = map (\u03bb (m, k) =&gt; encrypt m k) \u03bcMK\n</code></pre></p>"},{"location":"crypto/otp/bind_and_pure/#in-probability-terms","title":"In Probability Terms","text":"<ul> <li><code>pure a</code> is the Dirac delta distribution \u03b4_a</li> <li> <p><code>bind</code> is the law of total probability:   <pre><code>P(Y = y) = \u03a3_x P(X = x) \u00b7 P(Y = y | X = x)\n</code></pre>   where <code>bind p f</code> represents the distribution of Y when:</p> <ul> <li>X has distribution p</li> <li>Y | X=x has distribution f(x)</li> </ul> </li> </ul>"},{"location":"crypto/otp/cats_and_monads/","title":"A Category Theory Perspective: The Probability Monad \ud83d\udd2e","text":"<p>For those who like category theory, we can frame the concepts of <code>pure</code> and <code>bind</code> for probability mass functions in the language of monads.</p> <p>Indeed, the structure formed by <code>PMF</code>, <code>pure</code>, and <code>bind</code> is a classic example of a monad.</p> <p>In this view, <code>PMF</code> is a type constructor that wraps a type <code>\u03b1</code> in a \"probabilistic context,\" yielding <code>PMF \u03b1</code>.</p> <p>The functions <code>pure</code> and <code>bind</code> are the two fundamental operations that define the monad.</p>"},{"location":"crypto/otp/cats_and_monads/#pure-as-monadic-unit","title":"<code>pure</code> as Monadic <code>unit</code>","text":"<ul> <li> <p><code>pure</code> is the standard monadic <code>unit</code> (aka <code>return</code>)</p> </li> <li> <p>It takes <code>a : \u03b1</code> and lifts it into the monadic context with minimal effect.</p> <p><code>pure</code> : \u03b1 \u2192 <code>PMF</code> \u03b1</p> </li> <li> <p>In the probability monad \"minimal effect\" means \"no uncertainty.\"</p> </li> <li> <p><code>pure a</code> lives in the probabilistic world---it is a Dirac delta distribution \\(\u03b4_a\\), where all the probability mass is concentrated on that single value.</p> </li> <li> <p><code>pure</code> is a lens through which to view any <code>a : \u03b1</code> as a (constant) \"random\" variable.</p> </li> <li> <p><code>pure</code> is a thunk; i.e., a way to view <code>a</code> as the (constant) function <code>\u03bb _ \u2192 a</code>.</p> </li> </ul>"},{"location":"crypto/otp/cats_and_monads/#bind-as-monadic","title":"<code>bind</code> as Monadic <code>&gt;&gt;=</code>","text":"<p>The <code>bind</code> function is the cornerstone of the monad.</p> <p>It is often written <code>&gt;&gt;=</code> and sometimes called <code>flatMap</code> (e.g. in Scala).</p> <p>It defines how to compose operations within the monadic context.</p> <p><code>bind : PMF \u03b1 \u2192 (\u03b1 \u2192 PMF \u03b2) \u2192 PMF \u03b2</code></p> <p>This signature is revealing: <code>bind</code> takes</p> <ul> <li>a probability distribution <code>p : PMF \u03b1</code>,</li> <li>a Kleisli arrow function <code>\u03b1 \u2192 PMF \u03b2</code> that maps each value in <code>\u03b1</code> to a distribution over <code>\u03b2</code>,</li> </ul> <p>and returns a new distribution over <code>\u03b2</code>, which represents the total probability of the combined, sequential process.</p> <p>In our context, a Kleisli arrow is a family of probability distributions over <code>\u03b2</code>, indexed by <code>\u03b1</code>.</p> <p>Monads and effects</p> <p>The composition that manifests in <code>bind</code>--combining a value with a Kleisli arrow to produce a distribution--is precisely how monads are able to handle side effects in computational contexts--in this case, the context is probability and the side effects are correlations or dependencies among random processes, that is, the effects that values of random variables, or \"events,\" can have on the probabilities of other events.</p>"},{"location":"crypto/otp/cats_and_monads/#the-monad-laws-for-probability","title":"The Monad Laws for Probability","text":"<p>For (<code>PMF</code>, <code>bind</code>, <code>pure</code>) to comprise a monad, it must satisfy three laws, which guarantee that sequencing probabilistic computations behaves sensibly.</p> <ol> <li> <p>Left Identity: <code>bind (pure a) f \u2261 f a</code></p> <ul> <li>In probability terms: given the \"point mass at <code>a</code>\" distribution over <code>\u03b1</code>,    applying the family <code>f</code> simply gives the distribution <code>f a</code>.</li> </ul> </li> <li> <p>Right Identity: <code>bind p pure \u2261 p</code></p> <ul> <li>In probability terms: If you have a random variable with distribution <code>p</code> and your second step is to simply take its outcome and deterministically wrap it back into a <code>PMF</code>, you haven't actually changed the distribution. The final distribution is identical to the original <code>p</code>.</li> </ul> </li> <li> <p>Associativity: <code>bind (bind p f) g \u2261 bind p (\u03bbx =&gt; bind (f x) g)</code></p> <ul> <li>In probability terms: Thhe way in which you group the composition of a given sequence of probabilistic events doesn't matter. You can either run the first two events (<code>bind p f</code>) and then pipe the result into the third (<code>g</code>), or you can compose the second and third events (<code>\u03bbx =&gt; bind (f x) g)</code>) and pipe the result of the first event (<code>p</code>) into that composite function. Both methods yield the same final probability distribution. This is analogous to the law of total probability applied iteratively.</li> </ul> </li> <li> <p>By satisfying these laws, the triple (<code>PMF</code>, <code>bind</code>, <code>pure</code>)  provides a robust compositional framework for building complex probabilistic models from simpler ones.</p> </li> <li> <p>The expression <code>bind \u03bcMK (\u03bb (m, k) =&gt; pure (encrypt m k))</code> is a clear demonstration of this principle, sequencing a random draw from <code>\u03bcMK</code> with a deterministic computation.</p> </li> </ol>"},{"location":"crypto/otp/cats_and_monads/#the-category-of-types","title":"The Category of Types","text":"<p>The single category we are working in is the category of types and functions (often called Type in programming languages like Lean, or Set in set theory).</p> <ul> <li>Objects: The objects are the types themselves (e.g., <code>Bool</code>, <code>Nat</code>, <code>String</code>).</li> <li>Morphisms: The morphisms are the functions between types (e.g., <code>is_even: Nat \u2192 Bool</code>).</li> </ul>"},{"location":"crypto/otp/cats_and_monads/#how-pmf-acts-on-the-category-of-types","title":"How <code>PMF</code> acts on the category of types","text":"<ol> <li> <p>Mapping Objects.</p> <p>The <code>PMF</code> functor takes an object (a type \u03b1) and maps it to a new object in the same category, the type <code>PMF</code> \u03b1. For example,</p> <ul> <li>the object <code>Bool</code> is mapped to the object <code>PMF Bool</code>.</li> <li>the object <code>Nat</code> is mapped to the object <code>PMF Nat</code>.</li> </ul> <p>Crucially, <code>PMF Bool</code> is still just a type---an object in the category Type.</p> </li> <li> <p>Mapping Morphisms.</p> <p>The <code>PMF</code> functor takes a morphism, <code>f: \u03b1 \u2192 \u03b2</code>, and maps it to a new morphism in the same category (the function <code>map f: PMF \u03b1 \u2192 PMF \u03b2</code>).</p> <ul> <li>It maps the function <code>not: Bool \u2192 Bool</code> to the new function <code>map not: PMF Bool \u2192 PMF Bool</code>.</li> <li>It maps the function <code>is_even: Nat \u2192 Bool</code> to the new function <code>map is_even: PMF Nat \u2192 PMF Bool</code>.</li> </ul> </li> </ol> <p>Because <code>PMF</code> takes any object or morphism in Type and produces another object or morphism right back in Type, it is an endofunctor on Type.</p>"},{"location":"crypto/otp/cats_and_monads/#pmf-is-a-functor","title":"PMF is a functor","text":"<p>Recall, a functor, <code>F : \ud835\udc9e \u2192 \ud835\udc9f</code>, is a map from one category to another that satisfies the functor laws.</p> <pre><code>  \ud835\udc9e       \ud835\udc9f\n\n  \u03b1 ----&gt; F\u03b1\n  |       |              fmap : (\u03b1 \u2192 \u03b2) \u2192 (F\u03b1 \u2192 F\u03b2)\n  |       |\nf |       | fmap f       Functor Laws\n  |       |               i. fmap id = id\n  v       v              ii. fmap (g \u2218 f) = (fmap g) \u2218 (fmap f)\n  \u03b2 ----&gt; F\u03b2\n</code></pre> <p>What are the categories involved here?</p> <p>Clearly the domain category of <code>PMF</code> is the category of types.</p> <p>Also, PMF is a type constructor in the sense that, for each type <code>\u03b1</code>, the value <code>PMF \u03b1</code> is a type.</p> <p>Thus the codomain category of PMF is also <code>Type</code>.</p>"},{"location":"crypto/otp/cats_and_monads/#from-monad-to-functor","title":"From Monad to Functor","text":"<p>For any monad, the monadic structure automatically gives rise to a functor.</p> <p>The functor's <code>fmap</code> operation can be defined using <code>bind</code> and <code>pure</code>.</p> <p>A type constructor is a functor if it supports an <code>fmap</code> function that lifts a regular function into the context of the type.</p> <p>For <code>PMF</code>, this means we need a function with the following signature:</p> <p><code>fmap : (\u03b1 \u2192 \u03b2) \u2192 (PMF \u03b1 \u2192 PMF \u03b2)</code></p> <p>But this can be defined directly from the monadic operations, bind and pure!</p> <p><code>fmap f p = bind p (\u03bb x \u21d2 pure (f x))</code></p> <p>This composition has a clear probabilistic meaning:</p> <ol> <li><code>bind p ...</code>: Sample a value <code>x</code> from the distribution <code>p</code>.</li> <li><code>... (\u03bb x =&gt; ...)</code>: Take that sampled value <code>x</code>.</li> <li><code>pure (f x)</code>: Apply the function <code>f</code> to <code>x</code> and create a new, deterministic distribution that always returns the result <code>f x</code>.</li> </ol> <p>The overall effect is a new probability distribution over the type <code>\u03b2</code>, which is precisely what mapping a function over <code>p</code> should produce.</p>"},{"location":"crypto/otp/cats_and_monads/#the-functor-laws","title":"The Functor Laws","text":"<p>This definition of <code>map</code> also satisfies the two functor laws, which follow directly from the monad laws:</p> <ol> <li> <p>Identity: <code>map id = id</code></p> <ul> <li>Mapping the identity function over a distribution doesn't change it.</li> </ul> </li> <li> <p>Composition: <code>map (g \u2218 f) = (map g) \u2218 (map f)</code></p> <ul> <li>Mapping the composition of two functions is the same as mapping the first function and then mapping the second.</li> </ul> </li> </ol> <p>So, while <code>bind</code> is about sequencing probabilistic computations, <code>map</code> is about applying a deterministic transformation to the outcome of a probabilistic computation. The fact that every monad (like <code>PMF</code>) is also a functor is a fundamental concept in category theory that provides this useful <code>map</code> operation for \"free\".</p>"},{"location":"crypto/otp/cats_and_monads/#summary","title":"Summary","text":"<p>In <code>\u03bcC = bind \u03bcMK (\u03bb (m, k) =&gt; pure (encrypt m k))</code>:</p> <ul> <li><code>\u03bcMK</code> is the joint distribution of (message, key) pairs.</li> <li><code>bind</code> says \"sample from this distribution.\"</li> <li><code>\u03bb (m, k) =&gt; pure (encrypt m k)</code> says \"then apply encryption deterministically.\"</li> <li>Result: <code>\u03bcC</code> is the ciphertexts distribution.</li> </ul>"},{"location":"crypto/otp/law-of-total-prob/","title":"The Law of Total Probability in Lean","text":""},{"location":"crypto/otp/law-of-total-prob/#deconstructing-a-compositional-proof-with-bind-and-pure","title":"Deconstructing a Compositional Proof with <code>bind</code> and <code>pure</code>","text":"<p>We now move beyond proofs that are solved by a single <code>simp</code> command and into a more structured proof that requires several foundational tactics.</p> <p>We will prove a fundamental property about the ciphertext distribution <code>\u03bcC</code>, which we define using <code>bind</code> and <code>pure</code>.</p> <p>This give us the perfect opportunity to explore tactics like <code>rw</code>, <code>intro</code>, and <code>apply</code>, and examine their corresponding proof term constructions.</p>"},{"location":"crypto/otp/law-of-total-prob/#construction-of-c","title":"Construction of <code>\u03bcC</code>","text":"<p>The ciphertext distribution <code>\u03bcC</code> can be constructed by chaining two probabilistic processes:</p> <ol> <li> <p>Sample a message-key pair <code>(m , k)</code> from their joint distribution <code>\u03bcMK</code>.</p> </li> <li> <p>Deterministically compute the ciphertext <code>c = encrypt m k</code>.</p> </li> </ol> <p>We capture this nicely in Lean as follows:</p> <pre><code>\u03bcC = bind \u03bcMK (\u03bb mk =&gt; pure (encrypt mk.1 mk.2))\n</code></pre> <p>To help us understand the meaning of this definition, let's use it to prove a theorem that computes the probability of a specific ciphertext <code>c</code>.</p>"},{"location":"crypto/otp/law-of-total-prob/#the-law-of-total-probability","title":"The Law of Total Probability","text":"<p><code>P(C=c)</code> is the sum of probabilities of all <code>(m, k)</code> pairs that produce <code>c</code>.</p> <p>Theorem</p> <pre><code>\u03bcC c = \u2211' (\u27e8m , k\u27e9 : Plaintext n \u00d7 Key n), if encrypt m k = c then \u03bcMK \u27e8m , k\u27e9 else 0\n</code></pre> <p>Proving this will require unpacking the meaning of <code>bind</code> and <code>pure</code>.</p>"},{"location":"crypto/otp/law-of-total-prob/#setup-for-the-proof","title":"Setup for the Proof","text":"<p>First we add the necessary definitions to our Lean file.</p> <p>We need <code>Plaintext</code>s, an encryption function, and the distributions <code>\u03bcMK</code> and <code>\u03bcC</code>.</p> <p>For simplicity, we use a simple xor for encryption and assume a uniform distribution for messages.</p> <pre><code>-- Assume a uniform distribution on messages for this example.\nnoncomputable def \u03bcM {n : \u2115} : PMF (Plaintext n) :=\n  PMF.uniformOfFintype (Plaintext n)\n\n-- Manual construction of the product distribution P(m, k) = P(m) * P(k).\n-- (assumes independence of message and key)\nnoncomputable def \u03bcMK {n : \u2115} : PMF (Plaintext n \u00d7 Key n) :=\n  PMF.bind \u03bcM (\u03bb m =&gt; PMF.map (\u03bb k =&gt; (m, k)) \u03bcK)\n\n-- The ciphertext distribution, built with bind and pure.\nnoncomputable def \u03bcC {n : \u2115} : PMF (Ciphertext n) :=\n  PMF.bind \u03bcMK (\u03bb \u27e8m, k\u27e9 =&gt; PMF.pure (encrypt m k))\n</code></pre> <p>The law of total probability says that <code>P(C=c)</code> is the sum of probabilities of all <code>(m, k)</code> pairs that produce <code>c</code>.</p> <p>Theorem</p> <pre><code>\u03bcC c = \u2211' (mk : Plaintext n \u00d7 Key n), if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0\n</code></pre>"},{"location":"crypto/otp/law-of-total-prob/#the-proof-step-by-step","title":"The Proof Step-by-Step","text":"<p>Here is the complete, corrected proof in Lean: <pre><code>open Classical\ntheorem \u03bcC_apply_eq_sum {n : \u2115} (c : Ciphertext n) :\n\n  \u03bcC c = \u2211' mk : Plaintext n \u00d7 Key n,\n           if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0\n\n  := by\n  rw [\u03bcC, PMF.bind_apply]\n  simp only [PMF.pure_apply, mul_boole]\n  congr 1\n  ext mk\n  simp only [eq_comm]\n</code></pre></p>"},{"location":"crypto/otp/law-of-total-prob/#step-1-unfold-bind","title":"Step 1: Unfold <code>bind</code>","text":"<p>Tactics. <code>rw [\u03bcC, PMF.bind_apply]</code></p> <ul> <li> <p><code>rw [\u03bcC]</code>: as before, this is a substitution.</p> <p>It replaces <code>\u03bcC</code> with its definition, <code>PMF.bind \u03bcMK ...</code>.</p> <p>The proof term equivalent is <code>Eq.subst</code>.</p> </li> <li> <p><code>rw [PMF.bind_apply]</code>: this is the core of Step 1.</p> <p><code>PMF.bind_apply</code> is a theorem in Mathlib that states:</p> <pre><code>(PMF.bind p f) y = \u2211' x, p x * (f x) y\n</code></pre> <p>This is a formal expression of the law of total probability.</p> <p><code>rw</code> finds this lemma and mechanically rewrites the lhs of our goal to match it.</p> </li> </ul>"},{"location":"crypto/otp/law-of-total-prob/#step-1-unfold-pure","title":"Step 1: Unfold <code>pure</code>","text":"<p>\ud83e\udd45 Goal State \ud83e\udd45</p> <pre><code>n : \u2115\nc : Ciphertext n\n\u22a2 \u2211' (a : Plaintext n \u00d7 Key n),\n    \u03bcMK a * (match a with | (m, k) =&gt; PMF.pure (encrypt m k)) c\n= \u2211' (mk : Plaintext n \u00d7 Key n), if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0\n</code></pre> <p>Tactics. <code>simp only [PMF.pure_apply, mul_boole]</code></p> <ul> <li><code>PMF.pure_apply</code> says <code>(pure a) b</code> is 1 if <code>a = b</code> and 0 otherwise.</li> </ul> <p><code>simp</code> is smart enough to apply this inside the summation.</p> <ul> <li><code>mul_boole</code> simplifies multiplication with the indicator function.</li> </ul> <p>It turns the <code>if</code> into a multiplication by <code>1</code> or <code>0</code>.</p> <p>\ud83e\udd45 Goal State After the Tactics \ud83e\udd45</p> <pre><code>\u22a2 (\u2211' mk, if c = encrypt mk.1 mk.2 then \u03bcMK mk else 0)\n= (\u2211' mk, if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0)\n</code></pre> <p>Now the only difference between the two sides is the order of the equality:</p> <p><code>c = ...</code> versus <code>... = c</code>.</p>"},{"location":"crypto/otp/law-of-total-prob/#step-2-aligning-the-summations","title":"Step 2: Aligning the Summations","text":"<p>We need to show the bodies of the two summations are equal.</p> <p>Tactics. <code>congr 1; ext mk</code></p> <ul> <li> <p><code>congr 1</code>. This \"congruence\" tactic focuses the proof on the first arguments of the   equality\u2014in this case, the functions inside the summations <code>\u2211'</code>.</p> </li> <li> <p><code>ext mk</code>. This \"extensionality\" tactic then states we can prove the two functions   are equal by proving they are equal for an arbitrary input, which it names <code>mk</code>.</p> </li> </ul> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>mk: Plaintext n \u00d7 Key n\n\u22a2   (if c = encrypt mk.1 mk.2 then \u03bcMK mk else 0)\n  = (if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0)\n</code></pre>"},{"location":"crypto/otp/law-of-total-prob/#step-3-finishing-with-eq_comm","title":"Step 3: Finishing with <code>eq_comm</code>","text":"<p>Now we just resolve the switched equality.</p> <p>Tactic. <code>simp only [eq_comm]</code></p> <ul> <li>The lemma <code>eq_comm</code> states that <code>a = b</code> is equivalent to <code>b = a</code>. <code>simp</code> uses this   to rewrite the goal, making the two sides identical and closing the proof.</li> </ul>"},{"location":"crypto/otp/lean-project-setup/","title":"Lean Project Setup \ud83c\udfd7\ufe0f\ufe0f","text":"<p>This section describes the steps we took to set up our Lean project.  The resulting source code is maintained in our lean4crypto respository at</p> <p>https://github.com/formalverification/lean4crypto</p> <ol> <li> <p>Create the Project.</p> <p>In a terminal, <pre><code>lake new OTP math\ncd OTP\n</code></pre></p> </li> <li> <p>Verfiy Mathlib Dependency.</p> <p>The <code>lakefile.toml</code> should look something like this:</p> <pre><code>name = \"OTP\"\nversion = \"0.1.0\"\nkeywords = [\"math\"]\ndefaultTargets = [\"OTP\"]\n\n[leanOptions]\npp.unicode.fun = true # pretty-prints `fun a \u21a6 b`\nautoImplicit = false\n\n[[require]]\nname = \"mathlib\"\nscope = \"leanprover-community\"\n\n[[lean_lib]]\nname = \"OTP\"\n</code></pre> </li> <li> <p>Fetch Mathlib.</p> <p>In your terminal (in the <code>OTP</code> directory), enter the following: <pre><code>lake update\n</code></pre> This might take a few minutes the first time. Then run <code>lake build</code> to ensure it's working. <pre><code>lake build\n</code></pre></p> </li> <li> <p>Create Main File.</p> <ul> <li>The <code>lake new</code> command creates <code>OTP.lean</code> and <code>OTP/Basic.lean</code>.</li> <li>We'll start the formalization in <code>OTP/Basic.lean</code> (which is imported into <code>OTP.lean</code>).</li> </ul> </li> </ol>"},{"location":"crypto/otp/otp-basic-types/","title":"Basic Types for the OTP","text":""},{"location":"crypto/otp/otp-basic-types/#initial-considerations","title":"Initial Considerations \ud83e\udd14","text":"<ul> <li> <p>What types for messages, keys, ciphertexts?</p> <p><code>Vector Bool n</code> is a good candidate (or <code>Fin n \u2192 Bool</code>).</p> </li> <li> <p>How to represent the XOR operation on these types?</p> </li> <li> <p>Which Mathlib probability definitions will you need? (e.g., <code>PMF</code>, <code>Pure</code>, <code>Bind</code> for random variables, <code>cond</code> for conditional probability).</p> </li> </ul>"},{"location":"crypto/otp/otp-basic-types/#initial-definitions","title":"Initial Definitions \u270d\ufe0f","text":""},{"location":"crypto/otp/otp-basic-types/#types-aliases","title":"Types Aliases","text":"<pre><code>def Plaintext (n : Nat) := Vector Bool n\ndef Key (n : Nat) := Vector Bool n\ndef Ciphertext (n : Nat) := Vector Bool n\n</code></pre> <p>Using <code>n : Nat</code> so definitions are generic for any length.</p>"},{"location":"crypto/otp/otp-basic-types/#the-xor-operation","title":"The XOR Operation \u2295","text":"<p>To encrypt plain text messages, and decrypt ciphertext messages, we will use the \"exclusive or\" function, <code>xor</code>, applied pointwise to the message and key vectors.</p> <pre><code>xor_vector {n : Nat} (v\u2081 v\u2082 : Vector Bool n) : Vector Bool n\n</code></pre> <p>As we'll see below, this operation can be defined in a number of ways---for example, as <code>Vector.zipWith Bool.xor v\u2081 v\u2082</code> or <code>Vector.ofFn (\u03bb i =&gt; Bool.xor (v\u2081.get i) (v\u2082.get i))</code>, which are merely different ways of applying Boolean xor pointwise on the input vectors.</p> <p>The <code>encrypt</code> and <code>decrypt</code> functions are essentially aliases for the <code>xor_vector</code> function:</p> <pre><code>def encrypt {n : Nat} (p : Plaintext n) (k : Key n) : Ciphertext n :=\n  xor_vector p k\n\ndef decrypt {n : Nat} (c : Ciphertext n) (k : Key n) : Ciphertext n :=\n  xor_vector c k\n</code></pre> <p>Notice, however, that unlike <code>xor_vec</code> which takes a pair of generic binary vectors and returns a binary vector, <code>encrypt</code> takes a <code>Plaintext</code> message and a <code>Key</code> and returns <code>Ciphertext</code> message, while <code>decrypt</code> takes a <code>Ciphertext</code> message and a <code>Key</code> and returns <code>Plaintext</code> message.</p> <p>Lean will complain if we try to apply <code>encrypt</code> to a <code>Ciphertext</code> message and a <code>Key</code> or to two generic binary vectors.</p>"},{"location":"crypto/otp/otp-basic-types/#initial-definitions-in-lean","title":"Initial Definitions in Lean","text":"<p>Let's now encode these basic definitions in Lean.</p> <p>In Section Lean Project Setup, we created and built a Lean project called <code>OTP</code>.  This process creates a file called <code>OTP/Basic.lean</code> containing one line:</p> <pre><code>def hello := \"world\"\n</code></pre> <p>In your terminal, navigate to the <code>OTP</code> project directory and enter <code>code .</code>, which will launch VSCode with the <code>OTP</code> project open.</p> <p>In the project Explorer window on the left, click on the <code>OTP</code> directory and double click on the <code>Basic.lean</code> file to open it.</p> <p>Replace its contents (<code>def hello := \"world\"</code>) with the following:</p> <pre><code>import Mathlib.Data.Vector.Basic\n\nnamespace OTP\n  open List.Vector\n  -- Define types using List.Vector\n  def Plaintext  (n : Nat) := List.Vector Bool n\n  def Key        (n : Nat) := List.Vector Bool n\n  def Ciphertext (n : Nat) := List.Vector Bool n\n\n  -- Element-wise XOR for List.Vector\n  def vec_xor {n : Nat} (v\u2081 v\u2082 : List.Vector Bool n) := map\u2082 xor v\u2081 v\u2082\n\n  def encrypt {n : Nat} (m : Plaintext n) (k : Key n) : Ciphertext n :=\n    vec_xor m k\n\n  def decrypt {n : Nat} (c : Ciphertext n) (k : Key n) : Plaintext n :=\n    vec_xor c k\n\n\n-- Demo 1: Basic OTP Operations ----------------------------------\n-- Examples using List literals for the List.Vector constructor\nsection Demo1\n  -- Create a 4-bit message\n  def msg : Plaintext 4 := \u27e8[true, false, true, true], rfl\u27e9\n  -- `rfl` is the unique constructor for the equality type\n\n\n  -- Create a 4-bit key\n  def key : Key 4 := \u27e8[false, true, false, true], by rfl\u27e9\n  -- `by rfl` uses the rfl tactic, which is more generic than the `rfl` above.\n  -- It works for any relation that has a reflexivity lemma tagged with\n  -- the attribute `@[refl]`.\n\n  -- Show encryption\n  #eval encrypt msg key\n  -- Output: [true, true, true, false]\n\n  -- Show decryption recovers the message\n  #eval decrypt (encrypt msg key) key\n  -- Output: [true, false, true, true]\n\n  -- Show that different keys give different ciphertexts\n  def key2 : Key 4 := \u27e8[true, true, false, false], by decide\u27e9\n  -- `by decide` is yet another way to fill in the required proof\n\n  #eval encrypt msg key2\n  -- Output: [false, true, true, true]\n\nend OTP\n</code></pre> <p>Exercise</p> <p>Can the <code>encrypt</code> function take a <code>Ciphertext</code> and a <code>Key</code> (or a <code>Plaintext</code> message and a <code>Ciphertext</code> message, or even two keys) as arguments?  (Use <code>#eval</code> to check.)</p> <p>Would you say that <code>encrypt</code> is a function from <code>Plaintext n</code> \u00d7 <code>Key n</code> to <code>Ciphertext n</code>?  Or is it a binary operation on <code>Vector Bool n</code>?</p>"},{"location":"crypto/otp/otp-basic-types/#mathlib-specifics","title":"Mathlib Specifics","text":"<p>Tip</p> <p>Use the Mathlib documentation website for easy browsing of module contents and definitions.</p> <p>https://leanprover-community.github.io/mathlib4_docs/index.html</p>"},{"location":"crypto/otp/otp-basic-types/#datavector","title":"<code>Data/Vector/</code>","text":"<p>\ud83d\udcc1 <code>Mathlib/Data/Vector/Basic.lean</code>.</p> <ul> <li><code>Vector \u03b1 n</code> represents a list of elements of type <code>\u03b1</code> that is known to have length <code>n</code>.    Well suited to plaintexts, keys, and ciphertexts where length is fixed and equal.</li> </ul> <p>\ud83e\uddf0 Useful functions</p> <ul> <li><code>Vector.map (f : \u03b1 \u2192 \u03b2) : Vector \u03b1 n \u2192 Vector \u03b2 n</code></li> <li><code>Vector.map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 Vector \u03b3 n</code>,    perfect for XORing two vectors.</li> <li><code>Vector.get : Vector \u03b1 n \u2192 Fin n \u2192 \u03b1</code> to get an element at an index.</li> <li><code>Vector.ofFn : ((i : Fin n) \u2192 \u03b1) \u2192 Vector \u03b1 n</code> to construct a vector from a function.</li> <li>Literals like <code>![a, b, c]</code> can often be coerced to <code>Vector \u03b1 3</code> if the type is known.</li> </ul>"},{"location":"crypto/otp/otp-basic-types/#datalist","title":"<code>Data/List/</code>","text":"<ul> <li> <p>In <code>Mathlib/Data/List/Basic.lean</code> and other files in <code>Mathlib/Data/List/</code>.</p> </li> <li> <p>While <code>Vector</code> is likely better for fixed-length crypto primitives, <code>List \u03b1</code> is    the standard list type.</p> </li> <li> <p>Good to know its API (e.g., <code>map</code>, <code>zipWith</code>, <code>length</code>) as <code>Vector</code> often mirrors    or builds upon <code>List</code> concepts.</p> </li> </ul>"},{"location":"crypto/otp/otp-basics/","title":"OTP basics","text":""},{"location":"crypto/otp/otp-basics/#what-is-the-one-time-pad-otp","title":"What is the One-Time Pad (OTP)?","text":"<p>A theoretically unbreakable (\"perfect secrecy\") encryption technique with very specific requirements.</p> <p>The Key \ud83d\udddd\ufe0f must be</p> <ul> <li>truly random</li> <li>at least as long as the plaintext message</li> <li>used only once</li> <li>kept secret between sender and receiver</li> </ul>"},{"location":"crypto/otp/otp-basics/#encryption","title":"Encryption","text":"<p>\u270d\ufe0f Plaintext message: typically converted into a sequence of bits (or numbers)</p> <p>\ud83d\udddd\ufe0f Key: also a sequence of bits (or numbers) of the same length</p> <p>\u3299\ufe0f Encryption: performed by combining plaintext with key using a simple operation, commonly bitwise XOR.</p> <ul> <li> <p><code>Ciphertext = Plaintext xor Key</code> (for bits)</p> <p>\u3299\ufe0f = \u270d\ufe0f \u2295 \ud83d\udddd\ufe0f</p> </li> </ul> using numbers instead of bits <p>If using numbers, e.g., letters A=0, B=1, ... Z=25, then modular addition is used instead:</p> <p><code>Ciphertext = (Plaintext + Key) mod N</code></p>"},{"location":"crypto/otp/otp-basics/#decryption","title":"Decryption","text":"<p>uses the same key and the reverse operation</p> <ul> <li><code>Plaintext = Ciphertext XOR Key</code> (because <code>(P XOR K) XOR K = P</code>)</li> <li><code>Plaintext = (Ciphertext - Key) mod N</code></li> </ul>"},{"location":"crypto/otp/otp-basics/#perfect-secrecy","title":"Perfect Secrecy","text":"<p>The core theoretical property of OTP is</p> <p>The ciphertext provides no information (other than max length) about the plaintext content.</p> <ul> <li> <p>Formally, \\(P(\\text{plaintext} = m \\; | \\; \\text{ciphertext} = c) = P(\\text{plaintext} = m)\\).</p> </li> <li> <p>Knowing \\(c\\) doesn't change the probability distribution of the plaintext \\(m\\).</p> </li> <li> <p>This holds only if all the conditions for the key are met (random, same length, used once).</p> </li> </ul>"},{"location":"crypto/otp/otp-basics/#why-otp-is-interesting-to-cryptographers","title":"Why OTP is interesting to cryptographers","text":"<ul> <li> <p>Highlights critical importance of key management (randomness, length,    single-use, secrecy).</p> </li> <li> <p>Most practical ciphers try to achieve similar security with    shorter, reusable keys. (much harder)</p> </li> <li> <p>Understanding limitations of OTP motivates study of other cryptographic systems.</p> </li> </ul>"},{"location":"crypto/otp/otp-basics/#feasibility-of-formalizing-otp-in-lean","title":"Feasibility of Formalizing OTP in Lean","text":"<p>Formalizing the One-Time Pad in Lean is highly feasible and useful as a PoC, providing a concrete example of verifying a security property.</p> <ul> <li> <p>Simple Operations. The core operations (XOR, modular addition) are already    well-defined or easy to define in Lean. Mathlib has <code>Bool.xor</code> and <code>ZMod N</code> for modular arithmetic.</p> </li> <li> <p>Clear Definitions: We can define types for plaintexts, keys, and ciphertexts    (e.g., <code>List Bool</code>, <code>Vector Bool n</code>, or functions <code>Fin n \u2192 Bool</code>).</p> </li> <li> <p>Focus on a Key Property. The main goal would be to formalize and prove its    perfect secrecy, a non-trivial but achievable result that would be very compelling.</p> </li> <li> <p>Mathlib Support. Mathlib has a growing library for probability theory on    finite types (<code>Mathlib.Probability.ProbabilityMassFunction</code>), which is essential    for proving perfect secrecy. We don't need to build from scratch!</p> </li> </ul>"},{"location":"crypto/otp/otp-basics/#what-to-formalize","title":"What to Formalize","text":"<ol> <li> <p>Define message space, key space, ciphertext space.     For simplicity, use <code>Vector Bool n</code> (vectors of Booleans of fixed length <code>n</code>).</p> </li> <li> <p>Define encrypt and decrypt functions.     (e.g., element-wise XOR for <code>Vector Bool n</code>).</p> </li> <li> <p>State assumptions about key.</p> <ul> <li> <p>chosen uniformly at random from the key space</p> </li> <li> <p>independent of plaintext</p> </li> </ul> </li> <li> <p>Formalize definition of perfect secrecy.</p> \\[P(M=m \\; | \\; C=c) = P(M=m)\\] <p>Involves defining probability mass functions for message and key, and conditional probability.</p> </li> <li> <p>Prove our OTP implementation satisfies perfect secrecy under the stated assumptions.</p> </li> </ol>"},{"location":"crypto/otp/perfect-secrecy-in-lean/","title":"OTP: Perfect Secrecy in Lean","text":"<p>The standard way to prove the perfect secrecy of OTP is to show that for any fixed plaintext <code>m</code>, the conditional distribution of ciphertexts is uniform.</p>"},{"location":"crypto/otp/perfect-secrecy-in-lean/#proof-setup","title":"Proof Setup","text":"<p>We define the conditional distribution <code>\u03bcC_M m</code> by mapping the encryption function over the uniform key distribution.</p> <pre><code>-- The distribution of ciphertexts, conditioned on a fixed message `m`.\nnoncomputable def \u03bcC_M {n : \u2115} (m : Plaintext n) : PMF (Ciphertext n) :=\n  PMF.map (encrypt m) \u03bcK\n</code></pre> <p>Our goal is to prove that this distribution is uniform.</p> <p>Theorem: <code>\u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)</code></p>"},{"location":"crypto/otp/perfect-secrecy-in-lean/#a-detour-into-equivalences","title":"A Detour into Equivalences (<code>\u2243</code>)","text":"<p>Key mathematical insight: for a fixed <code>m</code>, the function <code>encrypt m</code> is a bijection.</p> <p>In Lean, such a bijection is captured by the type <code>Equiv</code>, written <code>\u03b1 \u2243 \u03b2</code>.</p>"},{"location":"crypto/otp/perfect-secrecy-in-lean/#what-is-an-equiv","title":"What is an <code>Equiv</code>?","text":"<p>An <code>Equiv</code> is a structure that bundles a function, its inverse, and proofs that they are indeed inverses of each other. It represents an isomorphism between types.</p> <p>The formal definition in Mathlib is: <pre><code>structure Equiv (\u03b1 : Sort*) (\u03b2 : Sort*) where\n  toFun    : \u03b1 \u2192 \u03b2        -- The forward function\n  invFun   : \u03b2 \u2192 \u03b1        -- The inverse function\n  left_inv  : Function.LeftInverse invFun toFun   -- proof of invFun (toFun x) = x\n  right_inv : Function.RightInverse invFun toFun  -- proof of toFun (invFun y) = y\n</code></pre></p>"},{"location":"crypto/otp/perfect-secrecy-in-lean/#how-to-construct-an-equiv-intro","title":"How to Construct an <code>Equiv</code> (Intro)","text":"<p>There are two main ways to build an equivalence.</p> <ol> <li> <p>From an Involutive Function (High-Level)</p> <p>If a function is its own inverse, like <code>not</code> or our <code>encrypt m</code>, you can use the constructor <code>Equiv.ofInvolutive</code>.</p> <pre><code>-- Helper lemma: For a fixed message m, encryption is its own inverse.\nlemma encrypt_involutive {n : \u2115} (m : Plaintext n) :\n  Function.Involutive (encrypt m) := by ...\n\n-- We build the Equiv directly from this property.\ndef encrypt_equiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n :=\n  Equiv.ofInvolutive (encrypt m) (encrypt_involutive m)\n</code></pre> </li> <li> <p>By Hand (Low-Level)</p> <p>You can construct one by providing all four fields. This is useful for simple cases.</p> <pre><code>-- An equivalence between Bool and Bool using `not`.\ndef not_equiv : Bool \u2243 Bool where\n  toFun    := not\n  invFun   := not\n  left_inv  := Bool.not_not\n  right_inv := Bool.not_not\n</code></pre> </li> </ol>"},{"location":"crypto/otp/perfect-secrecy-in-lean/#how-to-use-an-equiv-elim","title":"How to Use an <code>Equiv</code> (Elim)","text":"<p>Once you have an <code>Equiv</code>, you can use it in several ways.</p> <ol> <li> <p>As a Function. Lean knows how to treat an <code>Equiv</code> <code>e</code> as a function. You can just write <code>e x</code>.</p> </li> <li> <p>Accessing the Inverse. The inverse is available as <code>e.symm</code>. So you can write <code>e.symm y</code>.</p> </li> <li> <p>Using the Proofs. The proofs <code>e.left_inv</code> and <code>e.right_inv</code> are powerful tools for rewriting.</p> </li> </ol> <pre><code>example (e : \u03b1 \u2243 \u03b2) (x : \u03b1) : e.symm (e x) = x := by\n  -- The goal is exactly the statement of the left_inv property.\n  simp [e.left_inv]\n</code></pre> <ul> <li> <p>Understanding how to construct and use equivalences is crucial for many proofs    involving bijections.</p> </li> <li> <p>The final step of our OTP theorem would be to find the right Mathlib lemma that    uses this <code>encrypt_equiv</code> to prove that the <code>map</code> of a uniform distribution is    still uniform.</p> </li> </ul>"},{"location":"crypto/otp/perfect-secrecy-in-lean/#next","title":"Next","text":"<ol> <li> <p>A detailed Markdown explanation of our proof for <code>otp_perfect_secrecy_lemma</code>.</p> </li> <li> <p>An explanation for why <code>encrypt_equiv</code> must be <code>noncomputable</code> while <code>xorEquiv</code> is not.</p> </li> </ol> <p>Let's tackle the <code>noncomputable</code> question first, as it's a deep and important concept in Lean.</p>"},{"location":"crypto/otp/perfect-secrecy-in-lean/#computable-vs-noncomputable-definitions","title":"Computable vs. Noncomputable Definitions","text":"<p>The reason one definition is <code>noncomputable</code> and the other is not comes down to how the inverse function is provided.</p> <p>It's a classic case of being constructive versus classical.</p>"},{"location":"crypto/otp/perfect-secrecy-in-lean/#def-xorequiv-constructive","title":"<code>def xorEquiv</code> (Constructive)","text":"<pre><code>def xorEquiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n where\n  toFun     := encrypt m\n  invFun    := vec_xor m -- We explicitly provide the inverse function\n  left_inv  := by ...\n  right_inv := by ...\n</code></pre> <p>Here, we create the <code>Equiv</code> structure by hand. We provide all four components:</p> <ol> <li> <p><code>toFun</code>: The forward function, <code>encrypt m</code>.</p> </li> <li> <p><code>invFun</code>: The inverse function, <code>vec_xor m</code>. We explicitly construct and provid this function.</p> </li> <li> <p><code>left_inv</code>: A proof that <code>vec_xor m (encrypt m k) = k</code>.</p> </li> <li> <p><code>right_inv</code>: A proof that <code>encrypt m (vec_xor m c) = c</code>.</p> </li> </ol> <p>Because every component is explicitly defined and computable, the entire <code>xorEquiv</code> definition is computable.</p>"},{"location":"crypto/otp/perfect-secrecy-in-lean/#noncomputable-def-encrypt_equiv-classical","title":"<code>noncomputable def encrypt_equiv</code> (Classical)","text":"<pre><code>noncomputable def encrypt_equiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n :=\n  Equiv.ofBijective (encrypt m) (encrypt_bijective m)\n</code></pre> <p>Here, we use the high-level constructor <code>Equiv.ofBijective</code>. We provide it with:</p> <ol> <li> <p>A function, <code>encrypt m</code>.</p> </li> <li> <p>A proof, <code>encrypt_bijective m</code>, which proves that the function is both injective and surjective.</p> </li> </ol> <p>But notice what's missing: we never told Lean what the inverse function is!</p> <p>The <code>Equiv.ofBijective</code> constructor has to create the inverse function for us.</p> <p>How does it do that?  It uses the proof of surjectivity.</p> <p>A proof of <code>Surjective (encrypt m)</code> says \"for every ciphertext <code>c</code>, there exists a key <code>k</code> such that <code>encrypt m k = c</code>.\"</p> <p>To define an inverse function, Lean must choose such a <code>k</code> for each <code>c</code>.</p> <p>This act of choosing an object from a proof of its existence requires the axiom of choice (<code>Classical.choice</code>).</p> <p>In Lean's constructive logic, any definition that depends on the axiom of choice is marked as <code>noncomputable</code>.</p> <p>In short:</p> <ul> <li> <p><code>xorEquiv</code> is computable because we did the work of providing the inverse function constructively.</p> </li> <li> <p><code>encrypt_equiv</code> is noncomputable because we asked Lean to conjure the inverse function out of a classical existence proof, forcing it to use the noncomputable axiom of choice.</p> </li> </ul>"},{"location":"crypto/otp/perfect-secrecy-in-lean/#explaining-the-otp_perfect_secrecy_lemma-proof","title":"Explaining the <code>otp_perfect_secrecy_lemma</code> Proof","text":"<p>Theorem to Prove:</p> <pre><code>theorem otp_perfect_secrecy_lemma {n : \u2115} :\n    \u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> <p>The Proof, Explained: <pre><code>theorem otp_perfect_secrecy_lemma {n : \u2115} :\n    \u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n) := by\n  intro m\n  have h\u03bc : \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n) := by\n    apply map_uniformOfFintype_equiv (xorEquiv m)\n  simp [h\u03bc, PMF.uniformOfFintype_apply]\n</code></pre></p> <ul> <li> <p>Tactic <code>intro m</code></p> <ul> <li>What it does: The proof begins by addressing the \"for all <code>m</code>\" part of the theorem.</li> </ul> <p>The <code>intro</code> tactic introduces an arbitrary but fixed message <code>m</code> that we can work with for the rest of the proof.</p> <ul> <li> <p>Goal State:</p> <pre><code>m: Plaintext n\n\u22a2 \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> </li> </ul> </li> <li> <p>Tactic <code>have h\u03bc : ... := by ...</code></p> <ul> <li> <p>What it does: This is the main logical step. The <code>have</code> tactic lets us prove a helper fact, or lemma, which we can then use to prove our main goal. Here, we are proving a fact named <code>h\u03bc</code>. Coincidentally, <code>h\u03bc</code> is the exact statement of our main goal.</p> </li> <li> <p>The Sub-Proof: The proof of <code>h\u03bc</code> is <code>apply map_uniformOfFintype_equiv (xorEquiv m)</code>. This applies the helper lemma you proved earlier, which states that mapping a uniform distribution over an equivalence (<code>xorEquiv m</code>) results in a uniform distribution. This single line brilliantly captures the core mathematical argument.</p> </li> <li> <p>Goal State (after the <code>have</code> block is complete):</p> <pre><code>m: Plaintext n\nh\u03bc: \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n\u22a2 \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> </li> </ul> </li> <li> <p>Tactic <code>simp [h\u03bc, PMF.uniformOfFintype_apply]</code></p> <ul> <li> <p>What it does: This tactic finishes the proof using the fact <code>h\u03bc</code> we just proved. The <code>simp [h\u03bc]</code> part tells Lean to rewrite the goal using <code>h\u03bc</code>.</p> </li> <li> <p>How it Works: <code>simp</code> sees <code>\u03bcC_M m</code> on the left side of the goal <code>\u22a2</code> and sees the hypothesis <code>h\u03bc</code> which states <code>\u03bcC_M m = ...</code>. It substitutes the left side with the right side of <code>h\u03bc</code>.</p> </li> <li> <p>Goal State (after <code>simp [h\u03bc]</code>):</p> <pre><code>\u22a2 PMF.uniformOfFintype (Ciphertext n) = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> </li> <li> <p>This goal is true by reflexivity, and <code>simp</code> is able to solve it completely. (The extra <code>PMF.uniformOfFintype_apply</code> is not strictly necessary here, as <code>h\u03bc</code> is sufficient, but it doesn't hurt). A more direct way to finish after the <code>have</code> block would simply be <code>exact h\u03bc</code>.</p> </li> </ul> </li> </ul>"},{"location":"crypto/otp/perfect-secrecy/","title":"Perfect Secrecy of the One-time Pad","text":""},{"location":"crypto/otp/perfect-secrecy/#construction","title":"Construction","text":"<p>Definition of _\u2295_</p> <p>_\u2295_ is bitwise XOR: \\(\\quad 0 \u2295 0 = 0, \\quad 0 \u2295 1 = 1, \\quad 1 \u2295 0 = 1, \\quad 1 \u2295 1 = 0\\).</p> <p>For n-bit strings \\(\\; a = a\u2081 \u22ef a_n\\), \\(\\; b = b\u2081 \u22ef b_n\\) , let \\(\\; a \u2295 b = a\u2081 \u2295 b\u2081 \u22ef a_n \u2295 b_n\\).</p> Cayley table of _\u2295_ \u2295 0 1 0 0 1 1 1 0 <p>An important property of _\u2295_</p> <p>\\(a \u2295 b = c \u21d4 a = b \u2295 c\\), for all \\(a\\), \\(b\\), \\(c\\).</p> <p>Fix an integer \\(n &gt; 0\\).</p> <p>Let \\(\u2133\\) be the message space , \\(\ud835\udca6\\) the key space, and \\(\ud835\udc9e\\) the ciphertext space.</p> <p>Assume \\(\u2133\\), \\(\ud835\udca6\\), \\(\ud835\udc9e\\) all equal \\(\\{0, 1\\}^n\\).</p> <ul> <li> <p>Gen (key-generation algorithm) choose key from uniform distribution over \\(\ud835\udca6\\).</p> </li> <li> <p>Enc (encryption algorithm) given \\(k \u2208 \ud835\udca6\\), \\(m \u2208 \u2133\\),  output ciphertext \\(c = k \u2295 m\\).</p> </li> <li> <p>Dec (decryption algorithm) given \\(k \u2208 \ud835\udca6\\), \\(c \u2208 \ud835\udc9e\\), output message \\(m = k \u2295 c\\).</p> </li> </ul>"},{"location":"crypto/otp/perfect-secrecy/#perfect-secrecy-theorem","title":"Perfect Secrecy Theorem","text":"<p>Theorem 2.9 (Katz &amp; Lindell, 2ed)</p> <p>The one-time pad encryption scheme is perfectly secret.</p> <p>That is, if \\(m \u2208 \u2133\\), \\(c \u2208 \ud835\udc9e\\) and \\(\u2119(C = c) &gt; 0\\), then</p> \\[\u2119 (M = m \\; | \\; C = c) = \u2119(M = m).\\] Proof of Theorem 2.9 \u270d\ufe0f <ul> <li>Let \\(C\\) and \\(M\\) be r.v.s from arbitrary, fixed distributions over \\(\u2133\\) and \\(\ud835\udc9e\\), resp.</li> <li>Let \\(K\\) be a r.v. from the uniform distribution over \\(\ud835\udca6\\).</li> </ul> <p>\ud83e\udd45 Goal \ud83e\udd45</p> <p>If \\(m \u2208 \u2133\\), \\(c \u2208 \ud835\udc9e\\) and \\(\u2119(C = c) &gt; 0\\), then \\(\u2119 (M = m \\; | \\; C = c) = \u2119(M = m)\\).</p> <p>We first show what amounts to \"\\(C\\) is uniform if \\(K\\) is uniform, regardless of \\(M\\).\"</p> <p>Compute \\(\u2119(C = c \\; | \\; M = m )\\) for arbitrary \\(c \u2208 \ud835\udc9e\\) and \\(m \u2208 \u2133\\): \\[\u2119 (C = c \\; | \\; M = m) = \u2119 (\\mathrm{Enc}_k (m) = c) = \u2119(k \u2295 m = c)= \u2119(k = m \u2295 c)= 2^{-n},\\]</p> <p>since \\(k\\) is chosen from a uniform distribution over the set \\(\ud835\udca6\\) of \\(n\\)-bit strings.</p> <p>For \\(c \u2208 \ud835\udc9e\\),</p> <p>\\[\u2119 (C = c) = \u2211_{m \u2208 \u2133} \u2119 (C = c \\; | \\; M = m) \u00b7 \u2119(M = m) = 2^{-n} \u2211_{m \u2208 \u2133} \u2119(M = m) = 2^{-n}.\\]</p> <p>Therefore, by Bayes' Theorem,</p> \\[\\begin{align*} \u2119(M = m \\; | \\; C = c) &amp;= \\frac{\u2119(C = c \\; | \\; M = m) \u00b7 \u2119(M = m)}{\u2119(C = c)}\\\\                        &amp;= \\frac{2^{-n} \u00b7 \u2119(M = m)}{2^{-n}} = \u2119(M = m). \\end{align*}\\] <p>\u220e</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/","title":"Lean4: a primer for pedantic provers","text":"<p>We seek to not only demonstrate how to prove properties in Lean but also why the methods work, connecting the seemingly magical world of tactics to the solid ground of proof objects, with which we are more familiar from Agda.</p> <p>Our proposed aim to bridge the gap between tactic-based proofs and their underlying proof terms has been called \"an outstanding pedagogical approach.\"[^1]</p> <p>We'll start with a concrete, fundamental example that we touched upon in our previous meetings: computing the probability of choosing a specific key at random.</p> <p>This will allow us to bring the ideas down to earth and immediately dive into and discuss the tactic vs. proof object dichotomy.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#part-1-a-concrete-first-proof","title":"Part 1: A Concrete First Proof","text":"<p>Let's start with the</p> <p>Claim. The probability of randomly choosing a specific 3-bit key is 1/8.</p> <p>In Lean, the theorem and its tactic-based proof are very concise.</p> <pre><code>import Mathlib.Probability.Distributions.Uniform\n\n-- (Assuming a file OTP.Basic with the definition of Key)\nopen OTP\n-- Recall, we define `Key n` as vectors of booleans.\n-- This is equivalent to `Fin n \u2192 Bool` or other n-bit types.\n\n-- Here is the uniform distribution over keys of length n.\nnoncomputable def \u03bcK {n : \u2115} : PMF (Key n) := PMF.uniformOfFintype (Key n)\n\n-- Our claim: the probability of choosing key [true, false, true] is 1/8.\nexample : \u03bcK \u27e8[true, false, true], rfl\u27e9 = (1/8 : ENNReal) :=\n -- and here's the tactic-based proof in Lean:\n  by simp [\u03bcK, PMF.uniformOfFintype_apply]; rfl\n</code></pre> <p>This is great for a user who knows what <code>simp</code> means and does, but it may seem like a magical incantation for the newcomer.</p> <p>So, let's unpack it.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#deconstructing-simp","title":"Deconstructing <code>simp</code>","text":"<p>The <code>simp</code> tactic is an automated rewriter.</p> <p>It tries to simplify the main goal by applying a list of theorems (called a \"simpset\") from left to right, over and over, until no more simplifications can be made.</p> <p>When you write <code>simp [foo, bar]</code>, you are telling Lean:</p> <p>\"Please use your standard simpset, plus the definitions/lemmas <code>foo</code> and <code>bar</code> to the set of tools you can use to simplify or reduce the goal.\"</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-1-unfolding-the-definition-of-k","title":"Step 1: Unfolding the Definition of <code>\u03bcK</code>","text":"<p>Let's break down the proof step-by-step, showing the tactic at each stage, and then discuss the proof object it's building.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 \u03bcK \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>Here, <code>\u22a2</code> indicates the goal we are trying to prove.</p> <p>The Tactic <code>simp [\u03bcK]</code> or <code>rw [\u03bcK]</code></p> <p>tells Lean to substitute <code>\u03bcK</code> with its definition.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>\u22a2 PMF.uniformOfFintype (Key 3) \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun18-notes/#why-this-works","title":"Why this works","text":"<p>Looking under the hood,</p> <ul> <li> <p><code>\u03bcK</code> is defined as <code>PMF.uniformOfFintype (Key n)</code>.</p> </li> <li> <p><code>simp</code> (and the more targeted <code>rw</code>) can access all definitions in context.</p> </li> <li> <p>It sees the term <code>\u03bcK</code> in the goal and replaces it with its definition; a   simple substitution.</p> </li> </ul>"},{"location":"crypto/otp/talk/2025Jun18-notes/#the-equivalent-proof-term","title":"The Equivalent Proof Term","text":"<p>In a term-based proof, the substitution is achieved using functions that show equality is respected by function application.</p> <p>If we have a proof <code>h : \u03bcK = PMF.uniformOfFintype (Key 3)</code>, we can use it to rewrite the goal.</p> <p>The definition itself provides this proof <code>h</code>. The core idea is <code>Eq.subst</code> or <code>Eq.rec</code>.</p> <p>A proof term for just this step would look like this:</p> <pre><code>-- Let P be the property we are trying to prove for the definition.\n-- P := \u03bb x =&gt; x \u27e8[true, false, true], _\u27e9 = 1/8\n-- Our goal is `P (\u03bcK)`\n-- The definition of \u03bcK gives us `proof_of_definition : \u03bcK = PMF.uniformOfFintype (Key 3)`\n\n-- The new proof term is:\nEq.subst proof_of_definition (new_goal : P (PMF.uniformOfFintype (Key 3)))\n</code></pre> <p>...which is a bit clunky.</p> <p>A more common term-based idiom is to simply start with the definition already unfolded.</p> <p>The tactic <code>rw</code> is essentially a mechanical way of applying <code>Eq.subst</code>.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-2-unfolding-definition-of-uniform-pmf","title":"Step 2: Unfolding Definition of Uniform PMF","text":"<p>Now we apply the definition of what <code>uniformOfFintype</code> evaluates to for a given input.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 PMF.uniformOfFintype (Key 3) \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>The Tactic <code>simp [PMF.uniformOfFintype_apply]</code></p> <p>The lemma <code>PMF.uniformOfFintype_apply</code> states:</p> <p>If <code>a</code> is an inhabitant of the finite type <code>\u03b1</code>, then</p> <p><code>PMF.uniformOfFintype \u03b1 a</code> is equal to <code>(Fintype.card \u03b1)\u207b\u00b9</code>.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>\u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun18-notes/#why-this-works_1","title":"Why this works","text":"<p>Looking under the hood,</p> <ul> <li> <p><code>simp</code> finds a lemma <code>PMF.uniformOfFintype_apply</code> in the library;</p> </li> <li> <p>This lemma matches the pattern <code>PMF.uniformOfFintype (Key 3) ...</code> on the lhs of our goal;</p> </li> <li> <p><code>simp</code> using the lemma to rewrites the lhs as <code>(Fintype.card (Key 3))\u207b\u00b9</code>.</p> </li> </ul>"},{"location":"crypto/otp/talk/2025Jun18-notes/#the-equivalent-proof-term_1","title":"The Equivalent Proof Term","text":"<p>This is a direct application of the lemma.</p> <p>The proof term for the rewrite is <code>PMF.uniformOfFintype_apply (Key 3) \u27e8...\u27e9</code>.</p> <p>Applying this equality to our goal transforms it.</p> <p>A proof would look like:</p> <pre><code>-- h\u2081 : PMF.uniformOfFintype (Key 3) \u27e8...\u27e9 = (Fintype.card (Key 3))\u207b\u00b9\n-- This comes from the lemma PMF.uniformOfFintype_apply\n-- We use this to transform the goal into proving:\n-- \u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> <p>This is again a form of <code>Eq.subst</code>.</p> <p>The <code>rw</code> tactic is the most direct parallel: <code>rw [PMF.uniformOfFintype_apply]</code>.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-3-computing-the-cardinality-and-final-simplification","title":"Step 3: Computing the Cardinality and Final Simplification","text":"<p>This is where <code>simp</code> really shines by combining computation and proof.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> <p>The Tactic <code>simp</code></p> <p>We don't need to provide any more lemmas. The rest is handled by Lean's built-in capabilities.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <p>The goal is solved!</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#why-this-works_2","title":"Why this works","text":"<p>Looking under the hood,</p> <ol> <li> <p>Typeclass Inference. Lean needs to know the size of <code>Key 3</code>. The type <code>Key 3</code>,     which is <code>Vector Bool 3</code>, has an instance of the <code>Fintype</code> typeclass. This     instance provides a computable function to get the number of elements.</p> </li> <li> <p>Computation. The <code>simp</code> tactic (or the <code>norm_num</code> tactic it calls internally)     executes this function. It knows <code>Vector Bool 3</code> has <code>2^3 = 8</code> elements. So it     simplifies <code>Fintype.card (Key 3)</code> to the value <code>8</code>. The goal becomes     <code>(8 : ENNReal)\u207b\u00b9 = 1/8</code>.</p> </li> <li> <p>Normalization. The <code>simp</code> engine has lemmas about <code>ENNReal</code> arithmetic.     It knows that <code>8\u207b\u00b9</code> is the same as <code>1/8</code>.</p> </li> <li> <p>Reflexivity. The goal becomes <code>1/8 = 1/8</code>. <code>simp</code> reduces both sides to the     same term, and the final <code>rfl</code> tactic confirms this equality and closes the goal.</p> </li> </ol>"},{"location":"crypto/otp/talk/2025Jun18-notes/#the-equivalent-proof-term_2","title":"The Equivalent Proof Term","text":"<p>A term-based proof must explicitly provide proofs for each of these steps.</p> <pre><code>-- A lemma that proves card (Key 3) = 8\nhave card_proof : Fintype.card (Key 3) = 8 := by-- ... proof using vector cardinality lemmas\n\n-- We use this proof to rewrite the goal\n-- The goal becomes \u22a2 8\u207b\u00b9 = 1/8\n-- This is true by reflexivity, since 8\u207b\u00b9 is just notation for 1/8 in ENNReal.\n-- The final term is:\nrfl\n</code></pre> <p>The <code>simp</code> tactic automated the process of finding <code>card_proof</code>, applying it, and then seeing that the result was definitionally equal.</p> <p>The full proof term generated by our original <code>by simp [...]</code> is effectively a  composition of all these steps, applying congruence lemmas (<code>congr_arg</code>) and  transitivity (<code>Eq.trans</code>) to chain all the intermediate equalities together into one  grand proof that the starting expression equals the final one.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#summary-agda-perspective","title":"Summary &amp; Agda Perspective","text":"Tactic Proof Step What it Does Underlying Proof Term Concept <code>by simp [\u03bcK, ...]</code> A powerful, automatic rewrite sequence. A complex, generated term chaining together multiple equalities; a function that takes no arguments and returns a proof of <code>LHS = RHS</code>. <code>rw [\u03bcK]</code> Replaces <code>\u03bcK</code> with its definition. Application of <code>Eq.subst</code> or <code>Eq.rec</code> using definitional equality of <code>\u03bcK</code>. <code>rw [lem]</code> Rewrites goal using a proven lemma <code>lem : A = B</code>. Application of <code>Eq.subst</code> using lemma <code>lem</code> as proof of equality. <code>rfl</code> Solves a goal of the form <code>A = A</code>. The constructor for equality, <code>Eq.refl A</code>; it's a direct proof object. <ul> <li> <p>From an Agda perspective, a tactic proof is essentially a program that writes a    proof term, which is why tactic writing is metaprogramming.</p> </li> <li> <p><code>simp</code> is a very high-level command, like a call to a complex library, while <code>rw</code>    and <code>rfl</code> are more like fundamental operations.</p> </li> </ul> <p>This first example was heavy on <code>simp</code>. Next, let's tackle a proof that requires more manual, step-by-step tactics like <code>intro</code>, <code>apply</code>, and <code>let</code>, which have even clearer one-to-one correspondences with proof-term constructs like <code>fun</code>, function application, and <code>let ... in ...</code>.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#lean-code-version-10","title":"Lean Code (Version 1.0)**","text":"<p>Here is the initial Lean file containing the setup from our first example.</p> <p>Copy this into <code>presentation_examples.lean</code> in your VS Code project.</p> <pre><code>-- We need to import the necessary parts of Mathlib.\nimport Mathlib.Probability.ProbabilityMassFunction.Basic\nimport Mathlib.Data.Vector.Basic\n\n/-!\n### Part 1: A Concrete First Proof\n-/\n\n-- To make our example concrete, we'll define Key n as vectors of booleans.\n-- This is equivalent to `Fin n \u2192 Bool` or other n-bit types.\nabbrev Key (n : \u2115) := Vector Bool n\n\n-- The uniform distribution over keys, as mentioned in your notes.\nnoncomputable def \u03bcK {n : \u2115} : PMF (Key n) := PMF.uniformOfFintype (Key n)\n\n-- Our theorem: The probability of the key [true, false, true] is 1/8.\nexample : \u03bcK \u27e8[true, false, true], by simp\u27e9 = (1/8 : ENNReal) := by\n  -- This proof works by unfolding definitions and simplifying.\n  -- 1. `\u03bcK` unfolds to `PMF.uniformOfFintype (Key 3)`.\n  -- 2. `PMF.uniformOfFintype_apply` rewrites the goal to `(Fintype.card (Key 3))\u207b\u00b9`.\n  -- 3. The `Fintype` instance for `Vector Bool 3` computes the cardinality to `8`.\n  -- 4. The goal simplifies to `8\u207b\u00b9 = 1/8`, which is true by definition (`rfl`).\n  simp [\u03bcK, PMF.uniformOfFintype_apply]\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun18-notes/#part-2-deconstructing-a-compositional-proof-with-bind-and-pure","title":"Part 2: Deconstructing a Compositional Proof with <code>bind</code> and <code>pure</code>","text":"<p>For our next step, we move beyond proofs that are solved by a single <code>simp</code> command and into a more structured proof that requires several foundational tactics.</p> <p>We will prove a fundamental property about the ciphertext distribution <code>\u03bcC</code>, which we defined last time using <code>bind</code> and <code>pure</code>.</p> <p>This give us the perfect opportunity to explore tactics like <code>rw</code>, <code>intro</code>, and <code>apply</code>, and examine their corresponding proof term constructions.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#recall-construction-of-c","title":"Recall construction of <code>\u03bcC</code>","text":"<p>Last time we saw that the ciphertext distribution <code>\u03bcC</code> can be constructed by chaining two probabilistic processes:</p> <ol> <li> <p>Sample a message <code>m</code> and a key <code>k</code> from their joint distribution <code>\u03bcMK</code>.</p> </li> <li> <p>Deterministically compute the ciphertext <code>c = encrypt m k</code>.</p> </li> </ol> <p>We captured this nicely in Lean as follows:</p> <pre><code>\u03bcC = bind \u03bcMK (\u03bb mk =&gt; pure (encrypt mk.1 mk.2))\n</code></pre> <p>Let's prove a theorem that shows what this actually means when we compute the probability of a specific ciphertext <code>c</code>.</p> <p>The law of total probability says that <code>P(C=c)</code> is the sum of probabilities of all <code>(m, k)</code> pairs that produce <code>c</code>.</p> <p>Theorem</p> <pre><code>\u03bcC c = \u2211' (\u27e8m , k\u27e9 : Plaintext n \u00d7 Key n), if encrypt m k = c then \u03bcMK \u27e8m , k\u27e9 else 0\n</code></pre> <p>Proving this will require unpacking the meaning of <code>bind</code> and <code>pure</code>.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-0-setup-for-the-proof","title":"Step 0: Setup for the Proof","text":"<p>First we add the necessary definitions to our Lean file.</p> <p>We need <code>Plaintext</code>s, an encryption function, and the distributions <code>\u03bcMK</code> and <code>\u03bcC</code>.</p> <p>For simplicity, we use a simple xor for encryption and assume a uniform distribution for messages.</p> <pre><code>/-!\n## Part 2: Deconstructing `bind` and `pure`\n-/\n\n-- For our example, Plaintexts are also n-bit vectors.\nabbrev Plaintext (n : \u2115) := Vector Bool n\nabbrev Ciphertext (n : \u2115) := Vector Bool n\n\n-- A simple toy encryption function: pointwise XOR.\ndef encrypt (m : Plaintext n) (k : Key n) : Ciphertext n :=\n  Vector.map\u2082 Bool.xor m k\n\n-- Assume a uniform distribution on messages for this example.\nnoncomputable def \u03bcM {n : \u2115} : PMF (Plaintext n) := PMF.uniformOfFintype (Plaintext n)\n\n-- The joint distribution assumes independence of message and key.\n-- This is a manual construction of the product distribution P(m, k) = P(m) * P(k).\nnoncomputable def \u03bcMK {n : \u2115} : PMF (Plaintext n \u00d7 Key n) :=\n  -- This is the PMF product, which corresponds to P(m, k) = P(m) * P(k)\n  PMF.prod \u03bcM \u03bcK\n\n-- The ciphertext distribution, built with bind and pure.\nnoncomputable def \u03bcC {n : \u2115} : PMF (Ciphertext n) :=\n  PMF.bind \u03bcMK (fun mk =&gt; PMF.pure (encrypt mk.1 mk.2))\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-1-unfold-everything","title":"Step 1: Unfold Everything","text":"<p>The first step in many proofs is to reveal the definitions of the objects we are reasoning about.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>theorem \u03bcC_apply_eq_sum {n : \u2115} (c : Ciphertext n) :\n    \u03bcC c = \u2211' (mk : Plaintext n \u00d7 Key n), if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0 := by\n  -- First, let's see what \u03bcC is.\n  rw [\u03bcC]\n  -- Now, let's apply the definition of how `bind` works on a specific output.\n  -- This is the crucial lemma `PMF.bind_apply`.\n  rw [PMF.bind_apply]\n</code></pre> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>\u22a2 (\u2211' (x : Plaintext n \u00d7 Key n),\n    \u03bcMK x * (PMF.pure (encrypt x.1 x.2)) c)\n  =\n  \u2211' (mk : Plaintext n \u00d7 Key n),\n    if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun18-notes/#why-this-works-proof-term-view","title":"Why this works &amp; proof term view","text":"<p>Looking under the hood,</p> <ol> <li> <p><code>rw [\u03bcC]</code>: as before, this is a substitution.</p> <p>It replaces <code>\u03bcC</code> with its definition, <code>PMF.bind \u03bcMK ...</code>.</p> <p>The proof term equivalent is <code>Eq.subst</code>.</p> </li> <li> <p><code>rw [PMF.bind_apply]</code>: this is the core of Step 1.</p> <p><code>PMF.bind_apply</code> is a theorem in Mathlib that states:</p> <pre><code>(PMF.bind p f) y = \u2211' x, p x * (f x) y\n</code></pre> <p>This lemma is the formal expression of the \"law of total probability.\"</p> <p>The <code>rw</code> tactic finds this lemma and mechanically rewrites the left-hand side of our goal to match it.</p> </li> </ol>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-2-simplify-the-pure-term","title":"Step 2: Simplify the <code>pure</code> Term","text":"<p>Our goal now involves a sum containing the term <code>(PMF.pure (encrypt x.1 x.2)) c</code>,</p> <p>where <code>pure</code> creates a deterministic distribution.</p> <p>Let's simplify that.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#the-tactic-based-proof-continuing","title":"The Tactic-Based Proof (Continuing)","text":"<pre><code>-- We have `... * (PMF.pure ...)` inside the sum. Let's simplify it.\n-- The `PMF.pure_apply` lemma says `(pure a) b` is 1 if a=b and 0 otherwise.\n-- `simp` is smart enough to apply this inside the summation.\nsimp [PMF.pure_apply]\n</code></pre> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>\u22a2 (\u2211' (x : Plaintext n \u00d7 Key n),\n    \u03bcMK x * if encrypt x.1 x.2 = c then 1 else 0)\n  =\n  \u2211' (mk : Plaintext n \u00d7 Key n),\n    if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun18-notes/#why-this-works-proof-term-view_1","title":"Why this works &amp; proof term view","text":"<ul> <li> <p><code>PMF.pure_apply</code> states <code>(PMF.pure a) b = if a = b then 1 else 0</code>.</p> </li> <li> <p><code>simp</code> applies this rewrite inside the summation (it \"simplifies under binders\").</p> </li> <li> <p>For each <code>x</code> in the sum, it replaces <code>(PMF.pure (encrypt x.1 x.2)) c</code> with    <code>if encrypt x.1 x.2 = c then 1 else 0</code>.</p> </li> <li> <p>The corresponding proof term would involve a congruence lemma for summations,    <code>tsum_congr_args</code>, which says that two sums are equal provided their bodies are    equal for all inputs.</p> </li> </ul> <p>The proof of equality of the bodies would then use <code>PMF.pure_apply</code>.</p> <p><code>simp</code> does all of this.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-3-final-touches","title":"Step 3: Final Touches","text":"<p>The two sides of the equation look almost identical.</p> <p>We just need to convince Lean that <code>P * (if cond then 1 else 0)</code> is the same as <code>if cond then P else 0</code>.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#the-tactic-based-proof-finishing","title":"The Tactic-Based Proof (Finishing)","text":"<p><pre><code>  -- The goal is now to show that `P * (if ...)` is the same as `if ... then P else ...`\n  -- This is a standard algebraic simplification.\n  simp\n</code></pre> The goal is solved. <code>simp</code> has a lemma called <code>mul_boole</code> that proves exactly this identity.</p> <p>The Equivalent Proof Term (<code>rfl</code>)</p> <p>After the final <code>simp</code>, the left and right sides are syntactically identical.</p> <p>The final step is just reflexivity, <code>Eq.refl</code>.</p> <p>The genius of <code>simp</code> is that it did the <code>rw [mul_boole]</code> and <code>rfl</code> for us.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#the-lean-code-file-version-20","title":"The Lean Code File (Version 2.0)","text":"<p>Here is the complete, updated file with our new definitions and the full proof.</p> <pre><code>-- We need to import the necessary parts of Mathlib.\nimport Mathlib.Probability.ProbabilityMassFunction.Basic\nimport Mathlib.Data.Vector.Basic\n\n/-!\n### Part 1: A Concrete First Proof\n-/\n\n-- To make our example concrete, we'll define Key n as vectors of booleans.\n-- This is equivalent to `Fin n \u2192 Bool` or other n-bit types.\nabbrev Key (n : \u2115) := Vector Bool n\n\n-- The uniform distribution over keys, as mentioned in your notes.\nnoncomputable def \u03bcK {n : \u2115} : PMF (Key n) := PMF.uniformOfFintype (Key n)\n\n-- Our theorem: The probability of the key [true, false, true] is 1/8.\nexample : \u03bcK \u27e8[true, false, true], by simp\u27e9 = (1/8 : ENNReal) := by\n  -- This proof works by unfolding definitions and simplifying.\n  -- 1. `\u03bcK` unfolds to `PMF.uniformOfFintype (Key 3)`.\n  -- 2. `PMF.uniformOfFintype_apply` rewrites the goal to `(Fintype.card (Key 3))\u207b\u00b9`.\n  -- 3. The `Fintype` instance for `Vector Bool 3` computes the cardinality to `8`.\n  -- 4. The goal simplifies to `8\u207b\u00b9 = 1/8`, which is true by definition (`rfl`).\n  simp [\u03bcK, PMF.uniformOfFintype_apply]\n\n\n/-!\n### Part 2: Deconstructing `bind` and `pure`\n-/\n\n-- For our example, Plaintexts are also n-bit vectors.\nabbrev Plaintext (n : \u2115) := Vector Bool n\nabbrev Ciphertext (n : \u2115) := Vector Bool n\n\n-- A simple toy encryption function: pointwise XOR.\ndef encrypt (m : Plaintext n) (k : Key n) : Ciphertext n :=\n  Vector.map\u2082 Bool.xor m k\n\n-- Assume a uniform distribution on messages for this example.\nnoncomputable def \u03bcM {n : \u2115} : PMF (Plaintext n) := PMF.uniformOfFintype (Plaintext n)\n\n-- The joint distribution assumes independence of message and key.\nnoncomputable def \u03bcMK {n : \u2115} : PMF (Plaintext n \u00d7 Key n) :=\n  -- This is the PMF product, which corresponds to P(m, k) = P(m) * P(k)\n  PMF.prod \u03bcM \u03bcK\n\n-- The ciphertext distribution, built with bind and pure.\nnoncomputable def \u03bcC {n : \u2115} : PMF (Ciphertext n) :=\n  PMF.bind \u03bcMK (fun mk =&gt; PMF.pure (encrypt mk.1 mk.2))\n\n\n-- Theorem: The probability of a ciphertext `c` is the sum of probabilities\n-- of all (message, key) pairs that produce `c`.\ntheorem \u03bcC_apply_eq_sum {n : \u2115} (c : Ciphertext n) :\n    \u03bcC c = \u2211' (mk : Plaintext n \u00d7 Key n), if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0 := by\n  -- First, let's see what \u03bcC is.\n  rw [\u03bcC]\n  -- Now, let's apply the definition of how `bind` works on a specific output.\n  -- This is the crucial lemma `PMF.bind_apply`.\n  rw [PMF.bind_apply]\n  -- We have `... * (PMF.pure ...)` inside the sum. Let's simplify it.\n  -- The `PMF.pure_apply` lemma says `(pure a) b` is 1 if a=b and 0 otherwise.\n  -- `simp` is smart enough to apply this inside the summation.\n  simp only [PMF.pure_apply]\n  -- The goal is now to show that `P * (if ...)` is the same as `if ... then P else ...`\n  -- This is a standard algebraic simplification handled by `mul_boole`.\n  simp\n</code></pre> <p>This second example shows how we can construct proofs by successively applying theorems (<code>rw</code>) and simplifying (<code>simp</code>).</p> <p>Next, we'll prove a more cryptographic property, namely, a simple one-time pad lemma, which requires us to introduce assumptions with <code>intro</code> and use them with <code>apply</code>.</p> <p>So far, we have explored how distributions are defined and how to prove basic equalities by unfolding those definitions. Now, let's use these building blocks to prove a foundational cryptographic property: a key lemma for the perfect secrecy of the One-Time Pad (OTP).</p> <p>This example is powerful because it's simple enough to grasp intuitively but complex enough to require new and fundamental proof tactics. It will also show how we can leverage the vast library of mathematical facts within Mathlib to our advantage.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#part-3-proving-a-cryptographic-property-one-time-pad","title":"Part 3: Proving a Cryptographic Property (One-Time Pad)","text":"<p>The core idea of the one-time pad is that if you encrypt a message with a truly random key, the resulting ciphertext is also completely random.</p> <p>In other words, observing a ciphertext <code>c</code> gives an attacker no information whatsoever about the plaintext <code>m</code> that was encrypted.</p> <p>The standard way to prove this is to show that the conditional distribution of ciphertexts, given a fixed plaintext message <code>m</code>, is uniform.</p> <p>This is the conditional distribution <code>P(C | M=m)</code> we discussed previously, which we can formalize in Lean.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-0-setup-for-the-proof_1","title":"Step 0: Setup for the Proof","text":"<p>Let's define the conditional ciphertext distribution, <code>\u03bcC_M m</code>.</p> <p>This represents the distribution of ciphertexts when we encrypt a specific, known message <code>m</code> with a random key drawn from <code>\u03bcK</code>.</p> <p>In Lean, this is a straightforward <code>map</code> operation.</p> <pre><code>/-!\n### Part 3: Proving a Cryptographic Property (One-Time Pad)\n-/\n\n-- The distribution of ciphertexts, conditioned on a fixed message `m`.\n-- This is created by taking the key distribution `\u03bcK` and mapping the function\n-- `encrypt m` over it. For each random key `k`, we produce `encrypt m k`.\nnoncomputable def \u03bcC_M {n : \u2115} (m : Plaintext n) : PMF (Ciphertext n) :=\n  PMF.map (encrypt m) \u03bcK\n</code></pre> <p>Our goal is to prove that this distribution is the uniform distribution.</p> <p>Theorem: For any message <code>m</code>, <code>\u03bcC_M m</code> is the uniform distribution over ciphertexts; that is,</p> <pre><code>\u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-1-introducing-hypotheses-with-intro","title":"Step 1: Introducing Hypotheses with <code>intro</code>","text":"<p>Our theorem starts with <code>\u2200 m...</code>, so we need to introduce an arbitrary <code>m</code>.</p> <p>The Tactic. <code>intro m</code></p> <p>The <code>intro</code> tactic consumes a universal quantifier (<code>\u2200</code>) or implication (<code>\u2192</code>).</p> <p>It takes the quantified variable (<code>m</code>) and moves it into the local context as an hypothesis.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 \u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> <p>Applying <code>intro m</code></p> <pre><code>theorem otp_perfect_secrecy_lemma {n : \u2115} :\n    \u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n) := by\n  intro m\n</code></pre> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>m: Plaintext n\n\u22a2 \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun18-notes/#the-equivalent-proof-term_3","title":"The Equivalent Proof Term","text":"<p>This is the most beautiful part for Agda fans.</p> <p>The <code>intro</code> tactic corresponds to creating a lambda abstraction.</p> <p>The proof term starts</p> <p><pre><code>\u03bb (m : Plaintext n) =&gt;\n  -- The rest of the proof, which must produce a proof of\n  -- `\u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)`\n  ...\n</code></pre> <code>intro</code> is the tactic equivalent of <code>\u03bb (m : ...) =&gt; ...</code>.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-2-proving-function-equality-with-ext","title":"Step 2: Proving Function Equality with <code>ext</code>","text":"<p>The goal is now to prove that two <code>PMF</code>s are equal.</p> <p>A <code>PMF</code> is fundamentally a function.</p> <p>The principle of function extensionality (funext)</p> <p>Two functions <code>f</code> and <code>g</code> are equal iff <code>f x = g x</code> for all <code>x</code>.</p> <p>The Tactic. <code>ext c</code></p> <p>The <code>ext</code> tactic applies the funext principle, replacing the goal <code>f = g</code> with the goal <code>\u2200 x, f x = g x</code>, and automatically running <code>intro x</code>.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <p><pre><code>m: Plaintext n\n\u22a2 \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> Applying <code>ext c</code>: <pre><code>  -- To prove two PMFs are equal, we show they give the same probability to every output.\n  ext c\n</code></pre></p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>m: Plaintext n\nc: Ciphertext n\n\u22a2 \u03bcC_M m c = PMF.uniformOfFintype (Ciphertext n) c\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun18-notes/#the-equivalent-proof-term_4","title":"The Equivalent Proof Term","text":"<p>The <code>ext</code> tactic is a shortcut for applying the <code>funext</code> axiom.</p> <p>The proof term would look like</p> <p><pre><code>fun (m : Plaintext n) =&gt;\n  funext (fun (c : Ciphertext n) =&gt;\n    -- The rest of the proof, which must produce a proof of\n    -- `\u03bcC_M m c = ...`\n    ...\n  )\n</code></pre> So,</p> <ul> <li><code>intro</code> builds lambdas for <code>\u2200</code>,</li> <li><code>ext</code> builds lambdas for function equality.</li> </ul>"},{"location":"crypto/otp/talk/2025Jun18-notes/#step-3-using-the-mathlib-machinery","title":"Step 3: Using the Mathlib Machinery","text":"<p>We could now unfold all the definitions with <code>rw</code> and prove this from first principles.</p> <p>However, Mathlib has already done the hard work for us!</p> <p>There is a powerful theorem, <code>PMF.map_of_bijective</code>, that says:</p> <p>If you <code>map</code> a uniform distribution through a <code>bijective</code> function, the result is another uniform distribution.</p> <p>Our <code>encrypt m</code> function (which is <code>\u03bb k =&gt; m xor k</code>) is a bijection from <code>Key n</code> to <code>Ciphertext n</code>.</p> <p>Let's use that fact.</p>"},{"location":"crypto/otp/talk/2025Jun18-notes/#tactic-based-proof-finishing","title":"Tactic-Based Proof (Finishing)","text":"<pre><code>  -- Unfold the definition of \u03bcC_M to expose the `map`.\n  rw [\u03bcC_M]\n  -- Now, apply the powerful lemma from Mathlib.\n  rw [PMF.map_of_bijective (encrypt m) (\u03bb k =&gt; encrypt_is_bijective m k)]\n</code></pre> <p>This is a bit complex:</p> <ul> <li> <p>The <code>rw</code> tactic here uses <code>PMF.map_of_bijective</code>.</p> </li> <li> <p>This requires a proof that our encryption function is bijective.</p> </li> <li> <p>We pass that as an argument: <code>(encrypt_is_bijective m)</code>.</p> </li> </ul>"},{"location":"crypto/otp/talk/2025Jun18-notes/#tactic-based-proof-alt-ending","title":"Tactic-Based Proof (Alt Ending)","text":"<p>The <code>simp</code> tactic is actually smart enough to figure this out if we set it up correctly!</p> <p>A cleaner proof looks like this:</p> <pre><code>-- First, we prove that encryption is a bijection. This is a helper lemma.\nlemma encrypt_bijective {n : \u2115} (m : Plaintext n) : Function.Bijective (encrypt m) :=\n  -- This is true because XORing with a constant is its own inverse.\n  Function.Bijective.of_involutive (\u03bb k =&gt; by simp [encrypt, Vector.map\u2082_map, Bool.xor_comm, Bool.xor_self])\n\n-- Now the main proof becomes incredibly clean.\ntheorem otp_perfect_secrecy_lemma {n : \u2115} :\n    \u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n) := by\n  intro m\n  rw [\u03bcC_M] -- Unfold our definition\n  -- `simp` finds the `map_of_bijective` lemma and our `encrypt_bijective` lemma!\n  simp [\u03bcK, PMF.map_of_bijective, encrypt_bijective m]\n</code></pre> <p>The <code>simp</code> call does all the work:</p> <ul> <li>unfolds <code>\u03bcK</code> to see it's uniform,</li> <li>sees the <code>PMF.map</code>,</li> <li>finds the <code>map_of_bijective</code> lemma,</li> <li>proves the side-condition by applying our <code>encrypt_bijective</code> helper lemma.</li> </ul> <p>Typical workflow</p> <ol> <li>Identify the high-level mathematical property you need (e.g., mapping a distribution over a bijection).</li> <li>Prove it as a separate lemma.</li> <li>Use that lemma to make your main proof clean and conceptual.</li> </ol>"},{"location":"crypto/otp/talk/2025Jun18-notes/#the-lean-code-file-version-30","title":"The Lean Code File (Version 3.0)","text":"<p>Here is the complete file. It now contains the proof of the OTP secrecy lemma, which you can test and explore in VS Code.</p> <pre><code>-- We need to import the necessary parts of Mathlib.\nimport Mathlib.Probability.ProbabilityMassFunction.Basic\nimport Mathlib.Data.Vector.Basic\n\n/-!\n### Part 1: A Concrete First Proof\n-/\n\n-- To make our example concrete, we'll define Key n as vectors of booleans.\nabbrev Key (n : \u2115) := Vector Bool n\n\n-- The uniform distribution over keys, as mentioned in your notes.\nnoncomputable def \u03bcK {n : \u2115} : PMF (Key n) := PMF.uniformOfFintype (Key n)\n\n-- Our theorem: The probability of the key [true, false, true] is 1/8.\nexample : \u03bcK \u27e8[true, false, true], by simp\u27e9 = (1/8 : ENNReal) := by\n  simp [\u03bcK, PMF.uniformOfFintype_apply]\n\n\n/-!\n### Part 2: Deconstructing `bind` and `pure`\n-/\n\n-- For our example, Plaintexts are also n-bit vectors.\nabbrev Plaintext (n : \u2115) := Vector Bool n\nabbrev Ciphertext (n : \u2115) := Vector Bool n\n\n-- A simple toy encryption function: pointwise XOR.\ndef encrypt (m : Plaintext n) (k : Key n) : Ciphertext n :=\n  Vector.map\u2082 Bool.xor m k\n\n-- Assume a uniform distribution on messages for this example.\nnoncomputable def \u03bcM {n : \u2115} : PMF (Plaintext n) := PMF.uniformOfFintype (Plaintext n)\n\n-- The joint distribution assumes independence of message and key.\nnoncomputable def \u03bcMK {n : \u2115} : PMF (Plaintext n \u00d7 Key n) :=\n  PMF.prod \u03bcM \u03bcK\n\n-- The ciphertext distribution, built with bind and pure.\nnoncomputable def \u03bcC {n : \u2115} : PMF (Ciphertext n) :=\n  PMF.bind \u03bcMK (fun mk =&gt; PMF.pure (encrypt mk.1 mk.2))\n\n\n-- Theorem: The probability of a ciphertext `c` is the sum of probabilities\n-- of all (message, key) pairs that produce `c`.\ntheorem \u03bcC_apply_eq_sum {n : \u2115} (c : Ciphertext n) :\n    \u03bcC c = \u2211' (mk : Plaintext n \u00d7 Key n), if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0 := by\n  rw [\u03bcC, PMF.bind_apply]\n  simp only [PMF.pure_apply, mul_boole]\n\n\n/-!\n### Part 3: Proving a Cryptographic Property (One-Time Pad)\n-/\n\n-- The distribution of ciphertexts, conditioned on a fixed message `m`.\nnoncomputable def \u03bcC_M {n : \u2115} (m : Plaintext n) : PMF (Ciphertext n) :=\n  PMF.map (encrypt m) \u03bcK\n\n-- Helper lemma: For a fixed message m, encryption is a bijection from keys to ciphertexts.\nlemma encrypt_bijective {n : \u2115} (m : Plaintext n) : Function.Bijective (encrypt m) :=\n  -- This is true because XORing with a constant is its own inverse.\n  -- The proof is to show that applying the function twice gets you back to the start.\n  Function.Bijective.of_involutive (fun k =&gt; by\n    -- We need to show `encrypt m (encrypt m k) = k`\n    simp [encrypt, Vector.map\u2082_map, Bool.xor_comm, Bool.xor_assoc, Bool.xor_self, Bool.xor_false])\n\n-- Theorem: For any message m, the distribution of ciphertexts is uniform.\n-- This is a key lemma for proving the perfect secrecy of the one-time pad.\ntheorem otp_perfect_secrecy_lemma {n : \u2115} :\n    \u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n) := by\n  -- Consider an arbitrary message m.\n  intro m\n  -- Unfold the definition of our conditional distribution.\n  rw [\u03bcC_M]\n  -- The main argument: mapping a uniform distribution over a bijection yields\n  -- a uniform distribution. `simp` can apply this high-level theorem for us.\n  -- It uses our `encrypt_bijective` lemma to satisfy the precondition.\n  simp [\u03bcK, PMF.map_of_bijective, encrypt_bijective m]\n</code></pre> <p>[1] ...by the Gemini AI Agent.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/","title":"Lean4: a primer for paranoids and pedants","text":"<p>We will demonstrate not only how to prove properties in Lean but also why the methods work, connecting the seemingly magical world of tactics to the solid ground of proof objects, with which we are more familiar from Agda.</p> <p>We'll start by reviewing a concrete, fundamental example from last time: computing the probability of choosing a specific key at random.</p> <p>This will allow us to bring the ideas down to earth and immediately dive into and discuss the tactic vs. proof object dichotomy.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#part-1-a-concrete-first-proof","title":"Part 1: A Concrete First Proof","text":"<p>Let's start with the</p> <p>Claim. The probability of randomly choosing a specific 3-bit key is 1/8.</p> <p>In Lean, the theorem and its tactic-based proof are very concise.</p> <pre><code>import Mathlib.Probability.Distributions.Uniform\n\n-- (Assuming a file OTP.Basic with the definition of Key)\nopen OTP\n-- Recall, we define `Key n` as vectors of booleans.\n-- This is equivalent to `Fin n \u2192 Bool` or other n-bit types.\n\n-- Here is the uniform distribution over keys of length n.\nnoncomputable def \u03bcK {n : \u2115} : PMF (Key n) := PMF.uniformOfFintype (Key n)\n\n-- Our claim: the probability of choosing key [true, false, true] is 1/8.\nexample : \u03bcK \u27e8[true, false, true], rfl\u27e9 = (1/8 : ENNReal) :=\n -- and here's the tactic-based proof in Lean:\n  by simp [\u03bcK, PMF.uniformOfFintype_apply]; rfl\n</code></pre> <p>This is great for a user who knows what <code>simp</code> means and does, but it may seem like a magical incantation for the newcomer.</p> <p>So, let's unpack it.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#deconstructing-simp","title":"Deconstructing <code>simp</code>","text":"<p>The <code>simp</code> tactic is an automated rewriter.</p> <p>It tries to simplify the main goal by applying a list of theorems (called a \"simpset\") from left to right, over and over, until no more simplifications can be made.</p> <p>When you write <code>simp [foo, bar]</code>, you are telling Lean:</p> <p>\"Please use your standard simpset, plus the definitions/lemmas <code>foo</code> and <code>bar</code> to the set of tools you can use to simplify or reduce the goal.\"</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#step-1-unfolding-the-definition-of-k","title":"Step 1: Unfolding the Definition of <code>\u03bcK</code>","text":"<p>Let's break down the proof step-by-step, showing the tactic at each stage, and then discuss the proof object it's building.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 \u03bcK \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>Here, <code>\u22a2</code> indicates the goal we are trying to prove.</p> <p>The Tactic <code>simp [\u03bcK]</code> or <code>rw [\u03bcK]</code></p> <p>tells Lean to substitute <code>\u03bcK</code> with its definition.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>\u22a2 PMF.uniformOfFintype (Key 3) \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun19-notes/#why-this-works","title":"Why this works","text":"<p>Looking under the hood,</p> <ul> <li> <p><code>\u03bcK</code> is defined as <code>PMF.uniformOfFintype (Key n)</code>.</p> </li> <li> <p><code>simp</code> (and the more targeted <code>rw</code>) can access all definitions in context.</p> </li> <li> <p>It sees the term <code>\u03bcK</code> in the goal and replaces it with its definition; a   simple substitution.</p> </li> </ul>"},{"location":"crypto/otp/talk/2025Jun19-notes/#the-equivalent-proof-term","title":"The Equivalent Proof Term","text":"<p>In a term-based proof, the substitution is achieved using functions that show equality is respected by function application.</p> <p>If we have a proof <code>h : \u03bcK = PMF.uniformOfFintype (Key 3)</code>, we can use it to rewrite the goal.</p> <p>The definition itself provides this proof <code>h</code>. The core idea is <code>Eq.subst</code> or <code>Eq.rec</code>.</p> <p>A proof term for just this step would look like this:</p> <pre><code>-- Let P be the property we are trying to prove for the definition.\n-- P := \u03bb x =&gt; x \u27e8[true, false, true], _\u27e9 = 1/8\n-- Our goal is `P (\u03bcK)`\n-- The definition of \u03bcK gives us `proof_of_definition : \u03bcK = PMF.uniformOfFintype (Key 3)`\n\n-- The new proof term is:\nEq.subst proof_of_definition (new_goal : P (PMF.uniformOfFintype (Key 3)))\n</code></pre> <p>...which is a bit clunky.</p> <p>A more common term-based idiom is to simply start with the definition already unfolded.</p> <p>The tactic <code>rw</code> is essentially a mechanical way of applying <code>Eq.subst</code>.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#step-2-unfolding-definition-of-uniform-pmf","title":"Step 2: Unfolding Definition of Uniform PMF","text":"<p>Now we apply the definition of what <code>uniformOfFintype</code> evaluates to for a given input.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 PMF.uniformOfFintype (Key 3) \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>The Tactic <code>simp [PMF.uniformOfFintype_apply]</code></p> <p>The lemma <code>PMF.uniformOfFintype_apply</code> states:</p> <p>If <code>a</code> is an inhabitant of the finite type <code>\u03b1</code>, then</p> <p><code>PMF.uniformOfFintype \u03b1 a</code> is equal to <code>(Fintype.card \u03b1)\u207b\u00b9</code>.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>\u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun19-notes/#why-this-works_1","title":"Why this works","text":"<p>Looking under the hood,</p> <ul> <li> <p><code>simp</code> finds a lemma <code>PMF.uniformOfFintype_apply</code> in the library;</p> </li> <li> <p>This lemma matches the pattern <code>PMF.uniformOfFintype (Key 3) ...</code> on the lhs of our goal;</p> </li> <li> <p><code>simp</code> using the lemma to rewrites the lhs as <code>(Fintype.card (Key 3))\u207b\u00b9</code>.</p> </li> </ul>"},{"location":"crypto/otp/talk/2025Jun19-notes/#the-equivalent-proof-term_1","title":"The Equivalent Proof Term","text":"<p>This is a direct application of the lemma.</p> <p>The proof term for the rewrite is <code>PMF.uniformOfFintype_apply (Key 3) \u27e8...\u27e9</code>.</p> <p>Applying this equality to our goal transforms it.</p> <p>A proof would look like:</p> <pre><code>-- h\u2081 : PMF.uniformOfFintype (Key 3) \u27e8...\u27e9 = (Fintype.card (Key 3))\u207b\u00b9\n-- This comes from the lemma PMF.uniformOfFintype_apply\n-- We use this to transform the goal into proving:\n-- \u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> <p>This is again a form of <code>Eq.subst</code>.</p> <p>The <code>rw</code> tactic is the most direct parallel: <code>rw [PMF.uniformOfFintype_apply]</code>.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#step-3-computing-the-cardinality-and-final-simplification","title":"Step 3: Computing the Cardinality and Final Simplification","text":"<p>This is where <code>simp</code> really shines by combining computation and proof.</p> <p>\ud83e\udd45 Goal State Before the Tactic \ud83e\udd45</p> <pre><code>\u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> <p>The Tactic <code>simp; rfl</code></p> <p>We don't need to provide any more lemmas. The rest is handled by Lean's built-in capabilities.</p> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <p>The goal is solved!</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#why-this-works_2","title":"Why this works","text":"<p>Looking under the hood,</p> <ol> <li> <p>Typeclass Inference. Lean needs to know the size of <code>Key 3</code>. The type <code>Key 3</code>,     which is <code>Vector Bool 3</code>, has an instance of the <code>Fintype</code> typeclass. This     instance provides a computable function to get the number of elements.</p> </li> <li> <p>Computation. The <code>simp</code> tactic (or the <code>norm_num</code> tactic it calls internally)     executes the cardinality function, simplifying <code>Fintype.card (Key 3)</code> to <code>8</code>. The     goal becomes <code>(8 : ENNReal)\u207b\u00b9 = 1/8</code>.</p> </li> <li> <p>Normalization. The <code>simp</code> engine has lemmas about <code>ENNReal</code> arithmetic.     It knows that <code>8\u207b\u00b9</code> is the same as <code>1/8</code>.</p> </li> <li> <p>Reflexivity. The goal becomes <code>1/8 = 1/8</code>. <code>simp</code> reduces both sides to the     same term, and the final <code>rfl</code> tactic confirms this equality and closes the goal.</p> </li> </ol>"},{"location":"crypto/otp/talk/2025Jun19-notes/#the-equivalent-proof-term_2","title":"The Equivalent Proof Term","text":"<p>A term-based proof must explicitly provide proofs for each of these steps.</p> <pre><code>-- A lemma that proves card (Key 3) = 8\nhave card_proof : Fintype.card (Key 3) = 8 := by-- ... proof using vector cardinality lemmas\n\n-- We use this proof to rewrite the goal\n-- The goal becomes \u22a2 8\u207b\u00b9 = 1/8\n-- This is true by reflexivity, since 8\u207b\u00b9 is just notation for 1/8 in ENNReal.\n-- The final term is:\nrfl\n</code></pre> <p>The <code>simp</code> tactic automated the process of finding <code>card_proof</code>, applying it, and then seeing that the result was definitionally equal.</p> <p>The full proof term generated by our original <code>by simp [...]</code> is effectively a  composition of all these steps, applying congruence lemmas (<code>congr_arg</code>) and  transitivity (<code>Eq.trans</code>) to chain all the intermediate equalities together into one  grand proof that the starting expression equals the final one.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#summary-agda-perspective","title":"Summary &amp; Agda Perspective","text":"Tactic Proof Step What it Does Underlying Proof Term Concept <code>by simp [\u03bcK, ...]</code> A powerful, automatic rewrite sequence. A complex, generated term chaining together multiple equalities; a function that takes no arguments and returns a proof of <code>LHS = RHS</code>. <code>rw [\u03bcK]</code> Replaces <code>\u03bcK</code> with its definition. Application of <code>Eq.subst</code> or <code>Eq.rec</code> using definitional equality of <code>\u03bcK</code>. <code>rw [lem]</code> Rewrites goal using a proven lemma <code>lem : A = B</code>. Application of <code>Eq.subst</code> using lemma <code>lem</code> as proof of equality. <code>rfl</code> Solves a goal of the form <code>A = A</code>. The constructor for equality, <code>Eq.refl A</code>; it's a direct proof object. <ul> <li> <p>From an Agda perspective, a tactic proof is essentially a program that writes a    proof term, which is why tactic writing is metaprogramming.</p> </li> <li> <p><code>simp</code> is a very high-level command, like a call to a complex library, while <code>rw</code>    and <code>rfl</code> are more like fundamental operations.</p> </li> </ul> <p>This first example was heavy on <code>simp</code>. Next, let's tackle a proof that requires more manual, step-by-step tactics like <code>intro</code>, <code>apply</code>, and <code>let</code>, which have even clearer one-to-one correspondences with proof-term constructs like <code>fun</code>, function application, and <code>let ... in ...</code>.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#part-2-deconstructing-a-compositional-proof-with-bind-and-pure","title":"Part 2: Deconstructing a Compositional Proof with <code>bind</code> and <code>pure</code>","text":"<p>For our next step, we move beyond proofs that are solved by a single <code>simp</code> command and into a more structured proof that requires several foundational tactics.</p> <p>We will prove a fundamental property about the ciphertext distribution <code>\u03bcC</code>, which we defined last time using <code>bind</code> and <code>pure</code>.</p> <p>This give us the perfect opportunity to explore tactics like <code>rw</code>, <code>intro</code>, and <code>apply</code>, and examine their corresponding proof term constructions.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#recall-construction-of-c","title":"Recall construction of <code>\u03bcC</code>","text":"<p>Last time we saw that the ciphertext distribution <code>\u03bcC</code> can be constructed by chaining two probabilistic processes:</p> <ol> <li> <p>Sample a message <code>m</code> and a key <code>k</code> from their joint distribution <code>\u03bcMK</code>.</p> </li> <li> <p>Deterministically compute the ciphertext <code>c = encrypt m k</code>.</p> </li> </ol> <p>We captured this nicely in Lean as follows:</p> <pre><code>\u03bcC = bind \u03bcMK (\u03bb mk =&gt; pure (encrypt mk.1 mk.2))\n</code></pre> <p>Let's prove a theorem that shows what this actually means when we compute the probability of a specific ciphertext <code>c</code>.</p> <p>The law of total probability says that <code>P(C=c)</code> is the sum of probabilities of all <code>(m, k)</code> pairs that produce <code>c</code>.</p> <p>Theorem</p> <pre><code>\u03bcC c = \u2211' (\u27e8m , k\u27e9 : Plaintext n \u00d7 Key n), if encrypt m k = c then \u03bcMK \u27e8m , k\u27e9 else 0\n</code></pre> <p>Proving this will require unpacking the meaning of <code>bind</code> and <code>pure</code>.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#step-0-setup-for-the-proof","title":"Step 0: Setup for the Proof","text":"<p>First we add the necessary definitions to our Lean file.</p> <p>We need <code>Plaintext</code>s, an encryption function, and the distributions <code>\u03bcMK</code> and <code>\u03bcC</code>.</p> <p>For simplicity, we use a simple xor for encryption and assume a uniform distribution for messages.</p> <pre><code>/-!\n## Part 2: Deconstructing `bind` and `pure`\n-/\n\n-- Assume a uniform distribution on messages for this example.\nnoncomputable def \u03bcM {n : \u2115} : PMF (Plaintext n) := PMF.uniformOfFintype (Plaintext n)\n\n-- The joint distribution assumes independence of message and key.\n-- This is a manual construction of the product distribution P(m, k) = P(m) * P(k).\nnoncomputable def \u03bcMK {n : \u2115} : PMF (Plaintext n \u00d7 Key n) :=\n  PMF.bind \u03bcM (\u03bb m =&gt; PMF.map (\u03bb k =&gt; (m, k)) \u03bcK)\n\n-- The ciphertext distribution, built with bind and pure.\nnoncomputable def \u03bcC {n : \u2115} : PMF (Ciphertext n) :=\n  PMF.bind \u03bcMK (\u03bb \u27e8m, k\u27e9 =&gt; PMF.pure (encrypt m k))\n</code></pre> <p>The law of total probability says that <code>P(C=c)</code> is the sum of probabilities of all <code>(m, k)</code> pairs that produce <code>c</code>.</p> <p>Theorem</p> <p><code>\u03bcC c = \u2211' (mk : Plaintext n \u00d7 Key n), if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0</code></p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#the-proof-step-by-step","title":"The Proof Step-by-Step","text":"<p>Here is the complete, corrected proof in Lean: <pre><code>open Classical\ntheorem \u03bcC_apply_eq_sum {n : \u2115} (c : Ciphertext n) :\n  \u03bcC c = \u2211' mk : Plaintext n \u00d7 Key n, if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0\n  := by\n  rw [\u03bcC, PMF.bind_apply]\n  simp only [PMF.pure_apply, mul_boole]\n  congr 1\n  ext mk\n  simp only [eq_comm]\n</code></pre></p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#step-1-unfold-bind","title":"Step 1: Unfold <code>bind</code>","text":"<p>Tactics. <code>rw [\u03bcC, PMF.bind_apply]</code></p> <ul> <li> <p><code>rw [\u03bcC]</code>: as before, this is a substitution.</p> <p>It replaces <code>\u03bcC</code> with its definition, <code>PMF.bind \u03bcMK ...</code>.</p> <p>The proof term equivalent is <code>Eq.subst</code>.</p> </li> <li> <p><code>rw [PMF.bind_apply]</code>: this is the core of Step 1.</p> <p><code>PMF.bind_apply</code> is a theorem in Mathlib that states:</p> <pre><code>(PMF.bind p f) y = \u2211' x, p x * (f x) y\n</code></pre> <p>This is a formal expression of the law of total probability.</p> <p><code>rw</code> finds this lemma and mechanically rewrites the lhs of our goal to match it.</p> </li> </ul>"},{"location":"crypto/otp/talk/2025Jun19-notes/#step-1-unfold-pure","title":"Step 1: Unfold <code>pure</code>","text":"<p>\ud83e\udd45 Goal State \ud83e\udd45</p> <pre><code>n : \u2115\nc : Ciphertext n\n\u22a2 \u2211' (a : Plaintext n \u00d7 Key n),\n    \u03bcMK a * (match a with | (m, k) =&gt; PMF.pure (encrypt m k)) c\n= \u2211' (mk : Plaintext n \u00d7 Key n), if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0\n</code></pre> <p>Tactics. <code>simp only [PMF.pure_apply, mul_boole]</code></p> <ul> <li><code>PMF.pure_apply</code> says <code>(pure a) b</code> is 1 if <code>a = b</code> and 0 otherwise.</li> </ul> <p><code>simp</code> is smart enough to apply this inside the summation.</p> <ul> <li><code>mul_boole</code> simplifies multiplication with the indicator function.</li> </ul> <p>It turns the <code>if</code> into a multiplication by <code>1</code> or <code>0</code>.</p> <p>\ud83e\udd45 Goal State After the Tactics \ud83e\udd45</p> <pre><code>\u22a2 (\u2211' mk, if c = encrypt mk.1 mk.2 then \u03bcMK mk else 0)\n= (\u2211' mk, if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0)\n</code></pre> <p>Now the only difference between the two sides is the order of the equality:</p> <p><code>c = ...</code> versus <code>... = c</code>.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#step-2-aligning-the-summations","title":"Step 2: Aligning the Summations","text":"<p>We need to show the bodies of the two summations are equal.</p> <p>Tactics. <code>congr 1; ext mk</code></p> <ul> <li> <p><code>congr 1</code>. This \"congruence\" tactic focuses the proof on the first arguments of the   equality\u2014in this case, the functions inside the summations <code>\u2211'</code>.</p> </li> <li> <p><code>ext mk</code>. This \"extensionality\" tactic then states we can prove the two functions   are equal by proving they are equal for an arbitrary input, which it names <code>mk</code>.</p> </li> </ul> <p>\ud83e\udd45 Goal State After the Tactic \ud83e\udd45</p> <pre><code>mk: Plaintext n \u00d7 Key n\n\u22a2 (if c = encrypt mk.1 mk.2 then \u03bcMK mk else 0) = (if encrypt mk.1 mk.2 = c then \u03bcMK mk else 0)\n</code></pre>"},{"location":"crypto/otp/talk/2025Jun19-notes/#step-3-finishing-with-eq_comm","title":"Step 3: Finishing with <code>eq_comm</code>","text":"<p>Now we just resolve the switched equality.</p> <p>Tactic. <code>simp only [eq_comm]</code></p> <ul> <li>The lemma <code>eq_comm</code> states that <code>a = b</code> is equivalent to <code>b = a</code>. <code>simp</code> uses this   to rewrite the goal, making the two sides identical and closing the proof.</li> </ul>"},{"location":"crypto/otp/talk/2025Jun19-notes/#part-3-proving-a-cryptographic-property-one-time-pad","title":"Part 3: Proving a Cryptographic Property (One-Time Pad)","text":"<p>The standard way to prove the perfect secrecy of OTP is to show that for any fixed plaintext <code>m</code>, the conditional distribution of ciphertexts is uniform.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#step-0-setup-for-the-proof_1","title":"Step 0: Setup for the Proof","text":"<p>We define the conditional distribution <code>\u03bcC_M m</code> by mapping the encryption function over the uniform key distribution.</p> <pre><code>-- The distribution of ciphertexts, conditioned on a fixed message `m`.\nnoncomputable def \u03bcC_M {n : \u2115} (m : Plaintext n) : PMF (Ciphertext n) :=\n  PMF.map (encrypt m) \u03bcK\n</code></pre> <p>Our goal is to prove that this distribution is uniform.</p> <p>Theorem: <code>\u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)</code></p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#a-detour-into-equivalences","title":"A Detour into Equivalences (<code>\u2243</code>)","text":"<p>Key mathematical insight: for a fixed <code>m</code>, the function <code>encrypt m</code> is a bijection.</p> <p>In Lean, such a bijection is captured by the type <code>Equiv</code>, written <code>\u03b1 \u2243 \u03b2</code>.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#what-is-an-equiv","title":"What is an <code>Equiv</code>?","text":"<p>An <code>Equiv</code> is a structure that bundles a function, its inverse, and proofs that they are indeed inverses of each other. It represents an isomorphism between types.</p> <p>The formal definition in Mathlib is: <pre><code>structure Equiv (\u03b1 : Sort*) (\u03b2 : Sort*) where\n  toFun    : \u03b1 \u2192 \u03b2        -- The forward function\n  invFun   : \u03b2 \u2192 \u03b1        -- The inverse function\n  left_inv  : Function.LeftInverse invFun toFun   -- proof of invFun (toFun x) = x\n  right_inv : Function.RightInverse invFun toFun  -- proof of toFun (invFun y) = y\n</code></pre></p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#how-to-construct-an-equiv-intro","title":"How to Construct an <code>Equiv</code> (Intro)","text":"<p>There are two main ways to build an equivalence.</p> <ol> <li> <p>From an Involutive Function (High-Level)</p> <p>If a function is its own inverse, like <code>not</code> or our <code>encrypt m</code>, you can use the constructor <code>Equiv.ofInvolutive</code>.</p> <pre><code>-- Helper lemma: For a fixed message m, encryption is its own inverse.\nlemma encrypt_involutive {n : \u2115} (m : Plaintext n) :\n  Function.Involutive (encrypt m) := by ...\n\n-- We build the Equiv directly from this property.\ndef encrypt_equiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n :=\n  Equiv.ofInvolutive (encrypt m) (encrypt_involutive m)\n</code></pre> </li> <li> <p>By Hand (Low-Level)</p> <p>You can construct one by providing all four fields. This is useful for simple cases.</p> <pre><code>-- An equivalence between Bool and Bool using `not`.\ndef not_equiv : Bool \u2243 Bool where\n  toFun    := not\n  invFun   := not\n  left_inv  := Bool.not_not\n  right_inv := Bool.not_not\n</code></pre> </li> </ol>"},{"location":"crypto/otp/talk/2025Jun19-notes/#how-to-use-an-equiv-elim","title":"How to Use an <code>Equiv</code> (Elim)","text":"<p>Once you have an <code>Equiv</code>, you can use it in several ways.</p> <ol> <li> <p>As a Function. Lean knows how to treat an <code>Equiv</code> <code>e</code> as a function. You can just write <code>e x</code>.</p> </li> <li> <p>Accessing the Inverse. The inverse is available as <code>e.symm</code>. So you can write <code>e.symm y</code>.</p> </li> <li> <p>Using the Proofs. The proofs <code>e.left_inv</code> and <code>e.right_inv</code> are powerful tools for rewriting.</p> </li> </ol> <pre><code>example (e : \u03b1 \u2243 \u03b2) (x : \u03b1) : e.symm (e x) = x := by\n  -- The goal is exactly the statement of the left_inv property.\n  simp [e.left_inv]\n</code></pre> <ul> <li> <p>Understanding how to construct and use equivalences is crucial for many proofs    involving bijections.</p> </li> <li> <p>The final step of our OTP theorem would be to find the right Mathlib lemma that    uses this <code>encrypt_equiv</code> to prove that the <code>map</code> of a uniform distribution is    still uniform.</p> </li> </ul>"},{"location":"crypto/otp/talk/2025Jun19-notes/#next","title":"Next","text":"<ol> <li> <p>A detailed Markdown explanation of our proof for <code>otp_perfect_secrecy_lemma</code>.</p> </li> <li> <p>An explanation for why <code>encrypt_equiv</code> must be <code>noncomputable</code> while <code>xorEquiv</code> is not.</p> </li> </ol> <p>Let's tackle the <code>noncomputable</code> question first, as it's a deep and important concept in Lean.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#computable-vs-noncomputable-definitions","title":"Computable vs. Noncomputable Definitions","text":"<p>The reason one definition is <code>noncomputable</code> and the other is not comes down to how the inverse function is provided.</p> <p>It's a classic case of being constructive versus classical.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#def-xorequiv-constructive","title":"<code>def xorEquiv</code> (Constructive)","text":"<pre><code>def xorEquiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n where\n  toFun     := encrypt m\n  invFun    := vec_xor m -- We explicitly provide the inverse function\n  left_inv  := by ...\n  right_inv := by ...\n</code></pre> <p>Here, we create the <code>Equiv</code> structure by hand. We provide all four components:</p> <ol> <li> <p><code>toFun</code>: The forward function, <code>encrypt m</code>.</p> </li> <li> <p><code>invFun</code>: The inverse function, <code>vec_xor m</code>. We explicitly construct and provid this function.</p> </li> <li> <p><code>left_inv</code>: A proof that <code>vec_xor m (encrypt m k) = k</code>.</p> </li> <li> <p><code>right_inv</code>: A proof that <code>encrypt m (vec_xor m c) = c</code>.</p> </li> </ol> <p>Because every component is explicitly defined and computable, the entire <code>xorEquiv</code> definition is computable.</p>"},{"location":"crypto/otp/talk/2025Jun19-notes/#noncomputable-def-encrypt_equiv-classical","title":"<code>noncomputable def encrypt_equiv</code> (Classical)","text":"<pre><code>noncomputable def encrypt_equiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n :=\n  Equiv.ofBijective (encrypt m) (encrypt_bijective m)\n</code></pre> <p>Here, we use the high-level constructor <code>Equiv.ofBijective</code>. We provide it with:</p> <ol> <li> <p>A function, <code>encrypt m</code>.</p> </li> <li> <p>A proof, <code>encrypt_bijective m</code>, which proves that the function is both injective and surjective.</p> </li> </ol> <p>But notice what's missing: we never told Lean what the inverse function is!</p> <p>The <code>Equiv.ofBijective</code> constructor has to create the inverse function for us.</p> <p>How does it do that?  It uses the proof of surjectivity.</p> <p>A proof of <code>Surjective (encrypt m)</code> says \"for every ciphertext <code>c</code>, there exists a key <code>k</code> such that <code>encrypt m k = c</code>.\"</p> <p>To define an inverse function, Lean must choose such a <code>k</code> for each <code>c</code>.</p> <p>This act of choosing an object from a proof of its existence requires the axiom of choice (<code>Classical.choice</code>).</p> <p>In Lean's constructive logic, any definition that depends on the axiom of choice is marked as <code>noncomputable</code>.</p> <p>In short:</p> <ul> <li> <p><code>xorEquiv</code> is computable because we did the work of providing the inverse function constructively.</p> </li> <li> <p><code>encrypt_equiv</code> is noncomputable because we asked Lean to conjure the inverse function out of a classical existence proof, forcing it to use the noncomputable axiom of choice.</p> </li> </ul>"},{"location":"crypto/otp/talk/2025Jun19-notes/#explaining-the-otp_perfect_secrecy_lemma-proof","title":"Explaining the <code>otp_perfect_secrecy_lemma</code> Proof","text":"<p>Theorem to Prove:</p> <pre><code>theorem otp_perfect_secrecy_lemma {n : \u2115} :\n    \u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> <p>The Proof, Explained: <pre><code>theorem otp_perfect_secrecy_lemma {n : \u2115} :\n    \u2200 (m : Plaintext n), \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n) := by\n  intro m\n  have h\u03bc : \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n) := by\n    apply map_uniformOfFintype_equiv (xorEquiv m)\n  simp [h\u03bc, PMF.uniformOfFintype_apply]\n</code></pre></p> <ul> <li> <p>Tactic <code>intro m</code></p> <ul> <li>What it does: The proof begins by addressing the \"for all <code>m</code>\" part of the theorem.</li> </ul> <p>The <code>intro</code> tactic introduces an arbitrary but fixed message <code>m</code> that we can work with for the rest of the proof.</p> <ul> <li> <p>Goal State:</p> <pre><code>m: Plaintext n\n\u22a2 \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> </li> </ul> </li> <li> <p>Tactic <code>have h\u03bc : ... := by ...</code></p> <ul> <li> <p>What it does: This is the main logical step. The <code>have</code> tactic lets us prove a helper fact, or lemma, which we can then use to prove our main goal. Here, we are proving a fact named <code>h\u03bc</code>. Coincidentally, <code>h\u03bc</code> is the exact statement of our main goal.</p> </li> <li> <p>The Sub-Proof: The proof of <code>h\u03bc</code> is <code>apply map_uniformOfFintype_equiv (xorEquiv m)</code>. This applies the helper lemma you proved earlier, which states that mapping a uniform distribution over an equivalence (<code>xorEquiv m</code>) results in a uniform distribution. This single line brilliantly captures the core mathematical argument.</p> </li> <li> <p>Goal State (after the <code>have</code> block is complete):</p> <pre><code>m: Plaintext n\nh\u03bc: \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n\u22a2 \u03bcC_M m = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> </li> </ul> </li> <li> <p>Tactic <code>simp [h\u03bc, PMF.uniformOfFintype_apply]</code></p> <ul> <li> <p>What it does: This tactic finishes the proof using the fact <code>h\u03bc</code> we just proved. The <code>simp [h\u03bc]</code> part tells Lean to rewrite the goal using <code>h\u03bc</code>.</p> </li> <li> <p>How it Works: <code>simp</code> sees <code>\u03bcC_M m</code> on the left side of the goal <code>\u22a2</code> and sees the hypothesis <code>h\u03bc</code> which states <code>\u03bcC_M m = ...</code>. It substitutes the left side with the right side of <code>h\u03bc</code>.</p> </li> <li> <p>Goal State (after <code>simp [h\u03bc]</code>):</p> <pre><code>\u22a2 PMF.uniformOfFintype (Ciphertext n) = PMF.uniformOfFintype (Ciphertext n)\n</code></pre> </li> <li> <p>This goal is true by reflexivity, and <code>simp</code> is able to solve it completely. (The extra <code>PMF.uniformOfFintype_apply</code> is not strictly necessary here, as <code>h\u03bc</code> is sufficient, but it doesn't hurt). A more direct way to finish after the <code>have</code> block would simply be <code>exact h\u03bc</code>.</p> </li> </ul> </li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/","title":"Formalizing Discrete Probability in Lean 4: The One-Time Pad","text":""},{"location":"crypto/otp/talk/interleaved_demo_presentation/#fm-crypto-meeting","title":"FM Crypto Meeting","text":""},{"location":"crypto/otp/talk/interleaved_demo_presentation/#overview","title":"Overview","text":"<ul> <li> <p>GOAL</p> <p>Learn how to formalize some basic discrete probability in Lean 4.</p> </li> <li> <p>CASE STUDY</p> <p>Use Lean for formalize the statement and proof of perfect secrecy of the One-Time Pad.</p> </li> <li> <p>KEY CONCEPTS</p> <ul> <li>Probability Mass Functions (PMFs)</li> <li>Independence and joint distributions</li> <li>Conditional probability</li> <li>Bijections preserving uniform distributions</li> </ul> </li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#the-one-time-pad","title":"The One-Time Pad","text":""},{"location":"crypto/otp/talk/interleaved_demo_presentation/#informal-definition","title":"Informal Definition","text":"<ul> <li>Message space: \\(M = \\{0,1\\}^n\\)</li> <li>Key space: \\(K = \\{0,1\\}^n\\)</li> <li>Ciphertext space: \\(C = \\{0,1\\}^n\\)</li> <li>Encryption: \\(\\text{Enc}(m, k) = m \\oplus k\\)</li> <li>Decryption: \\(\\text{Dec}(c, k) = c \\oplus k\\)</li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#key-property","title":"Key Property","text":"\\[\\text{Dec}(\\text{Enc}(m, k), k) = (m \\oplus k) \\oplus k = m\\]"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#lean-4-formalization-types","title":"Lean 4 Formalization: Types","text":"<pre><code>import Mathlib.Data.Vector.Basic\n\ndef Plaintext  (n : Nat) := List.Vector Bool n\ndef Key        (n : Nat) := List.Vector Bool n\ndef Ciphertext (n : Nat) := List.Vector Bool n\n\n-- Element-wise xor\ndef vec_xor {n : Nat} (v\u2081 v\u2082 : List.Vector Bool n) :=\n  map\u2082 xor v\u2081 v\u2082\n\ndef encrypt {n : Nat} (m : Plaintext n) (k : Key n) : Ciphertext n :=\n  vec_xor m k\n</code></pre> Let me show you this in action... <pre><code>-- Demo 1: Basic OTP Operations\nsection BasicOTP\n  open OTP\n\n  -- Create a 4-bit message\n  def demo_msg : Plaintext 4 := \u27e8[true, false, true, true], by decide\u27e9\n  def demo_key : Key 4 := \u27e8[false, true, false, true], by decide\u27e9\n\n  -- Show encryption\n  #eval encrypt demo_msg demo_key\n  -- Output: [true, true, true, false]\n\n  -- Show decryption recovers the message\n  #eval decrypt (encrypt demo_msg demo_key) demo_key\n  -- Output: [true, false, true, true]\n\n  -- Show that different keys give different ciphertexts\n  def demo_key2 : Key 4 := \u27e8[true, true, false, false], by decide\u27e9\n  #eval encrypt demo_msg demo_key2\n  -- Output: [false, true, true, true]\nend BasicOTP\n</code></pre> <p>Key point</p> <p>The same message encrypted with different keys produces different ciphertexts!</p>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#correctness-of-encryptiondecryption","title":"Correctness of Encryption/Decryption","text":"<pre><code>lemma encrypt_decrypt {n : Nat} (m : Plaintext n) (k : Key n) :\n  decrypt (encrypt m k) k = m := by\n  unfold encrypt decrypt vec_xor\n  apply ext  -- vector extensionality\n  intro i    -- prove element-wise\n  simp only [get_map\u2082]\n  -- Goal: xor (xor (get m i) (get k i)) (get k i) = get m i\n  simp  -- Uses xor properties automatically\n</code></pre> <p>Key insight: Reduce vector equality to element-wise boolean equality</p> Let's explore the xor properties that make this work... <pre><code>-- Demo 2: xor Properties\nsection xorProperties\n  open OTP Bool\n\n  -- Interactive proof that xor is self-inverse\n  example (a b : Bool) : xor (xor a b) b = a := by\n    -- Let's explore the proof interactively\n    rw [xor_assoc]\n    -- Goal: xor a (xor b b) = a\n    rw [xor_self]\n    -- Goal: xor a false = a\n    rw [xor_false]\n    -- Done!\n\n  -- Another way using simp\n  example (a b : Bool) : xor (xor a b) b = a := by simp\nend XORProperties\n</code></pre> <p>Teaching moment</p> <p>Lean can automatically find these properties, but stepping through shows us exactly why decryption works!</p>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#probability-mass-functions-in-lean","title":"Probability Mass Functions in Lean","text":""},{"location":"crypto/otp/talk/interleaved_demo_presentation/#mathlibs-pmf-type","title":"Mathlib's PMF type","text":"<pre><code>import Mathlib.Probability.ProbabilityMassFunction.Constructions\n\n-- PMF \u03b1 represents discrete probability distributions over \u03b1\n-- (\u03bc : PMF \u03b1) assigns probability \u03bc a to element a : \u03b1\n</code></pre>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#uniform-distribution-over-keys","title":"Uniform distribution over keys","text":"<pre><code>noncomputable def \u03bcK {n : \u2115} : PMF (Key n) :=\n  uniformOfFintype (Key n)\n\n-- For any key k: \u03bcK k = 1 / 2^n\n</code></pre>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#independence-and-joint-distributions","title":"Independence and Joint Distributions","text":""},{"location":"crypto/otp/talk/interleaved_demo_presentation/#independent-product-of-pmfs","title":"Independent product of PMFs","text":"<pre><code>noncomputable def \u03bcMK {n : \u2115} (\u03bcM : PMF (Plaintext n)) :\n  PMF (Plaintext n \u00d7 Key n) :=\n  PMF.bind \u03bcM (fun m =&gt; PMF.map (fun k =&gt; (m, k)) \u03bcK)\n\n-- P(M = m, K = k) = P(M = m) \u00b7 P(K = k)\n</code></pre>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#ciphertext-distribution","title":"Ciphertext distribution","text":"<pre><code>noncomputable def \u03bcC {n : Nat} (\u03bcM : PMF (Plaintext n)) :\n  PMF (Ciphertext n) :=\n  PMF.bind (\u03bcMK \u03bcM) (fun mk =&gt;\n    PMF.pure (encrypt mk.1 mk.2))\n</code></pre> <p>Lemma (xor is a Bijection)</p> <p>For fixed \\(m\\), the map \\(k \u21a6 m \u2295 k\\) is a bijection!</p> <pre><code>def xorEquiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n where\n  toFun   := encrypt m     -- k \u21a6 m \u2295 k\n  invFun  := vec_xor m     -- c \u21a6 m \u2295 c\n  left_inv := by           -- m \u2295 (m \u2295 k) = k\n    intro k\n    apply ext\n    simp [encrypt, vec_xor, get_map\u2082, xor_aab_eq_b]\n  right_inv := by          -- (m \u2295 c) \u2295 m = c\n    intro c\n    apply ext\n    simp [encrypt, vec_xor, get_map\u2082, xor_aab_eq_b]\n</code></pre> Let me demonstrate why this bijection property is so important... <pre><code>-- Demo 3: Bijection Property\nsection BijectionDemo\n  open OTP\n\n  -- Show that encryption with a fixed message is injective\n  example {n : Nat} (m : Plaintext n) (k\u2081 k\u2082 : Key n)\n    (h : encrypt m k\u2081 = encrypt m k\u2082) : k\u2081 = k\u2082 := by\n    -- Use the bijection property\n    have bij := xorEquiv m\n    -- Apply injectivity\n    exact bij.injective h\n\n  -- Show that for every ciphertext, there's a unique key\n  example {n : Nat} (m : Plaintext n) (c : Ciphertext n) :\n    \u2203! k : Key n, encrypt m k = c := by\n    use vec_xor m c\n    constructor\n    \u00b7 -- Existence\n      simp [encrypt, vec_xor, xor_aab_eq_b]\n    \u00b7 -- Uniqueness\n      intro k hk\n      exact (key_uniqueness m k c).mp hk\nend BijectionDemo\n</code></pre> <p>Key insight</p> <p>This bijection is what guarantees that ciphertexts are uniformly distributed!</p> <p>Lemma (bijections preserve uniform distributions)</p> <pre><code>lemma map_uniformOfFintype_equiv\n    {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2] [DecidableEq \u03b2]\n    [Nonempty \u03b1] [Nonempty \u03b2] (\u03c3 : \u03b1 \u2243 \u03b2) :\n    PMF.map \u03c3 (uniformOfFintype \u03b1) = uniformOfFintype \u03b2\n</code></pre> <p>Intuition</p> <p>Given a uniform distribution on \\(\u03b1\\), if we apply a bijection \\(\u03c3 : \u03b1 \u2192 \u03b2\\), then we get a uniform distribution on \\(\u03b2\\). Crucial point: bijections preserve cardinality!</p> Let's see how this applies to our probability calculations... <pre><code>-- Demo 4: Probability Calculations\nsection ProbabilityDemo\n  open OTP PMF\n\n  -- The probability of any specific 3-bit key is 1/8\n  example : (\u03bcK (n := 3)) \u27e8[true, false, true], by decide\u27e9 = 1/8 := by\n    simp [\u03bcK, uniformOfFintype_apply]\n    -- Lean knows that card (Key 3) = 2^3 = 8\n    norm_num\n\n  -- The conditional probability P(C = c | M = m) is also 1/8\n  example (m : Plaintext 3) (c : Ciphertext 3) :\n    (\u03bcC_M m) c = 1/8 := by\n    rw [C_given_M_eq_inv_card_key]\n    norm_num\nend ProbabilityDemo\n</code></pre> <p>Key Point</p> <p>Both the key distribution and the conditional ciphertext distribution are uniform with the same probability!</p>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#perfect-secrecy-statement","title":"Perfect Secrecy: Statement","text":""},{"location":"crypto/otp/talk/interleaved_demo_presentation/#informal-version","title":"Informal Version","text":"<p>For all messages \\(m\\) and ciphertexts \\(c\\):</p> \\[P(M = m | C = c) = P(M = m)\\] <p>It's easy to see this is equivalent to the assertion that \\(M\\) and \\(C\\) are indenpendent.</p> <p>Independence and Conditional Probability</p> <p>By definition of conditional probability,</p> \\[P(M = m \\;|\\; C = c) \u00b7 P(C = c) = P(M = m, C = c) = P(C = c \\;| \\; M = m) \u00b7 P(M = m).\\] <p>\\(M\\) and \\(C\\) are independent provided</p> \\[P(M = m, C = c) = P(M = m) P(C = c).\\] <p>Therefore, assuming \\(P(C = c) &gt; 0\\) and \\(P(M = m) &gt; 0\\), the following are equivalent:</p> <ol> <li> <p>\\(P(M = m, C = c) = P(M = m) \u00b7 P(C = c)\\)</p> </li> <li> <p>\\(P(M = m \\;| \\; C = c) = P(M = m)\\),</p> </li> <li> <p>\\(P(C = c \\;| \\; M = m) = P(C = c)\\).</p> </li> </ol> <p>We will prove the third assertion.</p>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#proof-strategy","title":"Proof Strategy","text":"<ol> <li>Show conditional distribution is uniform:</li> </ol> <p>\\[P(C = c | M = m) = \\frac{1}{2^n}\\]</p> <ol> <li>Show marginal distribution is uniform:</li> </ol> <p>\\[P(C = c) = \\frac{1}{2^n}\\]</p>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#perfect-secrecy-visualization","title":"Perfect Secrecy Visualization","text":"Perfect secrecy in action with a small example... <pre><code>-- Demo 5: Perfect Secrecy Visualization\nsection PerfectSecrecyDemo\n  open OTP\n\n  -- For a 2-bit OTP, let's verify perfect secrecy manually\n  -- Message: [true, false]\n  -- Key space has 4 elements: [false,false], [false,true], [true,false], [true,true]\n\n  def msg_10 : Plaintext 2 := \u27e8[true, false], by decide\u27e9\n\n  -- Each key gives a different ciphertext:\n  #eval encrypt msg_10 \u27e8[false, false], by decide\u27e9  -- [true, false]\n  #eval encrypt msg_10 \u27e8[false, true], by decide\u27e9   -- [true, true]\n  #eval encrypt msg_10 \u27e8[true, false], by decide\u27e9   -- [false, false]\n  #eval encrypt msg_10 \u27e8[true, true], by decide\u27e9    -- [false, true]\n\n  -- Key insight: Every possible ciphertext appears exactly once!\n  -- This is why the OTP has perfect secrecy.\nend PerfectSecrecyDemo\n</code></pre> <p>Critical observation</p> <p>Each of the 4 possible 2-bit ciphertexts appears exactly once. This uniform mapping is the essence of perfect secrecy!</p>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#common-pitfall-key-reuse","title":"Common Pitfall: Key Reuse","text":"Why you must never reuse a one-time pad key... <pre><code>-- Demo 6: Common Pitfall - Key Reuse\nsection KeyReuse\n  open OTP\n\n  def msg1 : Plaintext 4 := \u27e8[true, false, true, false], by decide\u27e9\n  def msg2 : Plaintext 4 := \u27e8[false, true, false, true], by decide\u27e9\n  def shared_key : Key 4 := \u27e8[true, true, false, false], by decide\u27e9\n\n  def c1 := encrypt msg1 shared_key\n  def c2 := encrypt msg2 shared_key\n\n  -- If an attacker gets both ciphertexts, they can XOR them:\n  #eval vec_xor c1 c2\n  -- This equals vec_xor msg1 msg2 - the key cancels out!\n  #eval vec_xor msg1 msg2\n\n  -- Lesson: NEVER reuse a one-time pad key!\nend KeyReuse\n</code></pre> <p>Security lesson</p> <p>If we xor two ciphertexts encrypted with the same key, the key cancels out, leaving \\(m_1 \u2295 m_2\\). This leaks information about the messages!</p>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#summary-and-lessons-learned","title":"Summary and Lessons Learned","text":""},{"location":"crypto/otp/talk/interleaved_demo_presentation/#1-type-classes-matter","title":"1. Type Classes Matter","text":"<ul> <li><code>Fintype</code> for finite types</li> <li><code>Nonempty</code> to avoid division by zero</li> <li><code>DecidableEq</code> for computability</li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#2-bijections-are-powerful","title":"2. Bijections are Powerful","text":"<ul> <li>xor with fixed value is a bijection</li> <li>Bijections preserve uniform distributions</li> <li>Can transform complex sums using bijections</li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#3-pmf-library-is-well-designed","title":"3. PMF Library is Well-Designed","text":"<ul> <li><code>bind</code> for dependent distributions</li> <li><code>map</code> for transforming distributions</li> <li>Uniform distributions built-in</li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#summary-and-lessons-learned_1","title":"Summary and Lessons Learned","text":"<ol> <li> <p>What \u03bcC represents</p> <p>The distribution of ciphertexts when we:</p> <ul> <li>sample a message <code>m</code> from <code>\u03bcM</code></li> <li>sample a key <code>k</code> uniformly from all <code>2\u207f</code> keys</li> <li>output <code>encrypt m k</code></li> </ul> </li> <li> <p>Why it's uniform</p> <ul> <li>for each <code>m</code>, the map <code>k \u21a6 m \u2295 k</code> is a bijection</li> <li>so each ciphertext <code>c</code> appears exactly once for each <code>m</code></li> <li>since keys are uniform, each <code>c</code> has probability <code>1/2\u207f</code></li> </ul> </li> <li> <p>Perfect secrecy: P(C = c | M = m) = 1/2\u207f = P(C = c)</p> <ul> <li>OTP achieves perfect secrecy because xor is a bijection</li> <li>so both conditional and marginal distributions of ciphertexts are uniform</li> <li>this is precisely independence between message and ciphertext.</li> </ul> </li> </ol>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#challenges-in-formalization","title":"Challenges in Formalization","text":""},{"location":"crypto/otp/talk/interleaved_demo_presentation/#1-vector-equality","title":"1. Vector Equality","text":"<ul> <li>Must use extensionality (<code>ext</code>)</li> <li>Reduce to element-wise proofs</li> <li><code>simp</code> is very helpful with <code>get_map\u2082</code></li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#2-infinite-sums","title":"2. Infinite Sums","text":"<ul> <li><code>tsum</code> requires careful manipulation</li> <li>Product types need <code>tsum_prod'</code></li> <li>Conditional sums use <code>tsum_ite_eq</code></li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#3-real-number-arithmetic","title":"3. Real Number Arithmetic","text":"<ul> <li>Coercion between <code>Nat</code>, <code>NNReal</code>, <code>ENNReal</code></li> <li>Division requires non-zero denominators</li> <li>Must track when values are finite</li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#future-directions","title":"Future Directions","text":""},{"location":"crypto/otp/talk/interleaved_demo_presentation/#extensions","title":"Extensions","text":"<ol> <li> <p>Other Cryptographic Constructions</p> <ul> <li>Stream ciphers</li> <li>Block ciphers (with appropriate modes)</li> <li>Public key encryption</li> </ul> </li> <li> <p>Advanced Probability</p> <ul> <li>Computational indistinguishability</li> <li>Negligible functions</li> <li>Probabilistic polynomial time</li> </ul> </li> <li> <p>Security Proofs</p> <ul> <li>Semantic security</li> <li>CPA/CCA security</li> <li>Reduction proofs</li> </ul> </li> </ol>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#takeaways","title":"Takeaways","text":"<ul> <li>Lean + Mathlib provides excellent support for probability</li> <li>Type-driven development helps catch errors early</li> <li>Bijections are a key tool in cryptographic proofs</li> <li>Perfect secrecy is elegantly expressible and provable</li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#resources","title":"Resources","text":"<ul> <li>Slides https://formalmethods.io/crypto</li> <li> <p>Code https://github.com/formalverification/lean4crypto/</p> </li> <li> <p>Lean https://lean-lang.org/</p> </li> <li>Mathlib docs https://leanprover-community.github.io/mathlib4_docs/</li> <li>Mathlib source https://github.com/leanprover-community/mathlib4</li> </ul>"},{"location":"crypto/otp/talk/interleaved_demo_presentation/#questions","title":"Questions?","text":""},{"location":"crypto/otp/talk/interleaved_demo_presentation/#quick-reference","title":"Quick Reference","text":"<ul> <li><code>PMF \u03b1</code> - Probability mass function over type <code>\u03b1</code></li> <li><code>uniformOfFintype</code> - Uniform distribution</li> <li><code>List.Vector</code> - Fixed-length vectors</li> <li><code>ENNReal</code> - Extended non-negative reals</li> <li><code>\u2243</code> - Type equivalence (bijection)</li> </ul> <p>Thank you!</p>"},{"location":"crypto/otp/talk/slides/","title":"Formalizing Discrete Probability in Lean 4: The One-Time Pad","text":""},{"location":"crypto/otp/talk/slides/#fm-crypto-meeting","title":"FM Crypto Meeting","text":""},{"location":"crypto/otp/talk/slides/#overview","title":"Overview","text":"<ul> <li>\ud83e\udd45 Goal: Formalize basic discrete probability in Lean 4</li> <li>\ud83d\uddc4\ufe0f Case Study: One-Time Pad (OTP) and Perfect Secrecy</li> <li>\ud83d\udd11\ufe0f Key Concepts:</li> <li>Probability Mass Functions (PMFs)</li> <li>Independence and joint distributions</li> <li>Conditional probability</li> <li>Bijections preserving uniform distributions</li> </ul>"},{"location":"crypto/otp/talk/slides/#the-one-time-pad","title":"The One-Time Pad","text":""},{"location":"crypto/otp/talk/slides/#informal-definition","title":"Informal Definition","text":"<ul> <li>Message space: \\(M = \\{0,1\\}^n\\)</li> <li>Key space: \\(K = \\{0,1\\}^n\\)</li> <li>Ciphertext space: \\(C = \\{0,1\\}^n\\)</li> <li>Encryption: \\(\\text{Enc}(m, k) = m \\oplus k\\)</li> <li>Decryption: \\(\\text{Dec}(c, k) = c \\oplus k\\)</li> </ul>"},{"location":"crypto/otp/talk/slides/#key-property","title":"Key Property","text":"\\[\\text{Dec}(\\text{Enc}(m, k), k) = (m \\oplus k) \\oplus k = m\\]"},{"location":"crypto/otp/talk/slides/#lean-4-formalization-types","title":"Lean 4 Formalization: Types","text":"<pre><code>import Mathlib.Data.Vector.Basic\n\ndef Plaintext  (n : Nat) := List.Vector Bool n\ndef Key        (n : Nat) := List.Vector Bool n\ndef Ciphertext (n : Nat) := List.Vector Bool n\n\n-- Element-wise XOR\ndef vec_xor {n : Nat} (v\u2081 v\u2082 : List.Vector Bool n) :=\n  map\u2082 xor v\u2081 v\u2082\n\ndef encrypt {n : Nat} (m : Plaintext n) (k : Key n) : Ciphertext n :=\n  vec_xor m k\n</code></pre>"},{"location":"crypto/otp/talk/slides/#correctness-of-encryptiondecryption","title":"Correctness of Encryption/Decryption","text":"<pre><code>lemma encrypt_decrypt {n : Nat} (m : Plaintext n) (k : Key n) :\n  decrypt (encrypt m k) k = m := by\n  unfold encrypt decrypt vec_xor\n  apply ext  -- vector extensionality\n  intro i    -- prove element-wise\n  simp only [get_map\u2082]\n  -- Goal: xor (xor (get m i) (get k i)) (get k i) = get m i\n  simp  -- Uses xor properties automatically\n</code></pre> <p>Key insight: Reduce vector equality to element-wise boolean equality</p>"},{"location":"crypto/otp/talk/slides/#probability-mass-functions-in-lean-4","title":"Probability Mass Functions in Lean 4","text":""},{"location":"crypto/otp/talk/slides/#mathlibs-pmf-type","title":"Mathlib's PMF type","text":"<pre><code>import Mathlib.Probability.ProbabilityMassFunction.Constructions\n\n-- PMF \u03b1 represents discrete probability distributions over \u03b1\n-- (\u03bc : PMF \u03b1) assigns probability \u03bc a to element a : \u03b1\n</code></pre>"},{"location":"crypto/otp/talk/slides/#uniform-distribution-over-keys","title":"Uniform distribution over keys","text":"<pre><code>noncomputable def \u03bcK {n : \u2115} : PMF (Key n) :=\n  uniformOfFintype (Key n)\n\n-- For any key k: \u03bcK k = 1 / 2^n\n</code></pre>"},{"location":"crypto/otp/talk/slides/#independence-and-joint-distributions","title":"Independence and Joint Distributions","text":""},{"location":"crypto/otp/talk/slides/#independent-product-of-pmfs","title":"Independent product of PMFs","text":"<pre><code>noncomputable def \u03bcMK {n : \u2115} (\u03bcM : PMF (Plaintext n)) :\n  PMF (Plaintext n \u00d7 Key n) :=\n  PMF.bind \u03bcM (fun m =&gt; PMF.map (fun k =&gt; (m, k)) \u03bcK)\n\n-- P(M = m, K = k) = P(M = m) \u00b7 P(K = k)\n</code></pre>"},{"location":"crypto/otp/talk/slides/#ciphertext-distribution","title":"Ciphertext distribution","text":"<pre><code>noncomputable def \u03bcC {n : Nat} (\u03bcM : PMF (Plaintext n)) :\n  PMF (Ciphertext n) :=\n  PMF.bind (\u03bcMK \u03bcM) (fun mk =&gt;\n    PMF.pure (encrypt mk.1 mk.2))\n</code></pre>"},{"location":"crypto/otp/talk/slides/#key-lemma-1-xor-is-a-bijection","title":"Key Lemma 1: XOR is a Bijection","text":"<pre><code>def xorEquiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n where\n  toFun   := encrypt m     -- k \u21a6 m \u2295 k\n  invFun  := vec_xor m     -- c \u21a6 m \u2295 c\n  left_inv := by           -- m \u2295 (m \u2295 k) = k\n    intro k\n    apply ext\n    simp [encrypt, vec_xor, get_map\u2082, xor_aab_eq_b]\n  right_inv := by          -- (m \u2295 c) \u2295 m = c\n    intro c\n    apply ext\n    simp [encrypt, vec_xor, get_map\u2082, xor_aab_eq_b]\n</code></pre> <p>For fixed \\(m\\), the map \\(k \\mapsto m \\oplus k\\) is a bijection!</p>"},{"location":"crypto/otp/talk/slides/#key-lemma-2-bijections-preserve-uniform-distributions","title":"Key Lemma 2: Bijections Preserve Uniform Distributions","text":"<pre><code>lemma map_uniformOfFintype_equiv\n    {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2] [DecidableEq \u03b2]\n    [Nonempty \u03b1] [Nonempty \u03b2] (e : \u03b1 \u2243 \u03b2) :\n    PMF.map e (uniformOfFintype \u03b1) = uniformOfFintype \u03b2\n</code></pre>"},{"location":"crypto/otp/talk/slides/#intuition","title":"Intuition","text":"<ul> <li>If we have a uniform distribution on \\(\\alpha\\)</li> <li>And apply a bijection \\(e : \\alpha \\to \\beta\\)</li> <li>We get a uniform distribution on \\(\\beta\\)</li> <li>Crucial: bijections preserve cardinality!</li> </ul>"},{"location":"crypto/otp/talk/slides/#perfect-secrecy-statement","title":"Perfect Secrecy: Statement","text":""},{"location":"crypto/otp/talk/slides/#informal-version","title":"Informal Version","text":"<p>For all messages \\(m\\) and ciphertexts \\(c\\):</p> \\[P(M = m \\; | \\; C = c) = P(M = m)\\]"},{"location":"crypto/otp/talk/slides/#lean-4-version","title":"Lean 4 Version","text":"<pre><code>theorem perfect_secrecy {n : Nat} (\u03bcM : PMF (Plaintext n))\n  (m\u2080 : Plaintext n) (c\u2080 : Ciphertext n) :\n  (\u03bcC_M m\u2080) c\u2080 * \u03bcM m\u2080 / (\u03bcC \u03bcM) c\u2080 = \u03bcM m\u2080\n</code></pre> <p>Where:</p> <ul> <li><code>\u03bcC_M m\u2080</code> is the conditional distribution \\(P(C \\; | \\; M = m_0)\\)</li> <li><code>\u03bcC \u03bcM</code> is the marginal distribution \\(P(C)\\)</li> </ul>"},{"location":"crypto/otp/talk/slides/#proof-strategy","title":"Proof Strategy","text":"<ol> <li> <p>Show conditional distribution is uniform:</p> \\[P(C = c \\; | \\; M = m) = 2^{-n}\\] </li> <li> <p>Show marginal distribution is uniform:</p> \\[P(C = c) = 2^{-n}\\] </li> <li> <p>Apply Bayes' theorem:</p> \\[\\begin{align*} P(M = m | C = c) =&amp; \\frac{P(C = c \\; | \\; M = m) \u00b7 P(M = m)}{P(C = c)}\\\\[8pt] &amp;= \\frac{2^{-n} \u00b7 P(M = m)}{2^{-n}}\\\\[8pt] &amp;= P(M = m) \\end{align*}\\] </li> </ol>"},{"location":"crypto/otp/talk/slides/#step-1-conditional-distribution-is-uniform","title":"Step 1: Conditional Distribution is Uniform","text":"<pre><code>lemma C_given_M_eq_inv_card_key {n : \u2115}\n  (m : Plaintext n) (c : Ciphertext n) :\n  (\u03bcC_M m) c = 1 / card (Key n) := by\n  -- \u03bcC_M m = map (encrypt m) \u03bcK\n  -- encrypt m is a bijection (xorEquiv m)\n  -- So map (encrypt m) \u03bcK = uniformOfFintype (Ciphertext n)\n  have h\u03bc : \u03bcC_M m = uniformOfFintype (Ciphertext n) := by\n    apply map_uniformOfFintype_equiv (xorEquiv m)\n  simpa [h\u03bc, uniformOfFintype_apply]\n    using card_congr (xorEquiv m)\n</code></pre>"},{"location":"crypto/otp/talk/slides/#step-2-marginal-distribution-is-uniform","title":"Step 2: Marginal Distribution is Uniform","text":"<pre><code>lemma prob_C_uniform_ennreal {n : Nat} (\u03bcM : PMF (Plaintext n))\n  (c : Ciphertext n) :\n  (\u03bcC \u03bcM) c = (card (Key n) : ENNReal)\u207b\u00b9\n</code></pre>"},{"location":"crypto/otp/talk/slides/#key-insight","title":"Key insight:","text":"<ul> <li>For each \\(m\\), there's exactly one \\(k\\) such that \\(m \\oplus k = c\\)</li> <li>Namely, \\(k = m \\oplus c\\)</li> <li>So we can rewrite the sum over \\((m,k)\\) pairs as a sum over \\(m\\) alone</li> </ul>"},{"location":"crypto/otp/talk/slides/#working-with-ennreal","title":"Working with ENNReal","text":""},{"location":"crypto/otp/talk/slides/#challenge-division-in-probability","title":"Challenge: Division in probability","text":"<ul> <li>PMFs use <code>NNReal</code> (non-negative reals)</li> <li>Division requires <code>ENNReal</code> (extended non-negative reals)</li> <li>Need to handle \\(0\\) and \\(\\infty\\) carefully</li> </ul>"},{"location":"crypto/otp/talk/slides/#key-properties-used","title":"Key properties used:","text":"<pre><code>-- For x \u2260 0 and x \u2260 \u221e:\nx * y / x = y\n\n-- Uniform distribution has probability 1/|S|\n(uniformOfFintype S) s = (card S)\u207b\u00b9\n</code></pre>"},{"location":"crypto/otp/talk/slides/#lessons-learned","title":"Lessons Learned","text":""},{"location":"crypto/otp/talk/slides/#1-type-classes-matter","title":"1. Type Classes Matter","text":"<ul> <li><code>Fintype</code> for finite types</li> <li><code>Nonempty</code> to avoid division by zero</li> <li><code>DecidableEq</code> for computability</li> </ul>"},{"location":"crypto/otp/talk/slides/#2-bijections-are-powerful","title":"2. Bijections are Powerful","text":"<ul> <li>XOR with fixed value is a bijection</li> <li>Bijections preserve uniform distributions</li> <li>Can transform complex sums using bijections</li> </ul>"},{"location":"crypto/otp/talk/slides/#3-pmf-library-is-well-designed","title":"3. PMF Library is Well-Designed","text":"<ul> <li><code>bind</code> for dependent distributions</li> <li><code>map</code> for transforming distributions</li> <li>Uniform distributions built-in</li> </ul>"},{"location":"crypto/otp/talk/slides/#challenges-in-formalization","title":"Challenges in Formalization","text":""},{"location":"crypto/otp/talk/slides/#1-vector-equality","title":"1. Vector Equality","text":"<ul> <li>Must use extensionality (<code>ext</code>)</li> <li>Reduce to element-wise proofs</li> <li><code>simp</code> is very helpful with <code>get_map\u2082</code></li> </ul>"},{"location":"crypto/otp/talk/slides/#2-infinite-sums","title":"2. Infinite Sums","text":"<ul> <li><code>tsum</code> requires careful manipulation</li> <li>Product types need <code>tsum_prod'</code></li> <li>Conditional sums use <code>tsum_ite_eq</code></li> </ul>"},{"location":"crypto/otp/talk/slides/#3-real-number-arithmetic","title":"3. Real Number Arithmetic","text":"<ul> <li>Coercion between <code>Nat</code>, <code>NNReal</code>, <code>ENNReal</code></li> <li>Division requires non-zero denominators</li> <li>Must track when values are finite</li> </ul>"},{"location":"crypto/otp/talk/slides/#demo-interactive-proof-development","title":"Demo: Interactive Proof Development","text":"<p>Let's see how Lean 4's tactics work in practice:</p> <pre><code>example {n : Nat} (m : Plaintext n) (k : Key n) :\n  encrypt m k = encrypt m k := by\n  -- Lean's proof state shows current goal\n  rfl  -- reflexivity\n\nexample {n : Nat} (m : Plaintext n) (k\u2081 k\u2082 : Key n)\n  (h : encrypt m k\u2081 = encrypt m k\u2082) : k\u2081 = k\u2082 := by\n  -- Use key uniqueness\n  have h_unique := key_uniqueness m k\u2081 (encrypt m k\u2082)\n  rw [h_unique.mp h]\n  -- Alternative: use xorEquiv directly\n</code></pre>"},{"location":"crypto/otp/talk/slides/#future-directions","title":"Future Directions","text":""},{"location":"crypto/otp/talk/slides/#extensions","title":"Extensions","text":"<ol> <li> <p>Other Cryptographic Constructions</p> <ul> <li>Stream ciphers</li> <li>Block ciphers (with appropriate modes)</li> <li>Public key encryption</li> </ul> </li> <li> <p>Advanced Probability</p> <ul> <li>Computational indistinguishability</li> <li>Negligible functions</li> <li>Probabilistic polynomial time</li> </ul> </li> <li> <p>Security Proofs</p> <ul> <li>Semantic security</li> <li>CPA/CCA security</li> <li>Reduction proofs</li> </ul> </li> </ol>"},{"location":"crypto/otp/talk/slides/#takeaways","title":"Takeaways","text":"<ul> <li>Lean 4 + Mathlib provides excellent support for probability</li> <li>Type-driven development helps catch errors early</li> <li>Bijections are a key tool in cryptographic proofs</li> <li>Perfect secrecy is elegantly expressible and provable</li> </ul>"},{"location":"crypto/otp/talk/slides/#resources","title":"Resources","text":"<ul> <li>Slides https://formalmethods.io/crypto</li> <li> <p>Code https://github.com/formalverification/lean4crypto/</p> </li> <li> <p>Lean https://lean-lang.org/</p> </li> <li>Mathlib docs https://leanprover-community.github.io/mathlib4_docs/</li> <li>Mathlib source https://github.com/leanprover-community/mathlib4</li> </ul>"},{"location":"crypto/otp/talk/slides/#questions","title":"Questions?","text":""},{"location":"crypto/otp/talk/slides/#quick-reference","title":"Quick Reference","text":"<ul> <li><code>PMF \u03b1</code> - Probability mass function over type <code>\u03b1</code></li> <li><code>uniformOfFintype</code> - Uniform distribution</li> <li><code>List.Vector</code> - Fixed-length vectors</li> <li><code>ENNReal</code> - Extended non-negative reals</li> <li><code>\u2243</code> - Type equivalence (bijection)</li> </ul> <p>Thank you!</p>"},{"location":"mkdocs/admonitions/","title":"Admonitions","text":"<p>From the markdown...</p> <p><pre><code>!!! note \"Title of the callout\"\n\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n    nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n    massa, nec semper lorem quam in massa.\n</code></pre> ...MkDocs produces:</p> <p>Title of the callout</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"mkdocs/admonitions/#collapsible-callouts","title":"Collapsible callouts","text":"<p>From the markdown... </p> <pre><code>??? info \"Collapsible callout\"\n\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n    nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n    massa, nec semper lorem quam in massa.\n</code></pre> <p>... MkDocs produces:</p> Collapsible callout <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"mkdocs/code-blocks/","title":"Code blocks","text":"<pre><code>    ```py title=\"add_numbers.py\" linenums=\"1\" hl_lines=\"2-4\"\n    # Function to add two numbers\n    def add_two_numbers(num1, num2):\n        return num1 + num2\n\n    # Example usage\n    result = add_two_numbers(5, 3)\n    print('The sum is:', result)\n    ```\n</code></pre> <p>produces</p> add_numbers.py<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre>"},{"location":"mkdocs/content-tabs/","title":"Content tabs","text":""},{"location":"mkdocs/content-tabs/#generic-content","title":"Generic Content","text":"<p>From the markdown...</p> <pre><code>=== \"Plain text\"\n\n    This is some plain text\n\n=== \"Unordered list\"\n\n    * First item\n    * Second item\n    * Third item\n\n=== \"Ordered list\"\n\n    1. First item\n    2. Second item\n    3. Third item\n</code></pre> <p>...MkDocs produces</p> Plain textUnordered listOrdered list <p>This is some plain text</p> <ul> <li>First item</li> <li>Second item</li> <li>Third item</li> </ul> <ol> <li>First item</li> <li>Second item</li> <li>Third item</li> </ol>"},{"location":"mkdocs/content-tabs/#code-blocks-in-content-tabs","title":"Code Blocks in Content Tabs","text":"<p>From the markdown...</p> <pre><code>=== \"Python\"\n\n    ```py\n    def main():\n        print(\"Hello world!\")\n\n    if __name__ == \"__main__\":\n        main()\n    ```\n\n=== \"JavaScript\"\n\n    ```js\n    function main() {\n        console.log(\"Hello world!\");\n    }\n\n    main();\n    ```\n</code></pre> <p>...MkDocs produces</p> PythonJavaScript <pre><code>def main():\n    print(\"Hello world!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>function main() {\n    console.log(\"Hello world!\");\n}\n\nmain();\n</code></pre>"},{"location":"mkdocs/diagrams/","title":"Diagram Examples","text":""},{"location":"mkdocs/diagrams/#flowcharts","title":"Flowcharts","text":"<p>From the markdown...</p> <pre><code>    ```mermaid\n    graph LR\n      A[Start] --&gt; B{Failure?};\n      B --&gt;|Yes| C[Investigate...];\n      C --&gt; D[Debug];\n      D --&gt; B;\n      B ----&gt;|No| E[Success!];\n    ```\n</code></pre> <p>...MkDocs produces</p> <pre><code>graph LR\n  A[Start] --&gt; B{Failure?};\n  B --&gt;|Yes| C[Investigate...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Success!];</code></pre>"},{"location":"mkdocs/diagrams/#sequence-diagrams","title":"Sequence Diagrams","text":"<p>From the markdown...</p> <p><pre><code>    ```mermaid\n    sequenceDiagram\n      autonumber\n      Server-&gt;&gt;Terminal: Send request\n      loop Health\n          Terminal-&gt;&gt;Terminal: Check for health\n      end\n      Note right of Terminal: System online\n      Terminal--&gt;&gt;Server: Everything is OK\n      Terminal-&gt;&gt;Database: Request customer data\n      Database--&gt;&gt;Terminal: Customer data\n    ```\n</code></pre> ...MkDocs produces</p> <pre><code>sequenceDiagram\n  autonumber\n  Server-&gt;&gt;Terminal: Send request\n  loop Health\n      Terminal-&gt;&gt;Terminal: Check for health\n  end\n  Note right of Terminal: System online\n  Terminal--&gt;&gt;Server: Everything is OK\n  Terminal-&gt;&gt;Database: Request customer data\n  Database--&gt;&gt;Terminal: Customer data</code></pre>"}]}