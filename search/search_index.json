{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Formal Methods","text":""},{"location":"contributors/","title":"Contributors","text":"<p>William DeMeo</p> <p>If you have contributed to the contents of this site and you're not mention here, please contact williamdemeo at gmail or create a new issue  in the formalmethods.io GitHub repository.</p>"},{"location":"license/","title":"License","text":"<p>formalmethods.io \u00a9 2025 by William DeMeo is licensed under CC BY-NC-SA 4.0</p>"},{"location":"mkdocs/","title":"MkDocs","text":""},{"location":"mkdocs/#references","title":"References","text":"<ul> <li>MkDocs</li> <li>MkDocs Material</li> <li>Getting Started with Material for MkDocs, by James Willet.</li> </ul>"},{"location":"cardano-ledger/intro/","title":"Introduction","text":"<p>This document is a formal specification of the functionality of the ledger on the Cardano blockchain. This includes the blockchain layer determining what is a valid block, but does not include any concurrency issues such as chain selection. The details of the background and the larger context for the design decisions formalized in this document are presented in Appendix Section\u00a0shelley-delegation-design.</p> <p>In this document, we present the most important properties that any implementation of the ledger must have. Specifically, we model the following aspects of the functionality of the ledger on the blockchain:</p> <p>In defining Cardano, we are concerned with the means to construct inductive datatypes satisfying some validity conditions. For example, we wish to consider when a sequence of transactions forms a valid ledger, or a sequence of blocks forms a valid chain.</p> <p>This document describes the methods we use to define such validity conditions and how they result in the construction of valid states. In particular, we define inference rules for operations on a blockchain as a specification of the blockchain layer of Cardano. A block validity definition is given, which is accompanied by small-step operational semantics inference rules.</p> <p>The idea behind this document is to formalise what it means for a new block, to be added to the blockchain, to be valid. Unless a new block is valid, it cannot be added to the blockchain and thereby extend it. This is needed for a system that is subscribed to the blockchain and keeps a copy of it locally.</p> <p>Each block is made up of transactions and this specification models the conditions that the different parts of a transaction must fulfill so that they can extend a ledger, which is represented here as a list of transactions. In particular, we model the following aspects:</p> <p>Preservation of value</p> <p>:   relationship between the total value of input and outputs in a new     transaction, and the unspent outputs.</p> <p>Witnesses</p> <p>:   authentication of parts of the transaction data by means of     cryptographic entities (such as signatures and private keys)     contained in these transactions.</p> <p>Delegation</p> <p>:   validity of delegation certificates, which delegate block-signing     rights.</p> <p>Update validation</p> <p>:   voting mechanism which captures the identification of the voters,     and the participants that can post update proposals.</p> <p>Stake</p> <p>:   staking rights associated to an addresses.</p> <pre><code>&lt;!-- --&gt;\n</code></pre> <p>Preservation of value</p> <p>:   Every coin in the system must be accounted for, and the total amount     is unchanged by every transaction and epoch change. In particular,     every coin is accounted for by exactly one of the following     categories:</p> <pre><code>-   Circulation (UTxO)\n\n-   Deposit pot\n\n-   Fee pot\n\n-   Reserves (monetary expansion)\n\n-   Rewards (account addresses)\n\n-   Treasury\n</code></pre> <p>Witnesses</p> <p>:   Authentication of parts of the transaction data by means of     cryptographic entities (such as signatures and private keys)     contained in these transactions.</p> <p>Delegation</p> <p>:   Validity of delegation certificates, which delegate block-signing     rights.</p> <p>Stake</p> <p>:   Staking rights associated to an address.</p> <p>Rewards</p> <p>:   Reward calculation and distribution.</p> <p>Updates</p> <p>:   The update mechanism for Shelley protocol parameters and software.</p> <p>While the blockchain protocol is a reactive system that is driven by the arrival of blocks causing updates to the ledger, the formal description is a collection of rules that compose a static description of what a valid ledger is. A valid ledger state can only be reached by applying a sequence of inference rules and any valid ledger state is reachable by applying some sequence of these rules. The specifics of the semantics we use to define and apply the rules we present in this document are explained in detail in [@small-step-semantics] (this document will really help the reader's understanding of the contents of this specification).</p> <p>The structure of the rules that we give here is such that their application is deterministic. That is, given a specific initial state and relevant environmental constants, there is no ambiguity about which rule should be applied at any given time (i.e.\u00a0which state transition is allowed to take place). This property ensures that the specification is totally precise --- no choice is left to the implementor and any two implementations must behave the same when it comes to deciding whether a block is valid.</p>"},{"location":"cardano-ledger/shelley/intro/","title":"Intro","text":"<p>This document is a formal specification of the functionality of the ledger on the blockchain. This includes the blockchain layer determining what is a valid block, but does not include any concurrency issues such as chain selection. The details of the background and the larger context for the design decisions formalized in this document are presented in\u00a0[@shelley-delegation-design].</p> <p>In this document, we present the most important properties that any implementation of the ledger must have. Specifically, we model the following aspects of the functionality of the ledger on the blockchain:</p> <p>Preservation of value</p> <p>:   Every coin in the system must be accounted for, and the total amount     is unchanged by every transaction and epoch change. In particular,     every coin is accounted for by exactly one of the following     categories:</p> <pre><code>-   Circulation (UTxO)\n\n-   Deposit pot\n\n-   Fee pot\n\n-   Reserves (monetary expansion)\n\n-   Rewards (account addresses)\n\n-   Treasury\n</code></pre> <p>Witnesses</p> <p>:   Authentication of parts of the transaction data by means of     cryptographic entities (such as signatures and private keys)     contained in these transactions.</p> <p>Delegation</p> <p>:   Validity of delegation certificates, which delegate block-signing     rights.</p> <p>Stake</p> <p>:   Staking rights associated to an address.</p> <p>Rewards</p> <p>:   Reward calculation and distribution.</p> <p>Updates</p> <p>:   The update mechanism for Shelley protocol parameters and software.</p> <p>While the blockchain protocol is a reactive system that is driven by the arrival of blocks causing updates to the ledger, the formal description is a collection of rules that compose a static description of what a valid ledger is. A valid ledger state can only be reached by applying a sequence of inference rules and any valid ledger state is reachable by applying some sequence of these rules. The specifics of the semantics we use to define and apply the rules we present in this document are explained in detail in [@small-step-semantics] (this document will really help the reader's understanding of the contents of this specification).</p> <p>The structure of the rules that we give here is such that their application is deterministic. That is, given a specific initial state and relevant environmental constants, there is no ambiguity about which rule should be applied at any given time (i.e.\u00a0which state transition is allowed to take place). This property ensures that the specification is totally precise --- no choice is left to the implementor and any two implementations must behave the same when it comes to deciding whether a block is valid.</p>"},{"location":"crypto/","title":"FM Crypto","text":"<ul> <li>Formalizing the One-time Pad in Lean</li> </ul>"},{"location":"crypto/Mathlib/DistributionsInLean/","title":"Deep Dive: How Lean Represents Probability Distributions","text":""},{"location":"crypto/Mathlib/DistributionsInLean/#what-is-a-pmf-really","title":"What is a PMF Really?","text":"<p>In Lean/Mathlib, a <code>PMF \u03b1</code> (Probability Mass Function) is fundamentally:</p> <pre><code>/-- A probability mass function, or discrete probability measures is\n  a function `\u03b1 \u2192 \u211d\u22650\u221e` such that the values have (infinite) sum `1`. -/\n\ndef PMF.{u} (\u03b1 : Type u) : Type u :=\n  { f : \u03b1 \u2192 \u211d\u22650\u221e // HasSum f 1 }\n</code></pre> <p>So a PMF is a pair</p> <ol> <li> <p>A function assigning probabilities to outcomes.</p> </li> <li> <p>A proof that these probabilities form a valid distribution.</p> </li> </ol>"},{"location":"crypto/Mathlib/DistributionsInLean/#our-distributions-as-mathematical-objects","title":"Our Distributions as Mathematical Objects","text":""},{"location":"crypto/Mathlib/DistributionsInLean/#m-pmf-plaintext-n","title":"\u03bcM : PMF (Plaintext n)","text":"<ul> <li>Type: A function <code>Plaintext n \u2192 \u211d\u22650\u221e</code> (plus a proof).</li> <li>Meaning: For any n-bit message m, <code>\u03bcM m</code> is the probability that message m is sent.</li> <li>Example: If all messages equally likely, <code>\u03bcM m = 1/2^n</code> for all m.</li> </ul>"},{"location":"crypto/Mathlib/DistributionsInLean/#k-pmf-key-n","title":"\u03bcK : PMF (Key n)","text":"<ul> <li>Type: A function <code>Key n \u2192 \u211d\u22650\u221e</code></li> <li>Meaning: For any n-bit key k, <code>\u03bcK k</code> is its probability</li> <li>Definition: <code>uniformOfFintype</code> makes <code>\u03bcK k = 1/2^n</code> for all k</li> </ul>"},{"location":"crypto/Mathlib/DistributionsInLean/#mk-pmf-plaintext-n-key-n","title":"\u03bcMK : PMF (Plaintext n \u00d7 Key n)","text":"<ul> <li>Type: A function <code>(Plaintext n \u00d7 Key n) \u2192 \u211d\u22650\u221e</code></li> <li>Meaning: Joint probability P(M = m \u2227 K = k)</li> <li>Value: <code>\u03bcMK (m,k) = \u03bcM m * \u03bcK k</code> (independence!)</li> </ul>"},{"location":"crypto/Mathlib/DistributionsInLean/#c-pmf-ciphertext-n","title":"\u03bcC : PMF (Ciphertext n)","text":"<ul> <li>Type: A function <code>Ciphertext n \u2192 \u211d\u22650\u221e</code></li> <li>Meaning: For any n-bit ciphertext c, <code>\u03bcC c</code> is probability of observing c</li> <li>Computed: By summing over all (m,k) pairs that produce c</li> </ul>"},{"location":"crypto/Mathlib/DistributionsInLean/#c_m-plaintext-n-pmf-ciphertext-n","title":"\u03bcC_M : Plaintext n \u2192 PMF (Ciphertext n)","text":"<ul> <li>Type: A function that takes a message and returns a distribution</li> <li>Meaning: For fixed m, <code>\u03bcC_M m</code> is the conditional distribution P(C | M = m)</li> <li>Value: <code>(\u03bcC_M m) c = if \u2203k. encrypt m k = c then 1/2^n else 0</code></li> </ul>"},{"location":"crypto/Mathlib/DistributionsInLean/#why-noncomputable","title":"Why <code>noncomputable</code>?","text":"<p>This is subtle! Even though we're dealing with finite types, these definitions are <code>noncomputable</code> because:</p>"},{"location":"crypto/Mathlib/DistributionsInLean/#1-real-number-arithmetic","title":"1. Real Number Arithmetic","text":"<pre><code>noncomputable def \u03bcK {n : \u2115} : PMF (Key n) := uniformOfFintype (Key n)\n</code></pre> <p>The probability values are in <code>\u211d\u22650\u221e</code> (extended non-negative reals), not rationals:</p> <ul> <li><code>1/2\u207f</code> is computed as real division, not rational division</li> <li>Real arithmetic is inherently noncomputable in constructive mathematics</li> <li>Even though we \"know\" the answer is rational, the type system uses reals</li> </ul>"},{"location":"crypto/Mathlib/DistributionsInLean/#2-infinite-summations","title":"2. Infinite Summations","text":"<p>Even for finite types, PMF uses infinite summation machinery:</p> <pre><code>\u2211' a : \u03b1, p a  -- This is an infinite sum operator\n</code></pre> <ul> <li>The <code>\u2211'</code> notation works for both finite and infinite types.</li> <li>It's defined using limits and topology.</li> <li>Even when <code>\u03b1</code> is finite, we use the general machinery.</li> </ul>"},{"location":"crypto/Mathlib/DistributionsInLean/#3-classical-logic","title":"3. Classical Logic","text":"<p>PMF operations often use classical logic (excluded middle):</p> <pre><code>open Classical  -- Needed for many probability operations\n</code></pre> <p>This makes things noncomputable in Lean's constructive logic.</p>"},{"location":"crypto/Mathlib/DistributionsInLean/#why-can-we-still-prove-18","title":"Why Can We Still Prove <code>= 1/8</code>?","text":"<p>Here's the beautiful part: noncomputable doesn't mean we can't reason about values!</p>"},{"location":"crypto/Mathlib/DistributionsInLean/#proofs-vs-computation","title":"Proofs vs Computation","text":"<pre><code>-- We can't compute this:\n#eval \u03bcK \u27e8[true, false, true], by decide\u27e9  -- Error: noncomputable\n\n-- But we CAN prove this:\nexample : \u03bcK \u27e8[true, false, true], by decide\u27e9 = 1/8 := by\n  simp [\u03bcK, uniformOfFintype_apply]\n  -- Proves that (card (Key 3))\u207b\u00b9 = 8\u207b\u00b9 = 1/8\n</code></pre>"},{"location":"crypto/Mathlib/DistributionsInLean/#whats-happening","title":"What's Happening?","text":"<ol> <li> <p>Definitional unfolding: Even though <code>\u03bcK</code> is noncomputable, we can unfold its definition in proofs.</p> </li> <li> <p>Symbolic reasoning: We prove <code>1/card(Key 3) = 1/8</code> symbolically, not by computation.</p> </li> <li> <p>Type class inference: Lean knows <code>Fintype (Key 3)</code> and can reason about cardinalities.</p> </li> <li> <p>Real number lemmas: Mathlib has lemmas about real arithmetic that we use in proofs.</p> </li> </ol>"},{"location":"crypto/Mathlib/DistributionsInLean/#the-philosophical-point","title":"The Philosophical Point","text":"<p>This separation between computation and reasoning is fundamental:</p> <ul> <li>Computation: Running an algorithm to get a concrete answer.</li> <li>Reasoning: Proving properties about mathematical objects.</li> </ul> <p>In formal mathematics, we often work with noncomputable objects (like real numbers, infinite sets, choice functions) but can still prove precise theorems about them.</p>"},{"location":"crypto/Mathlib/DistributionsInLean/#summary","title":"Summary","text":"<ul> <li> <p>In Lean, probability distributions are functions from outcomes to probabilities, bundled with a proof that probabilities sum to 1.</p> </li> <li> <p>Even though we work with finite spaces, these are marked <code>noncomputable</code> because they use real number arithmetic and infinite summation machinery.</p> </li> <li> <p>This doesn't limit our reasoning---we can still prove exact results like \"each key has probability 1/8.\"</p> </li> <li> <p>The distinction between computation and proof is fundamental: we reason symbolically about these mathematical objects without needing to compute their values.\"</p> </li> <li> <p>Practical Analogy</p> <ul> <li>Computable: a calculator gives you 0.125 when you type 1 \u00f7 8.</li> <li>Noncomputable with proofs: we can show algebraically that 1/8 = 0.125 without calculating</li> </ul> <p>PMFs in Lean are the second kind---we work with them symbolically and prove properties, rather than computing decimal expansions.</p> </li> </ul>"},{"location":"crypto/Mathlib/WhyExtendedNNReals/","title":"Deep Dive: Why use [0, \u221e] for the codomain of a distribution?","text":"<ul> <li>Probabilities should be in [0, 1] by definition.</li> <li>If p + q &gt; 1, then p + q isn't a probability of anything.</li> <li>A rich type system should enforce this constraint.</li> <li>Having to prove preservation of [0, 1] keeps us mathematically honest.</li> </ul> <p>So why did Mathlib choose <code>ENNReal</code>? The reasons are probably subtle, but we can speculate.</p>"},{"location":"crypto/Mathlib/WhyExtendedNNReals/#1-integration-with-measure-theory","title":"1. Integration with Measure Theory","text":"<p>This is probably the biggest reason:</p> <pre><code>/-- In measure theory, measures assign values in [0,\u221e] to sets.\n\nA measure is defined to be an outer measure that is countably additive on\nmeasurable sets, with the assumption that the outer measure is the canonical\nextension of the restricted measure.\n\nThe measure of a set `s`, denoted `\u03bc s`, is an extended nonnegative real.\n\nThe real-valued version is written `\u03bc.real s`.\n-/\nstructure Measure (\u03b1 : Type*) [MeasurableSpace \u03b1] extends OuterMeasure \u03b1 where\n  m_iUnion \u2983f : \u2115 \u2192 Set \u03b1\u2984 : (\u2200 i, MeasurableSet (f i)) \u2192 Pairwise (Disjoint on f) \u2192\n    toOuterMeasure (\u22c3 i, f i) = \u2211' i, toOuterMeasure (f i)\n  trim_le : toOuterMeasure.trim \u2264 toOuterMeasure\n</code></pre> <pre><code>/-- A measure `\u03bc` is called a probability measure if `\u03bc univ = 1`. -/\nclass IsProbabilityMeasure (\u03bc : Measure \u03b1) : Prop where\n  measure_univ : \u03bc univ = 1\n</code></pre> <p>PMFs are designed to integrate seamlessly with measure theory, where <code>ENNReal</code> is standard.</p>"},{"location":"crypto/Mathlib/WhyExtendedNNReals/#2-division-conventions","title":"2. Division Conventions","text":"<p><code>ENNReal</code> has specific conventions that make probability formulas work:</p> <pre><code>-- In ENNReal:\n0 / 0 = 0    -- Makes conditional probability P(A|B) work when P(B) = 0\nx / \u221e = 0    -- Handles certain limit cases\nx / 0 = \u221e    -- for x &gt; 0\n</code></pre> <p>These would be messier and require more special case analysis with a [0, 1] type.</p>"},{"location":"crypto/Mathlib/WhyExtendedNNReals/#the-pragmatic-compromise","title":"The Pragmatic Compromise","text":"<p>Philosophically, a <code>Probability</code> type should be:</p> <pre><code>def Probability := {x : \u211d // 0 \u2264 x \u2227 x \u2264 1}\n</code></pre> <p>And operations should return proofs:</p> <pre><code>def prob_or (p q : Probability) (h : disjoint) : Probability :=\n  \u27e8p.val + q.val, by proof_that_sum_le_1\u27e9\n</code></pre> <p>Mathlib probably chose <code>ENNReal</code> for pragmatic reasons:</p> <ol> <li>Compatibility with measure theory (the bigger framework)</li> <li>Computational convenience (limits and sums \"just work\")</li> <li>Mathematical practice (probabilists often work with unnormalized measures)</li> </ol> <p>But this loses \"type safety.\" A more principled approach might have:</p> <pre><code>-- The \"right\" design?\nstructure PMF (\u03b1 : Type*) where\n  val : \u03b1 \u2192 Probability  -- Each value is certified in [0,1]\n  has_sum_one : \u2211 val = 1\n</code></pre>"},{"location":"crypto/Mathlib/WhyExtendedNNReals/#summary","title":"Summary","text":"<ul> <li> <p>Mathlib uses [0, \u221e] for probability values, which might seem wrong---probabilities    should be in [0,1]!</p> </li> <li> <p>A pragmatic choice for integration with measure theory and handling limits.</p> </li> <li> <p>In a perfect world, we might use a <code>Probability</code> type that restricts inhabitants    to [0, 1].</p> </li> <li> <p>Mathlib prioritizes compatibility with the broader mathematical ecosystem over type safety here.</p> </li> </ul>"},{"location":"crypto/Mathlib/WhyExtendedNNReals/#honest-bottom-line","title":"Honest Bottom Line","text":"<p>A real tension in library design:</p> <ul> <li>Type safety says: enforce invariants in types</li> <li>Pragmatism says: make it compatible with existing math</li> <li>Mathlib chose pragmatism over purity here</li> </ul>"},{"location":"crypto/Mathlib/bind_and_pure/","title":"<code>bind</code> and <code>pure</code> for Probability Distributions","text":""},{"location":"crypto/Mathlib/bind_and_pure/#pure-creating-a-deterministic-distribution","title":"<code>pure</code>: Creating a Deterministic Distribution","text":"<p><code>pure a</code> creates a probability distribution that always returns <code>a</code> with probability 1.</p> <pre><code>pure : \u03b1 \u2192 PMF \u03b1\npure a = the distribution where P(X = a) = 1 and P(X = b) = 0 for all b \u2260 a\n</code></pre>"},{"location":"crypto/Mathlib/bind_and_pure/#example","title":"Example","text":"<pre><code>def always_true : PMF Bool := pure true\n-- This distribution gives: P(true) = 1, P(false) = 0\n</code></pre>"},{"location":"crypto/Mathlib/bind_and_pure/#in-our-code","title":"In our code","text":"<pre><code>pure (encrypt m k)\n</code></pre> <p>would creates a distribution that always returns the specific ciphertext <code>encrypt m k</code> with probability 1.</p>"},{"location":"crypto/Mathlib/bind_and_pure/#bind-chaining-random-processes","title":"<code>bind</code>: Chaining Random Processes","text":"<p><code>bind</code> chains two random processes together:</p> <ol> <li>First, sample from one distribution.</li> <li>Based on that result, sample from another distribution.</li> </ol> <pre><code>bind : PMF \u03b1 \u2192 (\u03b1 \u2192 PMF \u03b2) \u2192 PMF \u03b2\n</code></pre>"},{"location":"crypto/Mathlib/bind_and_pure/#intuitive-explanation","title":"Intuitive Explanation","text":"<p>Think of <code>bind p f</code> as a two-step random process:</p> <ol> <li>Sample <code>x</code> from distribution <code>p</code>.</li> <li>Use <code>x</code> to choose a new distribution <code>f x</code>.</li> <li>Sample from <code>f x</code> to get the final result.</li> </ol>"},{"location":"crypto/Mathlib/bind_and_pure/#example_1","title":"Example","text":"<pre><code>-- Roll a die, then flip that many coins and count heads\ndef roll_then_flip : PMF Nat :=\n  bind die_roll (fun n =&gt; flip_n_coins n)\n</code></pre>"},{"location":"crypto/Mathlib/bind_and_pure/#breaking-down-our-expression","title":"Breaking Down Our Expression","text":"<pre><code>\u03bcC = bind \u03bcMK (fun mk =&gt; pure (encrypt mk.1 mk.2))\n</code></pre> <p>This means:</p> <ol> <li>First step: sample a pair <code>(m, k)</code> from the joint distribution <code>\u03bcMK</code></li> <li>Second step: Return <code>encrypt m k</code> with probability 1</li> </ol> <p>Since the second step is deterministic (<code>pure</code>), this simplifies to:</p> <p>Sample <code>(m, k)</code> from <code>\u03bcMK</code> and output <code>encrypt m k</code>.</p>"},{"location":"crypto/Mathlib/bind_and_pure/#why-use-bind-and-pure","title":"Why Use <code>bind</code> and <code>pure</code>?","text":"<p>To build complex probability distributions from simple ones:</p> <pre><code>-- Without bind/pure (conceptually):\n\u03bcC c = \u03a3 {P(M=m, K=k) : (m, k) is such that (encrypt m k = c)}\n\n-- With bind/pure:\n\u03bcC = bind \u03bcMK (fun mk =&gt; pure (encrypt mk.1 mk.2))\n</code></pre> <p>The <code>bind</code>/<code>pure</code> formulation is cleaner and more compositional.</p>"},{"location":"crypto/Mathlib/bind_and_pure/#the-general-pattern","title":"The General Pattern","text":"<pre><code>bind p (fun x =&gt; pure (f x)) = map f p\n</code></pre> <p>When the second step is deterministic (using <code>pure</code>), <code>bind</code> reduces to <code>map</code>.</p> <p>So we could also write: <pre><code>\u03bcC = map (fun mk =&gt; encrypt mk.1 mk.2) \u03bcMK\n</code></pre></p>"},{"location":"crypto/Mathlib/bind_and_pure/#in-probability-terms","title":"In Probability Terms","text":"<ul> <li><code>pure a</code> is the Dirac delta distribution \u03b4_a</li> <li><code>bind</code> is the law of total probability:   <pre><code>P(Y = y) = \u03a3_x P(X = x) \u00b7 P(Y = y | X = x)\n</code></pre>   where <code>bind p f</code> represents the distribution of Y when:</li> <li>X has distribution p</li> <li>Y | X=x has distribution f(x)</li> </ul>"},{"location":"crypto/Mathlib/bind_and_pure/#summary","title":"Summary","text":"<p>In <code>\u03bcC = bind \u03bcMK (fun mk =&gt; pure (encrypt mk.1 mk.2))</code>: - <code>\u03bcMK</code> is the joint distribution of (message, key) pairs - <code>bind</code> says \"sample from this distribution\" - <code>fun mk =&gt; pure (encrypt mk.1 mk.2)</code> says \"then apply encryption deterministically\" - Result: <code>\u03bcC</code> is the distribution of ciphertexts</p>"},{"location":"crypto/Mathlib/list-and-vector/","title":"List and Vector in Mathlib","text":"<p>Tip: Use the Mathlib documentation website for easy browsing of module contents and definitions.</p>"},{"location":"crypto/Mathlib/list-and-vector/#datalist","title":"<code>Data.List</code>","text":"<ul> <li> <p>In <code>Mathlib/Data/List/Basic.lean</code> and other files in <code>Mathlib/Data/List/</code>.</p> </li> <li> <p>While <code>Vector</code> is likely better for fixed-length crypto primitives, <code>List \u03b1</code> is    the standard list type. </p> </li> <li> <p>Good to know its API (e.g., <code>map</code>, <code>zipWith</code>, <code>length</code>) as <code>Vector</code> often mirrors    or builds upon <code>List</code> concepts.</p> </li> </ul>"},{"location":"crypto/Mathlib/list-and-vector/#datavector","title":"<code>Data.Vector</code>","text":"<ul> <li> <p>Located in <code>Mathlib/Data/Vector/Basic.lean</code>.</p> </li> <li> <p><code>Vector \u03b1 n</code>: Represents a list of elements of type <code>\u03b1</code> that is known to have length <code>n</code>. </p> </li> </ul> <p>Very suitable for plaintexts, keys, and ciphertexts where length is fixed and equal.</p> <ul> <li> <p>Useful functions:</p> <ul> <li><code>Vector.map (f : \u03b1 \u2192 \u03b2) : Vector \u03b1 n \u2192 Vector \u03b2 n</code></li> <li><code>Vector.map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 Vector \u03b3 n</code>,      perfect for XORing two vectors. </li> <li><code>Vector.get : Vector \u03b1 n \u2192 Fin n \u2192 \u03b1</code> to get an element at an index.</li> <li><code>Vector.ofFn : ((i : Fin n) \u2192 \u03b1) \u2192 Vector \u03b1 n</code> to construct a vector from a function.</li> <li>Literals like <code>![a, b, c]</code> can often be coerced to <code>Vector \u03b1 3</code> if the type is known.</li> </ul> </li> </ul>"},{"location":"crypto/Mathlib/prob/","title":"Probability in L\u2203\u2200N","text":""},{"location":"crypto/Mathlib/prob/#basic-definitions-of-probability-theory","title":"\ud83c\udfb2 Basic Definitions of Probability Theory","text":"<ul> <li> <p>\u03a9 denotes an outcome space</p> </li> <li> <p>\u03c9 \u2208 \u03a9 denotes an outcome (e.g., of an experiment, trial, etc.)</p> </li> <li> <p>An event \ud835\udc38 is a set of outcomes: \ud835\udc38 \u2286 \u03a9</p> </li> <li> <p>A probability mass function (pmf), or probability measure, on an outcome space is    a function \u2119 : \u03a9 \u2192 \u211d such that, for all events \ud835\udc38\u2080, \ud835\udc38\u2081, \u2026</p> </li> <li>\u2119 \u2205 = 0 and \u2119 \u03a9 = 1</li> <li>0 \u2264 \u2119 \ud835\udc38\u1d62 \u2264 1</li> <li>\ud835\udc38\u1d62 \u2286 \ud835\udc38\u2c7c \u2192 \u2119 \ud835\udc38\u1d62 \u2264 \u2119 \ud835\udc38\u2c7c (monotone)</li> <li>\u2119(\u22c3 \ud835\udc38\u1d62) \u2264 \u2211 \u2119 \ud835\udc38\u1d62 (subadditive)</li> </ul> <p>Mathlib's definition</p> <p>It's slightly more direct: it's a function <code>f : \u03b1 \u2192 NNReal</code> (non-negative reals) along with a proof <code>h : tsum f = 1</code> (the sum of <code>f a</code> over all <code>a : \u03b1</code> is 1). The other properties above (like monotonicity, probability of empty set being 0, etc.) can be derived from this.</p>"},{"location":"crypto/Mathlib/prob/#basic-probability-in-mathlib","title":"Basic Probability in Mathlib","text":"<p><code>Probability/ProbabilityMassFunction/</code></p> <p>\ud83d\udcc1 <code>Mathlib/Probability/ProbabilityMassFunction/Basic.lean</code></p> <ul> <li> <p>Often imported as <code>PMF</code>.</p> </li> <li> <p>It's the main tool for defining discrete random variables and their distributions.</p> </li> </ul> <p>\ud83d\udd11\ufe0f Key Concepts</p> <ul> <li> <p><code>PMF \u03b1</code> represents a probability mass function (pmf) over a type <code>\u03b1</code>;    it's a function <code>\u03b1 \u2192 NNReal</code> (non-negative reals) where the sum over all <code>a : \u03b1</code> is 1.</p> </li> <li> <p><code>PMF.pure (a : \u03b1)</code> is a pmf with all mass at <code>a</code> (prob 1 for <code>a</code>, 0 otherwise).</p> </li> <li> <p><code>PMF.bind (p : PMF \u03b1) (f : \u03b1 \u2192 PMF \u03b2)</code> is used for creating dependent r.v.s;    given a r.v. <code>p</code> and function <code>f</code> mapping outcomes of <code>p</code> to new r.v.s, <code>bind</code> gives the resulting distribution on <code>\u03b2</code>.</p> </li> <li> <p><code>PMF.map (f : \u03b1 \u2192 \u03b2) (p : PMF \u03b1)</code>: If we apply a function <code>f</code> to the outcomes    of a r.v. <code>p</code>, <code>map</code> gives the pmf of the results.</p> </li> </ul>"},{"location":"crypto/Mathlib/prob/#conditional-probability-in-mathlib","title":"Conditional Probability in Mathlib","text":"<p>\ud83d\udcc1 <code>Mathlib/Probability/ConditionalProbability.lean</code></p> <p><code>Probability.ConditionalProbability</code></p> <ul> <li> <p><code>cond</code> is the conditional probability measure of measure <code>\u03bc</code> on set <code>s</code></p> </li> <li> <p>it is <code>\u03bc</code> restricted to <code>s</code> and scaled by the inverse of <code>\u03bc s</code> (to make it a    probability measure): <code>(\u03bc s)\u207b\u00b9 \u2022 \u03bc.restrict s</code></p> </li> <li> <p><code>cond (p : PMF \u03b1) (E : Set \u03b1)</code> gives the conditional pmf given an event <code>E</code> &lt;&lt;== check this!!</p> </li> </ul> <p>we'll use it to define \\(P(M=m \\; | \\; C=c)\\)</p> <p>Other notable files</p> <ul> <li><code>Probability/ConditionalExpectation.lean</code> conditional expectation</li> <li><code>Probability/CondVar.lean</code> conditional variance</li> <li><code>Probability/Independence/Conditional.lean</code> conditional independence</li> </ul>"},{"location":"crypto/Mathlib/vector-and-list/","title":"Vector and List in Mathlib","text":"<p>Tip</p> <p>Use the Mathlib documentation website for easy browsing of module contents and definitions.</p> <p>https://leanprover-community.github.io/mathlib4_docs/index.html</p>"},{"location":"crypto/Mathlib/vector-and-list/#datavector","title":"<code>Data/Vector/</code>","text":"<p>\ud83d\udcc1 <code>Mathlib/Data/Vector/Basic.lean</code>.</p> <ul> <li><code>Vector \u03b1 n</code> represents a list of elements of type <code>\u03b1</code> that is known to have length <code>n</code>.     Well suited to plaintexts, keys, and ciphertexts where length is fixed and equal.</li> </ul> <p>\ud83e\uddf0 Useful functions</p> <ul> <li><code>Vector.map (f : \u03b1 \u2192 \u03b2) : Vector \u03b1 n \u2192 Vector \u03b2 n</code></li> <li><code>Vector.map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 Vector \u03b3 n</code>,    perfect for XORing two vectors. </li> <li><code>Vector.get : Vector \u03b1 n \u2192 Fin n \u2192 \u03b1</code> to get an element at an index.</li> <li><code>Vector.ofFn : ((i : Fin n) \u2192 \u03b1) \u2192 Vector \u03b1 n</code> to construct a vector from a function.</li> <li>Literals like <code>![a, b, c]</code> can often be coerced to <code>Vector \u03b1 3</code> if the type is known.</li> </ul>"},{"location":"crypto/Mathlib/vector-and-list/#datalist","title":"<code>Data/List/</code>","text":"<ul> <li> <p>In <code>Mathlib/Data/List/Basic.lean</code> and other files in <code>Mathlib/Data/List/</code>.</p> </li> <li> <p>While <code>Vector</code> is likely better for fixed-length crypto primitives, <code>List \u03b1</code> is    the standard list type. </p> </li> <li> <p>Good to know its API (e.g., <code>map</code>, <code>zipWith</code>, <code>length</code>) as <code>Vector</code> often mirrors    or builds upon <code>List</code> concepts.</p> </li> </ul>"},{"location":"crypto/otp/2025Jun18-notes/","title":"Lean4: a guide for the pedantic programmer/prover","text":"<p>We seek to create a presentation that not only demonstrates how to prove properties in Lean but also reveals why the methods work, connecting the seemingly magical world of tactics to the solid ground of proof objects with which we are familiar from Agda.</p> <p>Our desire to bridge the gap between tactic-based proofs and their underlying proof terms has been called \"an outstanding pedagogical approach\" (by the Gemini 2.5 Pro AI Agent).</p>"},{"location":"crypto/otp/2025Jun18-notes/#departures","title":"Departures","text":"<p>Let's start with a concrete, fundamental example that we touched upon in our previous meetings: proving the probability that a specific key is chosen.</p> <p>This will allow us to bring the ideas down to earth and immediately dive into and discuss the tactic vs. proof object dichotomy.</p>"},{"location":"crypto/otp/2025Jun18-notes/#part-1-a-concrete-first-proof","title":"Part 1: A Concrete First Proof","text":"<p>Let's start with the following</p> <p>Claim.  The probability of randomly choosing a specific 3-bit key is 1/8.</p> <p>In Lean, the theorem and its tactic-based proof are surprisingly concise:</p> <pre><code>import Mathlib.Probability.ProbabilityMassFunction.Basic\n\n-- To make our example concrete, we'll define Key n as vectors of booleans.\n-- This is equivalent to `Fin n \u2192 Bool` or other n-bit types.\nabbrev Key (n : \u2115) := Vector Bool n\n\n-- The uniform distribution over keys.\nnoncomputable def \u03bcK {n : \u2115} : PMF (Key n) := PMF.uniformOfFintype (Key n)\n\n-- Our claim: probability of choosing the key [true, false, true] is 1/8.\nexample : \u03bcK \u27e8[true, false, true], by simp\u27e9 = (1/8 : ENNReal) := by\n  simp [\u03bcK, PMF.uniformOfFintype_apply]\n</code></pre> <p>This is fine for a user who knows what <code>simp</code> means and does, but it's a \"magical incantation\" for a newcomer.</p> <p>Let's unpack it!</p>"},{"location":"crypto/otp/2025Jun18-notes/#goal-deconstruct-simp","title":"\ud83e\udd45 Goal: deconstruct <code>simp</code>","text":"<p>The <code>simp</code> tactic is an automated rewriter.</p> <p>It tries to simplify the main goal by applying a list of theorems (called a \"simpset\") from left to right, over and over, until no more simplifications can be made.</p> <p>When you write <code>simp [foo, bar]</code>, you are telling it: \"Please use your standard simpset, and also add the definitions or lemmas <code>foo</code> and <code>bar</code> to the set of tools you can use.\"</p> <p>Let's break down the proof step-by-step, showing the tactic at each stage and then discussing the proof object it's building.</p>"},{"location":"crypto/otp/2025Jun18-notes/#step-1-unfolding-the-definition-of-k","title":"Step 1: Unfolding the Definition of <code>\u03bcK</code> \ud83d\udd75\ufe0f\u200d\u2642\ufe0f","text":"<p>The State Before the Tactic</p> <pre><code>\u22a2 \u03bcK \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>Here, <code>\u22a2</code> indicates the goal we are trying to prove.</p> <p>The Tactic <code>simp [\u03bcK]</code> or <code>rw [\u03bcK]</code></p> <p>This tells Lean to substitute <code>\u03bcK</code> with its definition.</p> <p>The State After the Tactic:</p> <pre><code>\u22a2 PMF.uniformOfFintype (Key 3) \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>Why this works (\"under the hood\")</p> <ul> <li><code>\u03bcK</code> is defined as <code>PMF.uniformOfFintype (Key n)</code>.</li> <li>The <code>simp</code> tactic (and the more targeted <code>rw</code> tactic) has access to all definitions in the context.</li> <li>It sees the term <code>\u03bcK</code> in the goal and replaces it with its definition. This is a simple substitution.</li> </ul> <p>The Equivalent Proof Term</p> <p>In a term-based proof, this substitution is achieved using functions that show equality is respected by function application.</p> <p>If we have a proof <code>h : \u03bcK = PMF.uniformOfFintype (Key 3)</code>, we can use it to rewrite the goal.</p> <p>The definition itself provides this proof <code>h</code>. The core idea is <code>Eq.subst</code> or <code>Eq.rec</code>.</p> <p>A proof term for just this step would look like this:</p> <p><pre><code>-- Let P be the property we are trying to prove for the definition.\n-- P := fun x =&gt; x \u27e8[true, false, true], _\u27e9 = 1/8\n-- Our goal is `P (\u03bcK)`\n-- The definition of \u03bcK gives us `proof_of_definition : \u03bcK = PMF.uniformOfFintype (Key 3)`\n\n-- The new proof term is:\nEq.subst proof_of_definition (new_goal : P (PMF.uniformOfFintype (Key 3)))\n</code></pre> This is clunky. A more common term-based idiom is to simply start with the definition already unfolded.</p> <p>The tactic <code>rw</code> is essentially a mechanical way of applying <code>Eq.subst</code>.</p>"},{"location":"crypto/otp/2025Jun18-notes/#step-2-unfolding-the-definition-of-the-uniform-pmf","title":"Step 2: Unfolding the Definition of the Uniform PMF","text":"<p>Now we apply the definition of what <code>uniformOfFintype</code> actually means for a given input.</p> <p>The State Before the Tactic:</p> <pre><code>\u22a2 PMF.uniformOfFintype (Key 3) \u27e8[true, false, true], rfl\u27e9 = 1 / 8\n</code></pre> <p>The Tactic: <code>simp [PMF.uniformOfFintype_apply]</code></p> <p>The lemma <code>PMF.uniformOfFintype_apply</code> states that for any element <code>a</code> of a finite type <code>\u03b1</code>, <code>PMF.uniformOfFintype \u03b1 a</code> is equal to <code>(Fintype.card \u03b1)\u207b\u00b9</code>.</p> <p>The State After the Tactic:</p> <pre><code>\u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> <p>Why this works (\"Under the Hood\"):</p> <ul> <li>The <code>simp</code> engine found a lemma <code>PMF.uniformOfFintype_apply</code> in the library.</li> <li>This lemma matches the pattern <code>PMF.uniformOfFintype (Key 3) ...</code> on the left side of our goal.</li> <li>It rewrites the left side of the goal using this lemma, replacing it with <code>(Fintype.card (Key 3))\u207b\u00b9</code>.</li> </ul> <p>The Equivalent Proof Term:</p> <p>This is a direct application of the lemma. The proof term for this rewrite is <code>PMF.uniformOfFintype_apply (Key 3) \u27e8...\u27e9</code>. Applying this equality to our goal transforms it. A proof would look like:</p> <p><pre><code>-- h\u2081 : PMF.uniformOfFintype (Key 3) \u27e8...\u27e9 = (Fintype.card (Key 3))\u207b\u00b9\n-- This comes from the lemma PMF.uniformOfFintype_apply\n-- We use this to transform the goal into proving:\n-- \u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> This is again a form of <code>Eq.subst</code>. The <code>rw</code> tactic is the most direct parallel: <code>rw [PMF.uniformOfFintype_apply]</code>.</p>"},{"location":"crypto/otp/2025Jun18-notes/#step-3-computing-the-cardinality-and-final-simplification","title":"Step 3: Computing the Cardinality and Final Simplification","text":"<p>This is where <code>simp</code> really shines by combining computation and proof.</p> <p>The State Before the Tactic:</p> <pre><code>\u22a2 (Fintype.card (Key 3))\u207b\u00b9 = 1 / 8\n</code></pre> <p>The Tactic: <code>simp</code></p> <p>We don't need to provide any more lemmas. The rest is handled by Lean's built-in capabilities.</p> <p>The State After the Tactic:</p> <p>The goal is solved!</p> <p>Why this works (\"Under the Hood\"):</p> <ol> <li>Typeclass Inference: Lean needs to know the size of <code>Key 3</code>. The type <code>Key 3</code>, which is <code>Vector Bool 3</code>, has an instance of the <code>Fintype</code> typeclass. This instance provides a computable function to get the number of elements.</li> <li>Computation: The <code>simp</code> tactic (or the <code>norm_num</code> tactic it calls internally) executes this function. It knows <code>Vector Bool 3</code> has <code>2^3 = 8</code> elements. So it simplifies <code>Fintype.card (Key 3)</code> to the value <code>8</code>. The goal becomes <code>(8 : ENNReal)\u207b\u00b9 = 1/8</code>.</li> <li>Normalization: The <code>simp</code> engine has lemmas about <code>ENNReal</code> arithmetic. It knows that <code>(8)\u207b\u00b9</code> is the same as <code>1/8</code>.</li> <li>Reflexivity: The goal becomes <code>1/8 = 1/8</code>. This is true by reflexivity (<code>rfl</code>).</li> </ol> <p>The Equivalent Proof Term:</p> <p>A term-based proof would need to explicitly provide the proofs for each of these steps:</p> <p><pre><code>-- A lemma that proves card (Key 3) = 8\nhave card_proof : Fintype.card (Key 3) = 8 := by-- ... proof using vector cardinality lemmas\n\n-- We use this proof to rewrite the goal\n-- The goal becomes \u22a2 8\u207b\u00b9 = 1/8\n-- This is true by reflexivity, since 8\u207b\u00b9 is just notation for 1/8 in ENNReal.\n-- The final term is:\nrfl\n</code></pre> The <code>simp</code> tactic automated the process of finding <code>card_proof</code>, applying it, and then seeing that the result was definitionally equal. The full proof term generated by our original <code>by simp [...]</code> is effectively a composition of all these steps, applying congruence lemmas (<code>congr_arg</code>) and transitivity (<code>Eq.trans</code>) to chain all the intermediate equalities together into one grand proof that the starting expression equals the final one.</p>"},{"location":"crypto/otp/2025Jun18-notes/#summary-your-agda-perspective","title":"Summary &amp; Your Agda Perspective","text":"Tactic Proof Step What it Does Underlying Proof Term Concept <code>by simp [\u03bcK, ...]</code> A powerful, automatic rewrite sequence. A complex, generated term chaining together multiple equalities. It's a function that takes no arguments and returns a proof of <code>LHS = RHS</code>. <code>rw [\u03bcK]</code> Replaces <code>\u03bcK</code> with its definition. Application of <code>Eq.subst</code> or <code>Eq.rec</code> using the definitional equality of <code>\u03bcK</code>. <code>rw [lem]</code> Rewrites the goal using a proven lemma <code>lem : A = B</code>. Application of <code>Eq.subst</code> using the lemma <code>lem</code> as the proof of equality. <code>rfl</code> Solves a goal of the form <code>A = A</code>. The constructor for equality, <code>Eq.refl A</code>. It's a direct proof object. <p>From your Agda perspective, you can think of a tactic proof as a program that writes a proof term. Each tactic is a command in this program. <code>simp</code> is a very high-level command, like a call to a complex library, while <code>rw</code> and <code>rfl</code> are more like fundamental operations.</p> <p>This first example was heavy on <code>simp</code>. Next, we can tackle a proof that requires more manual, step-by-step tactics like <code>intro</code>, <code>apply</code>, and <code>let</code>, which have even clearer one-to-one correspondences with proof-term constructs like <code>fun</code>, function application, and <code>let ... in ...</code>.</p>"},{"location":"crypto/otp/DistributionsInLean/","title":"Deep Dive: How Lean Represents Probability Distributions","text":""},{"location":"crypto/otp/DistributionsInLean/#what-is-a-pmf-really","title":"What is a PMF Really?","text":"<p>In Lean/Mathlib, a <code>PMF \u03b1</code> (Probability Mass Function) is fundamentally:</p> <pre><code>structure PMF (\u03b1 : Type*) where\n  val : \u03b1 \u2192 \u211d\u22650\u221e                 -- Function from \u03b1 to extended non-negative reals\n  has_sum_one : \u2211' a, val a = 1  -- Proof that probabilities sum to 1\n</code></pre> <p>So a PMF is a pair</p> <ol> <li> <p>A function assigning probabilities to outcomes</p> </li> <li> <p>A proof that these probabilities form a valid distribution</p> </li> </ol>"},{"location":"crypto/otp/DistributionsInLean/#our-distributions-as-mathematical-objects","title":"Our Distributions as Mathematical Objects","text":""},{"location":"crypto/otp/DistributionsInLean/#m-pmf-plaintext-n","title":"\u03bcM : PMF (Plaintext n)","text":"<ul> <li>Type: A function <code>Plaintext n \u2192 \u211d\u22650\u221e</code> (plus a proof)</li> <li>Meaning: For any n-bit message m, <code>\u03bcM m</code> is the probability that message m is sent</li> <li>Example: If all messages equally likely, <code>\u03bcM m = 1/2^n</code> for all m</li> </ul>"},{"location":"crypto/otp/DistributionsInLean/#k-pmf-key-n","title":"\u03bcK : PMF (Key n)","text":"<ul> <li>Type: A function <code>Key n \u2192 \u211d\u22650\u221e</code></li> <li>Meaning: For any n-bit key k, <code>\u03bcK k</code> is its probability</li> <li>Definition: <code>uniformOfFintype</code> makes <code>\u03bcK k = 1/2^n</code> for all k</li> </ul>"},{"location":"crypto/otp/DistributionsInLean/#mk-pmf-plaintext-n-key-n","title":"\u03bcMK : PMF (Plaintext n \u00d7 Key n)","text":"<ul> <li>Type: A function <code>(Plaintext n \u00d7 Key n) \u2192 \u211d\u22650\u221e</code></li> <li>Meaning: Joint probability P(M = m \u2227 K = k)</li> <li>Value: <code>\u03bcMK (m,k) = \u03bcM m * \u03bcK k</code> (independence!)</li> </ul>"},{"location":"crypto/otp/DistributionsInLean/#c-pmf-ciphertext-n","title":"\u03bcC : PMF (Ciphertext n)","text":"<ul> <li>Type: A function <code>Ciphertext n \u2192 \u211d\u22650\u221e</code> </li> <li>Meaning: For any n-bit ciphertext c, <code>\u03bcC c</code> is probability of observing c</li> <li>Computed: By summing over all (m,k) pairs that produce c</li> </ul>"},{"location":"crypto/otp/DistributionsInLean/#c_m-plaintext-n-pmf-ciphertext-n","title":"\u03bcC_M : Plaintext n \u2192 PMF (Ciphertext n)","text":"<ul> <li>Type: A function that takes a message and returns a distribution</li> <li>Meaning: For fixed m, <code>\u03bcC_M m</code> is the conditional distribution P(C | M = m)</li> <li>Value: <code>(\u03bcC_M m) c = if \u2203k. encrypt m k = c then 1/2^n else 0</code></li> </ul>"},{"location":"crypto/otp/DistributionsInLean/#why-noncomputable","title":"Why <code>noncomputable</code>?","text":"<p>This is subtle! Even though we're dealing with finite types, these definitions are <code>noncomputable</code> because:</p>"},{"location":"crypto/otp/DistributionsInLean/#1-real-number-arithmetic","title":"1. Real Number Arithmetic","text":"<pre><code>noncomputable def \u03bcK {n : \u2115} : PMF (Key n) := uniformOfFintype (Key n)\n</code></pre> <p>The probability values are in <code>\u211d\u22650\u221e</code> (extended non-negative reals), not rationals:</p> <ul> <li><code>1/2\u207f</code> is computed as real division, not rational division</li> <li>Real arithmetic is inherently noncomputable in constructive mathematics</li> <li>Even though we \"know\" the answer is rational, the type system uses reals</li> </ul>"},{"location":"crypto/otp/DistributionsInLean/#2-infinite-summations","title":"2. Infinite Summations","text":"<p>Even for finite types, PMF uses infinite summation machinery:</p> <pre><code>\u2211' a : \u03b1, p a  -- This is an infinite sum operator\n</code></pre> <ul> <li>The <code>\u2211'</code> notation works for both finite and infinite types.</li> <li>It's defined using limits and topology.</li> <li>Even when <code>\u03b1</code> is finite, we use the general machinery.</li> </ul>"},{"location":"crypto/otp/DistributionsInLean/#3-classical-logic","title":"3. Classical Logic","text":"<p>PMF operations often use classical logic (excluded middle):</p> <pre><code>open Classical  -- Needed for many probability operations\n</code></pre> <p>This makes things noncomputable in Lean's constructive logic.</p>"},{"location":"crypto/otp/DistributionsInLean/#why-can-we-still-prove-18","title":"Why Can We Still Prove <code>= 1/8</code>?","text":"<p>Here's the beautiful part: noncomputable doesn't mean we can't reason about values!</p>"},{"location":"crypto/otp/DistributionsInLean/#proofs-vs-computation","title":"Proofs vs Computation","text":"<pre><code>-- We can't compute this:\n#eval \u03bcK \u27e8[true, false, true], by decide\u27e9  -- Error: noncomputable\n\n-- But we CAN prove this:\nexample : \u03bcK \u27e8[true, false, true], by decide\u27e9 = 1/8 := by\n  simp [\u03bcK, uniformOfFintype_apply]\n  -- Proves that (card (Key 3))\u207b\u00b9 = 8\u207b\u00b9 = 1/8\n</code></pre>"},{"location":"crypto/otp/DistributionsInLean/#whats-happening","title":"What's Happening?","text":"<ol> <li> <p>Definitional unfolding: Even though <code>\u03bcK</code> is noncomputable, we can unfold its definition in proofs.</p> </li> <li> <p>Symbolic reasoning: We prove <code>1/card(Key 3) = 1/8</code> symbolically, not by computation.</p> </li> <li> <p>Type class inference: Lean knows <code>Fintype (Key 3)</code> and can reason about cardinalities.</p> </li> <li> <p>Real number lemmas: Mathlib has lemmas about real arithmetic that we use in proofs.</p> </li> </ol>"},{"location":"crypto/otp/DistributionsInLean/#the-philosophical-point","title":"The Philosophical Point","text":"<p>This separation between computation and reasoning is fundamental:</p> <ul> <li>Computation: Running an algorithm to get a concrete answer.</li> <li>Reasoning: Proving properties about mathematical objects.</li> </ul> <p>In formal mathematics, we often work with noncomputable objects (like real numbers, infinite sets, choice functions) but can still prove precise theorems about them.</p>"},{"location":"crypto/otp/DistributionsInLean/#summary","title":"Summary","text":"<p>In Lean, probability distributions are functions from outcomes to probabilities, bundled with a proof that probabilities sum to 1.</p> <p>Even though we work with finite spaces, these are marked <code>noncomputable</code> because they use real number arithmetic and infinite summation machinery. </p> <p>This doesn't limit our reasoning---we can still prove exact results like \"each key has probability 1/8.\"</p> <p>The distinction between computation and proof is fundamental: we reason symbolically about these mathematical objects without needing to compute their values.\"</p>"},{"location":"crypto/otp/DistributionsInLean/#a-practical-analogy","title":"A Practical Analogy","text":"<ul> <li>Computable: a calculator gives you 0.125 when you type 1 \u00f7 8.</li> <li>Noncomputable with proofs: we can show algebraically that 1/8 = 0.125 without calculating</li> </ul> <p>PMFs in Lean are the second kind---we work with them symbolically and prove properties, rather than computing decimal expansions.</p>"},{"location":"crypto/otp/basics/","title":"Basics","text":""},{"location":"crypto/otp/basics/#what-is-the-one-time-pad-otp","title":"What is the One-Time Pad (OTP)?","text":"<p>A theoretically unbreakable (\"perfect secrecy\") encryption technique with very specific requirements.</p> <p>The Key \ud83d\udddd\ufe0f must be</p> <ul> <li>truly random</li> <li>at least as long as the plaintext message</li> <li>used only once</li> <li>kept secret between sender and receiver</li> </ul>"},{"location":"crypto/otp/basics/#encryption","title":"Encryption","text":"<p>\u270d\ufe0f Plaintext message: typically converted into a sequence of bits (or numbers)</p> <p>\ud83d\udddd\ufe0f Key: also a sequence of bits (or numbers) of the same length</p> <p>\u3299\ufe0f Encryption: performed by combining plaintext with key using a simple operation, commonly bitwise XOR.</p> <ul> <li> <p><code>Ciphertext = Plaintext xor Key</code> (for bits)</p> <p>\u3299\ufe0f = \u270d\ufe0f \u2295 \ud83d\udddd\ufe0f</p> </li> </ul> using numbers instead of bits <p>If using numbers, e.g., letters A=0, B=1, ... Z=25, then modular addition is used instead:</p> <p><code>Ciphertext = (Plaintext + Key) mod N</code></p>"},{"location":"crypto/otp/basics/#decryption","title":"Decryption","text":"<p>uses the same key and the reverse operation</p> <ul> <li><code>Plaintext = Ciphertext XOR Key</code> (because <code>(P XOR K) XOR K = P</code>)</li> <li><code>Plaintext = (Ciphertext - Key) mod N</code></li> </ul>"},{"location":"crypto/otp/basics/#perfect-secrecy","title":"Perfect Secrecy","text":"<p>The core theoretical property of OTP is</p> <p>The ciphertext provides no information (other than max length) about the plaintext content.</p> <ul> <li> <p>Formally, \\(P(\\text{plaintext} = m \\; | \\; \\text{ciphertext} = c) = P(\\text{plaintext} = m)\\).</p> </li> <li> <p>Knowing \\(c\\) doesn't change the probability distribution of the plaintext \\(m\\).</p> </li> <li> <p>This holds only if all the conditions for the key are met (random, same length, used once).</p> </li> </ul>"},{"location":"crypto/otp/basics/#why-otp-is-interesting-to-cryptographers","title":"Why OTP is interesting to cryptographers","text":"<ul> <li> <p>Highlights critical importance of key management (randomness, length,    single-use, secrecy).</p> </li> <li> <p>Most practical ciphers try to achieve similar security with    shorter, reusable keys. (much harder)</p> </li> <li> <p>Understanding limitations of OTP motivates study of other cryptographic systems.</p> </li> </ul>"},{"location":"crypto/otp/basics/#feasibility-of-formalizing-otp-in-lean","title":"Feasibility of Formalizing OTP in Lean","text":"<p>Formalizing the One-Time Pad in Lean is highly feasible and useful as a PoC, providing a concrete example of verifying a security property.</p> <ul> <li> <p>Simple Operations. The core operations (XOR, modular addition) are already    well-defined or easy to define in Lean. Mathlib has <code>Bool.xor</code> and <code>ZMod N</code> for modular arithmetic.</p> </li> <li> <p>Clear Definitions: We can define types for plaintexts, keys, and ciphertexts    (e.g., <code>List Bool</code>, <code>Vector Bool n</code>, or functions <code>Fin n \u2192 Bool</code>).</p> </li> <li> <p>Focus on a Key Property. The main goal would be to formalize and prove its    perfect secrecy, a non-trivial but achievable result that would be very compelling.</p> </li> <li> <p>Mathlib Support. Mathlib has a growing library for probability theory on    finite types (<code>Mathlib.Probability.ProbabilityMassFunction</code>), which is essential    for proving perfect secrecy. We don't need to build from scratch!</p> </li> </ul>"},{"location":"crypto/otp/basics/#what-to-formalize","title":"What to Formalize","text":"<ol> <li> <p>Define message space, key space, ciphertext space.     For simplicity, use <code>Vector Bool n</code> (vectors of Booleans of fixed length <code>n</code>).</p> </li> <li> <p>Define encrypt and decrypt functions.     (e.g., element-wise XOR for <code>Vector Bool n</code>).</p> </li> <li> <p>State assumptions about key.</p> <ul> <li> <p>chosen uniformly at random from the key space</p> </li> <li> <p>independent of plaintext</p> </li> </ul> </li> <li> <p>Formalize definition of perfect secrecy.</p> \\[P(M=m \\; | \\; C=c) = P(M=m)\\] <p>Involves defining probability mass functions for message and key, and conditional probability.</p> </li> <li> <p>Prove our OTP implementation satisfies perfect secrecy under the stated assumptions.</p> </li> </ol>"},{"location":"crypto/otp/bind_and_pure/","title":"<code>bind</code> and <code>pure</code> for Probability Distributions","text":""},{"location":"crypto/otp/bind_and_pure/#pure-creating-a-deterministic-distribution","title":"<code>pure</code>: Creating a Deterministic Distribution","text":"<p><code>pure a</code> creates a probability distribution that always returns <code>a</code> with probability 1.</p> <pre><code>pure : \u03b1 \u2192 PMF \u03b1\npure a = the distribution where P(X = a) = 1 and P(X = b) = 0 for all b \u2260 a\n</code></pre>"},{"location":"crypto/otp/bind_and_pure/#example","title":"Example","text":"<pre><code>def always_true : PMF Bool := pure true\n-- This distribution gives: P(true) = 1, P(false) = 0\n</code></pre>"},{"location":"crypto/otp/bind_and_pure/#in-our-code","title":"In our code","text":"<pre><code>pure (encrypt m k)\n</code></pre> <p>would creates a distribution that always returns the specific ciphertext <code>encrypt m k</code> with probability 1.</p>"},{"location":"crypto/otp/bind_and_pure/#bind-chaining-random-processes","title":"<code>bind</code>: Chaining Random Processes","text":"<p><code>bind</code> chains two random processes together:</p> <ol> <li>First, sample from one distribution.</li> <li>Based on that result, sample from another distribution.</li> </ol> <pre><code>bind : PMF \u03b1 \u2192 (\u03b1 \u2192 PMF \u03b2) \u2192 PMF \u03b2\n</code></pre>"},{"location":"crypto/otp/bind_and_pure/#intuitive-explanation","title":"Intuitive Explanation","text":"<p>Think of <code>bind p f</code> as a two-step random process:</p> <ol> <li>Sample <code>x</code> from distribution <code>p</code>.</li> <li>Use <code>x</code> to choose a new distribution <code>f x</code>.</li> <li>Sample from <code>f x</code> to get the final result.</li> </ol>"},{"location":"crypto/otp/bind_and_pure/#example_1","title":"Example","text":"<pre><code>-- Roll a die, then flip that many coins and count heads\ndef roll_then_flip : PMF Nat :=\n  bind die_roll (fun n =&gt; flip_n_coins n)\n</code></pre>"},{"location":"crypto/otp/bind_and_pure/#breaking-down-our-expression","title":"Breaking Down Our Expression","text":"<pre><code>\u03bcC = bind \u03bcMK (fun mk =&gt; pure (encrypt mk.1 mk.2))\n</code></pre> <p>This means:</p> <ol> <li>First step: sample a pair <code>(m, k)</code> from the joint distribution <code>\u03bcMK</code></li> <li>Second step: Return <code>encrypt m k</code> with probability 1</li> </ol> <p>Since the second step is deterministic (<code>pure</code>), this simplifies to:</p> <p>Sample <code>(m, k)</code> from <code>\u03bcMK</code> and output <code>encrypt m k</code>.</p>"},{"location":"crypto/otp/bind_and_pure/#why-use-bind-and-pure","title":"Why Use <code>bind</code> and <code>pure</code>?","text":"<p>To build complex probability distributions from simple ones:</p> <pre><code>-- Without bind/pure (conceptually):\n\u03bcC c = \u03a3 {P(M=m, K=k) : (m, k) is such that (encrypt m k = c)}\n\n-- With bind/pure:\n\u03bcC = bind \u03bcMK (fun mk =&gt; pure (encrypt mk.1 mk.2))\n</code></pre> <p>The <code>bind</code>/<code>pure</code> formulation is cleaner and more compositional.</p>"},{"location":"crypto/otp/bind_and_pure/#the-general-pattern","title":"The General Pattern","text":"<pre><code>bind p (fun x =&gt; pure (f x)) = map f p\n</code></pre> <p>When the second step is deterministic (using <code>pure</code>), <code>bind</code> reduces to <code>map</code>.</p> <p>So we could also write: <pre><code>\u03bcC = map (fun mk =&gt; encrypt mk.1 mk.2) \u03bcMK\n</code></pre></p>"},{"location":"crypto/otp/bind_and_pure/#in-probability-terms","title":"In Probability Terms","text":"<ul> <li><code>pure a</code> is the Dirac delta distribution \u03b4_a</li> <li><code>bind</code> is the law of total probability:   <pre><code>P(Y = y) = \u03a3_x P(X = x) \u00b7 P(Y = y | X = x)\n</code></pre>   where <code>bind p f</code> represents the distribution of Y when:</li> <li>X has distribution p</li> <li>Y | X=x has distribution f(x)</li> </ul>"},{"location":"crypto/otp/bind_and_pure/#summary","title":"Summary","text":"<p>In <code>\u03bcC = bind \u03bcMK (fun mk =&gt; pure (encrypt mk.1 mk.2))</code>: - <code>\u03bcMK</code> is the joint distribution of (message, key) pairs - <code>bind</code> says \"sample from this distribution\" - <code>fun mk =&gt; pure (encrypt mk.1 mk.2)</code> says \"then apply encryption deterministically\" - Result: <code>\u03bcC</code> is the distribution of ciphertexts</p>"},{"location":"crypto/otp/interleaved_demo_presentation/","title":"Formalizing Discrete Probability in Lean 4: The One-Time Pad","text":""},{"location":"crypto/otp/interleaved_demo_presentation/#fm-crypto-meeting","title":"FM Crypto Meeting","text":""},{"location":"crypto/otp/interleaved_demo_presentation/#overview","title":"Overview","text":"<ul> <li> <p>GOAL</p> <p>Learn how to formalize some basic discrete probability in Lean 4.</p> </li> <li> <p>CASE STUDY</p> <p>Use Lean for formalize the statement and proof of perfect secrecy of the One-Time Pad.</p> </li> <li> <p>KEY CONCEPTS</p> <ul> <li>Probability Mass Functions (PMFs)</li> <li>Independence and joint distributions</li> <li>Conditional probability</li> <li>Bijections preserving uniform distributions</li> </ul> </li> </ul>"},{"location":"crypto/otp/interleaved_demo_presentation/#the-one-time-pad","title":"The One-Time Pad","text":""},{"location":"crypto/otp/interleaved_demo_presentation/#informal-definition","title":"Informal Definition","text":"<ul> <li>Message space: \\(M = \\{0,1\\}^n\\)</li> <li>Key space: \\(K = \\{0,1\\}^n\\)</li> <li>Ciphertext space: \\(C = \\{0,1\\}^n\\)</li> <li>Encryption: \\(\\text{Enc}(m, k) = m \\oplus k\\)</li> <li>Decryption: \\(\\text{Dec}(c, k) = c \\oplus k\\)</li> </ul>"},{"location":"crypto/otp/interleaved_demo_presentation/#key-property","title":"Key Property","text":"\\[\\text{Dec}(\\text{Enc}(m, k), k) = (m \\oplus k) \\oplus k = m\\]"},{"location":"crypto/otp/interleaved_demo_presentation/#lean-4-formalization-types","title":"Lean 4 Formalization: Types","text":"<pre><code>import Mathlib.Data.Vector.Basic\n\ndef Plaintext  (n : Nat) := List.Vector Bool n\ndef Key        (n : Nat) := List.Vector Bool n\ndef Ciphertext (n : Nat) := List.Vector Bool n\n\n-- Element-wise xor\ndef vec_xor {n : Nat} (v\u2081 v\u2082 : List.Vector Bool n) :=\n  map\u2082 xor v\u2081 v\u2082\n\ndef encrypt {n : Nat} (m : Plaintext n) (k : Key n) : Ciphertext n :=\n  vec_xor m k\n</code></pre> Let me show you this in action... <pre><code>-- Demo 1: Basic OTP Operations\nsection BasicOTP\n  open OTP\n\n  -- Create a 4-bit message\n  def demo_msg : Plaintext 4 := \u27e8[true, false, true, true], by decide\u27e9\n  def demo_key : Key 4 := \u27e8[false, true, false, true], by decide\u27e9\n\n  -- Show encryption\n  #eval encrypt demo_msg demo_key\n  -- Output: [true, true, true, false]\n\n  -- Show decryption recovers the message\n  #eval decrypt (encrypt demo_msg demo_key) demo_key\n  -- Output: [true, false, true, true]\n\n  -- Show that different keys give different ciphertexts\n  def demo_key2 : Key 4 := \u27e8[true, true, false, false], by decide\u27e9\n  #eval encrypt demo_msg demo_key2\n  -- Output: [false, true, true, true]\nend BasicOTP\n</code></pre> <p>Key point</p> <p>The same message encrypted with different keys produces different ciphertexts!</p>"},{"location":"crypto/otp/interleaved_demo_presentation/#correctness-of-encryptiondecryption","title":"Correctness of Encryption/Decryption","text":"<pre><code>lemma encrypt_decrypt {n : Nat} (m : Plaintext n) (k : Key n) :\n  decrypt (encrypt m k) k = m := by\n  unfold encrypt decrypt vec_xor\n  apply ext  -- vector extensionality\n  intro i    -- prove element-wise\n  simp only [get_map\u2082]\n  -- Goal: xor (xor (get m i) (get k i)) (get k i) = get m i\n  simp  -- Uses xor properties automatically\n</code></pre> <p>Key insight: Reduce vector equality to element-wise boolean equality</p> Let's explore the xor properties that make this work... <pre><code>-- Demo 2: xor Properties\nsection xorProperties\n  open OTP Bool\n\n  -- Interactive proof that xor is self-inverse\n  example (a b : Bool) : xor (xor a b) b = a := by\n    -- Let's explore the proof interactively\n    rw [xor_assoc]\n    -- Goal: xor a (xor b b) = a\n    rw [xor_self]\n    -- Goal: xor a false = a\n    rw [xor_false]\n    -- Done!\n\n  -- Another way using simp\n  example (a b : Bool) : xor (xor a b) b = a := by simp\nend XORProperties\n</code></pre> <p>Teaching moment</p> <p>Lean can automatically find these properties, but stepping through shows us exactly why decryption works!</p>"},{"location":"crypto/otp/interleaved_demo_presentation/#probability-mass-functions-in-lean","title":"Probability Mass Functions in Lean","text":""},{"location":"crypto/otp/interleaved_demo_presentation/#mathlibs-pmf-type","title":"Mathlib's PMF type","text":"<pre><code>import Mathlib.Probability.ProbabilityMassFunction.Constructions\n\n-- PMF \u03b1 represents discrete probability distributions over \u03b1\n-- (\u03bc : PMF \u03b1) assigns probability \u03bc a to element a : \u03b1\n</code></pre>"},{"location":"crypto/otp/interleaved_demo_presentation/#uniform-distribution-over-keys","title":"Uniform distribution over keys","text":"<pre><code>noncomputable def \u03bcK {n : \u2115} : PMF (Key n) :=\n  uniformOfFintype (Key n)\n\n-- For any key k: \u03bcK k = 1 / 2^n\n</code></pre>"},{"location":"crypto/otp/interleaved_demo_presentation/#independence-and-joint-distributions","title":"Independence and Joint Distributions","text":""},{"location":"crypto/otp/interleaved_demo_presentation/#independent-product-of-pmfs","title":"Independent product of PMFs","text":"<pre><code>noncomputable def \u03bcMK {n : \u2115} (\u03bcM : PMF (Plaintext n)) :\n  PMF (Plaintext n \u00d7 Key n) :=\n  PMF.bind \u03bcM (fun m =&gt; PMF.map (fun k =&gt; (m, k)) \u03bcK)\n\n-- P(M = m, K = k) = P(M = m) \u00b7 P(K = k)\n</code></pre>"},{"location":"crypto/otp/interleaved_demo_presentation/#ciphertext-distribution","title":"Ciphertext distribution","text":"<pre><code>noncomputable def \u03bcC {n : Nat} (\u03bcM : PMF (Plaintext n)) :\n  PMF (Ciphertext n) :=\n  PMF.bind (\u03bcMK \u03bcM) (fun mk =&gt;\n    PMF.pure (encrypt mk.1 mk.2))\n</code></pre> <p>Lemma (xor is a Bijection)</p> <p>For fixed \\(m\\), the map \\(k \u21a6 m \u2295 k\\) is a bijection!</p> <pre><code>def xorEquiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n where\n  toFun   := encrypt m     -- k \u21a6 m \u2295 k\n  invFun  := vec_xor m     -- c \u21a6 m \u2295 c\n  left_inv := by           -- m \u2295 (m \u2295 k) = k\n    intro k\n    apply ext\n    simp [encrypt, vec_xor, get_map\u2082, xor_aab_eq_b]\n  right_inv := by          -- (m \u2295 c) \u2295 m = c\n    intro c\n    apply ext\n    simp [encrypt, vec_xor, get_map\u2082, xor_aab_eq_b]\n</code></pre> Let me demonstrate why this bijection property is so important... <pre><code>-- Demo 3: Bijection Property\nsection BijectionDemo\n  open OTP\n\n  -- Show that encryption with a fixed message is injective\n  example {n : Nat} (m : Plaintext n) (k\u2081 k\u2082 : Key n)\n    (h : encrypt m k\u2081 = encrypt m k\u2082) : k\u2081 = k\u2082 := by\n    -- Use the bijection property\n    have bij := xorEquiv m\n    -- Apply injectivity\n    exact bij.injective h\n\n  -- Show that for every ciphertext, there's a unique key\n  example {n : Nat} (m : Plaintext n) (c : Ciphertext n) :\n    \u2203! k : Key n, encrypt m k = c := by\n    use vec_xor m c\n    constructor\n    \u00b7 -- Existence\n      simp [encrypt, vec_xor, xor_aab_eq_b]\n    \u00b7 -- Uniqueness\n      intro k hk\n      exact (key_uniqueness m k c).mp hk\nend BijectionDemo\n</code></pre> <p>Key insight</p> <p>This bijection is what guarantees that ciphertexts are uniformly distributed!</p> <p>Lemma (bijections preserve uniform distributions)</p> <pre><code>lemma map_uniformOfFintype_equiv\n    {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2] [DecidableEq \u03b2]\n    [Nonempty \u03b1] [Nonempty \u03b2] (\u03c3 : \u03b1 \u2243 \u03b2) :\n    PMF.map \u03c3 (uniformOfFintype \u03b1) = uniformOfFintype \u03b2\n</code></pre> <p>Intuition</p> <p>Given a uniform distribution on \\(\u03b1\\), if we apply a bijection \\(\u03c3 : \u03b1 \u2192 \u03b2\\), then we get a uniform distribution on \\(\u03b2\\). Crucial point: bijections preserve cardinality!</p> Let's see how this applies to our probability calculations... <pre><code>-- Demo 4: Probability Calculations\nsection ProbabilityDemo\n  open OTP PMF\n\n  -- The probability of any specific 3-bit key is 1/8\n  example : (\u03bcK (n := 3)) \u27e8[true, false, true], by decide\u27e9 = 1/8 := by\n    simp [\u03bcK, uniformOfFintype_apply]\n    -- Lean knows that card (Key 3) = 2^3 = 8\n    norm_num\n\n  -- The conditional probability P(C = c | M = m) is also 1/8\n  example (m : Plaintext 3) (c : Ciphertext 3) :\n    (\u03bcC_M m) c = 1/8 := by\n    rw [C_given_M_eq_inv_card_key]\n    norm_num\nend ProbabilityDemo\n</code></pre> <p>Key Point</p> <p>Both the key distribution and the conditional ciphertext distribution are uniform with the same probability!</p>"},{"location":"crypto/otp/interleaved_demo_presentation/#perfect-secrecy-statement","title":"Perfect Secrecy: Statement","text":""},{"location":"crypto/otp/interleaved_demo_presentation/#informal-version","title":"Informal Version","text":"<p>For all messages \\(m\\) and ciphertexts \\(c\\):</p> \\[P(M = m | C = c) = P(M = m)\\] <p>It's easy to see this is equivalent to the assertion that \\(M\\) and \\(C\\) are indenpendent.</p> <p>Independence and Conditional Probability</p> <p>By definition of conditional probability,</p> \\[P(M = m \\;|\\; C = c) \u00b7 P(C = c) = P(M = m, C = c) = P(C = c \\;| \\; M = m) \u00b7 P(M = m).\\] <p>\\(M\\) and \\(C\\) are independent provided</p> \\[P(M = m, C = c) = P(M = m) P(C = c).\\] <p>Therefore, assuming \\(P(C = c) &gt; 0\\) and \\(P(M = m) &gt; 0\\), the following are equivalent:</p> <ol> <li> <p>\\(P(M = m, C = c) = P(M = m) \u00b7 P(C = c)\\)</p> </li> <li> <p>\\(P(M = m \\;| \\; C = c) = P(M = m)\\),</p> </li> <li> <p>\\(P(C = c \\;| \\; M = m) = P(C = c)\\).</p> </li> </ol> <p>We will prove the third assertion.</p>"},{"location":"crypto/otp/interleaved_demo_presentation/#proof-strategy","title":"Proof Strategy","text":"<ol> <li>Show conditional distribution is uniform:</li> </ol> <p>\\[P(C = c | M = m) = \\frac{1}{2^n}\\]</p> <ol> <li>Show marginal distribution is uniform:</li> </ol> <p>\\[P(C = c) = \\frac{1}{2^n}\\]</p>"},{"location":"crypto/otp/interleaved_demo_presentation/#perfect-secrecy-visualization","title":"Perfect Secrecy Visualization","text":"Perfect secrecy in action with a small example... <pre><code>-- Demo 5: Perfect Secrecy Visualization\nsection PerfectSecrecyDemo\n  open OTP\n\n  -- For a 2-bit OTP, let's verify perfect secrecy manually\n  -- Message: [true, false]\n  -- Key space has 4 elements: [false,false], [false,true], [true,false], [true,true]\n\n  def msg_10 : Plaintext 2 := \u27e8[true, false], by decide\u27e9\n\n  -- Each key gives a different ciphertext:\n  #eval encrypt msg_10 \u27e8[false, false], by decide\u27e9  -- [true, false]\n  #eval encrypt msg_10 \u27e8[false, true], by decide\u27e9   -- [true, true]\n  #eval encrypt msg_10 \u27e8[true, false], by decide\u27e9   -- [false, false]\n  #eval encrypt msg_10 \u27e8[true, true], by decide\u27e9    -- [false, true]\n\n  -- Key insight: Every possible ciphertext appears exactly once!\n  -- This is why the OTP has perfect secrecy.\nend PerfectSecrecyDemo\n</code></pre> <p>Critical observation</p> <p>Each of the 4 possible 2-bit ciphertexts appears exactly once. This uniform mapping is the essence of perfect secrecy!</p>"},{"location":"crypto/otp/interleaved_demo_presentation/#common-pitfall-key-reuse","title":"Common Pitfall: Key Reuse","text":"Why you must never reuse a one-time pad key... <pre><code>-- Demo 6: Common Pitfall - Key Reuse\nsection KeyReuse\n  open OTP\n\n  def msg1 : Plaintext 4 := \u27e8[true, false, true, false], by decide\u27e9\n  def msg2 : Plaintext 4 := \u27e8[false, true, false, true], by decide\u27e9\n  def shared_key : Key 4 := \u27e8[true, true, false, false], by decide\u27e9\n\n  def c1 := encrypt msg1 shared_key\n  def c2 := encrypt msg2 shared_key\n\n  -- If an attacker gets both ciphertexts, they can XOR them:\n  #eval vec_xor c1 c2\n  -- This equals vec_xor msg1 msg2 - the key cancels out!\n  #eval vec_xor msg1 msg2\n\n  -- Lesson: NEVER reuse a one-time pad key!\nend KeyReuse\n</code></pre> <p>Security lesson</p> <p>If we xor two ciphertexts encrypted with the same key, the key cancels out, leaving \\(m_1 \u2295 m_2\\). This leaks information about the messages!</p>"},{"location":"crypto/otp/interleaved_demo_presentation/#summary-and-lessons-learned","title":"Summary and Lessons Learned","text":""},{"location":"crypto/otp/interleaved_demo_presentation/#1-type-classes-matter","title":"1. Type Classes Matter","text":"<ul> <li><code>Fintype</code> for finite types</li> <li><code>Nonempty</code> to avoid division by zero</li> <li><code>DecidableEq</code> for computability</li> </ul>"},{"location":"crypto/otp/interleaved_demo_presentation/#2-bijections-are-powerful","title":"2. Bijections are Powerful","text":"<ul> <li>xor with fixed value is a bijection</li> <li>Bijections preserve uniform distributions</li> <li>Can transform complex sums using bijections</li> </ul>"},{"location":"crypto/otp/interleaved_demo_presentation/#3-pmf-library-is-well-designed","title":"3. PMF Library is Well-Designed","text":"<ul> <li><code>bind</code> for dependent distributions</li> <li><code>map</code> for transforming distributions</li> <li>Uniform distributions built-in</li> </ul>"},{"location":"crypto/otp/interleaved_demo_presentation/#summary-and-lessons-learned_1","title":"Summary and Lessons Learned","text":"<ol> <li> <p>What \u03bcC represents</p> <p>The distribution of ciphertexts when we:</p> <ul> <li>sample a message <code>m</code> from <code>\u03bcM</code></li> <li>sample a key <code>k</code> uniformly from all <code>2\u207f</code> keys</li> <li>output <code>encrypt m k</code></li> </ul> </li> <li> <p>Why it's uniform</p> <ul> <li>for each <code>m</code>, the map <code>k \u21a6 m \u2295 k</code> is a bijection</li> <li>so each ciphertext <code>c</code> appears exactly once for each <code>m</code></li> <li>since keys are uniform, each <code>c</code> has probability <code>1/2\u207f</code></li> </ul> </li> <li> <p>Perfect secrecy: P(C = c | M = m) = 1/2\u207f = P(C = c)</p> <ul> <li>OTP achieves perfect secrecy because xor is a bijection</li> <li>so both conditional and marginal distributions of ciphertexts are uniform</li> <li>this is precisely independence between message and ciphertext.</li> </ul> </li> </ol>"},{"location":"crypto/otp/interleaved_demo_presentation/#challenges-in-formalization","title":"Challenges in Formalization","text":""},{"location":"crypto/otp/interleaved_demo_presentation/#1-vector-equality","title":"1. Vector Equality","text":"<ul> <li>Must use extensionality (<code>ext</code>)</li> <li>Reduce to element-wise proofs</li> <li><code>simp</code> is very helpful with <code>get_map\u2082</code></li> </ul>"},{"location":"crypto/otp/interleaved_demo_presentation/#2-infinite-sums","title":"2. Infinite Sums","text":"<ul> <li><code>tsum</code> requires careful manipulation</li> <li>Product types need <code>tsum_prod'</code></li> <li>Conditional sums use <code>tsum_ite_eq</code></li> </ul>"},{"location":"crypto/otp/interleaved_demo_presentation/#3-real-number-arithmetic","title":"3. Real Number Arithmetic","text":"<ul> <li>Coercion between <code>Nat</code>, <code>NNReal</code>, <code>ENNReal</code></li> <li>Division requires non-zero denominators</li> <li>Must track when values are finite</li> </ul>"},{"location":"crypto/otp/interleaved_demo_presentation/#future-directions","title":"Future Directions","text":""},{"location":"crypto/otp/interleaved_demo_presentation/#extensions","title":"Extensions","text":"<ol> <li> <p>Other Cryptographic Constructions</p> <ul> <li>Stream ciphers</li> <li>Block ciphers (with appropriate modes)</li> <li>Public key encryption</li> </ul> </li> <li> <p>Advanced Probability</p> <ul> <li>Computational indistinguishability</li> <li>Negligible functions</li> <li>Probabilistic polynomial time</li> </ul> </li> <li> <p>Security Proofs</p> <ul> <li>Semantic security</li> <li>CPA/CCA security</li> <li>Reduction proofs</li> </ul> </li> </ol>"},{"location":"crypto/otp/interleaved_demo_presentation/#takeaways","title":"Takeaways","text":"<ul> <li>Lean + Mathlib provides excellent support for probability</li> <li>Type-driven development helps catch errors early</li> <li>Bijections are a key tool in cryptographic proofs</li> <li>Perfect secrecy is elegantly expressible and provable</li> </ul>"},{"location":"crypto/otp/interleaved_demo_presentation/#resources","title":"Resources","text":"<ul> <li>Slides https://formalmethods.io/crypto</li> <li> <p>Code https://github.com/formalverification/lean4crypto/</p> </li> <li> <p>Lean https://lean-lang.org/</p> </li> <li>Mathlib docs https://leanprover-community.github.io/mathlib4_docs/</li> <li>Mathlib source https://github.com/leanprover-community/mathlib4</li> </ul>"},{"location":"crypto/otp/interleaved_demo_presentation/#questions","title":"Questions?","text":""},{"location":"crypto/otp/interleaved_demo_presentation/#quick-reference","title":"Quick Reference","text":"<ul> <li><code>PMF \u03b1</code> - Probability mass function over type <code>\u03b1</code></li> <li><code>uniformOfFintype</code> - Uniform distribution</li> <li><code>List.Vector</code> - Fixed-length vectors</li> <li><code>ENNReal</code> - Extended non-negative reals</li> <li><code>\u2243</code> - Type equivalence (bijection)</li> </ul> <p>Thank you!</p>"},{"location":"crypto/otp/otp-lean/","title":"OTP in L\u2203\u2200N","text":""},{"location":"crypto/otp/otp-lean/#initial-considerations","title":"Initial Considerations \ud83e\udd14","text":"<ul> <li> <p>What types for messages, keys, ciphertexts? </p> <p><code>Vector Bool n</code> is a good candidate (or <code>Fin n \u2192 Bool</code>).</p> </li> <li> <p>How to represent the XOR operation on these types?</p> </li> <li> <p>Which Mathlib probability definitions will you need? (e.g., <code>PMF</code>, <code>Pure</code>, <code>Bind</code> for random variables, <code>cond</code> for conditional probability).</p> </li> </ul>"},{"location":"crypto/otp/otp-lean/#types-aliases","title":"Types Aliases  \ud83d\udd75\ufe0f","text":"<pre><code>def Plaintext (n : Nat) := Vector Bool n\ndef Key (n : Nat) := Vector Bool n\ndef Ciphertext (n : Nat) := Vector Bool n\n</code></pre> <p>Using <code>n : Nat</code> so definitions are generic for any length.</p>"},{"location":"crypto/otp/otp-lean/#xor-operation","title":"XOR Operation \u2295","text":"<p>We need a function like</p> <pre><code>xor_vector {n : Nat} (v\u2081 v\u2082 : Vector Bool n) : Vector Bool n\n</code></pre> <p>This can be defined using <code>Vector.map\u2082 Bool.xor v\u2081 v\u2082</code>.</p>"},{"location":"crypto/otp/otp-lean/#mathlib-definitions","title":"Mathlib Definitions \ud83d\udcd1","text":"<p>Message Distribution <code>PMF (Plaintext n)</code></p> <p>Perfect secrecy definition assumes messages come from some probability distribution.</p> <p>In our theorem statement, we leave this arbitrary: <code>\u03bc_M : PMF (Plaintext n)</code>.</p> <p>Key Distribution <code>PMF (Key n)</code></p> <p>This is uniform on the key space (a finite set of size 2\u207f).</p> <p>We need to define what <code>is_uniform (\u03bc_K : PMF (Key n))</code> means.</p> <p>For a finite type <code>\u03b1</code>, probability mass function <code>p</code> is uniform if <code>p a = 1 / card \u03b1</code> for all <code>a : \u03b1</code>.</p> <p>Mathlib has utilities for this, e.g. <code>PMF.uniformOfFintype</code>.</p> <p>Ciphertext Distribution <code>PMF (Ciphertext n)</code></p> <p>This is derived from message and key distributions using <code>PMF.bind</code> to represent the encryption process.</p> <p>Conditional Probability \\(\u2119(M=m \\;| \\;C=c)\\)</p> <p>defined using <code>PMF.cond</code></p>"},{"location":"crypto/otp/otp-lean/#lean-project-setup","title":"Lean Project Setup \ud83c\udfd7\ufe0f\ufe0f","text":"<p>This section describes the steps we took to set up our Lean project.  The resulting source code is maintained in our lean4crypto respository at </p> <p>https://github.com/formalverification/lean4crypto</p> <ol> <li> <p>Create the Project.</p> <p>In a terminal, <pre><code>lake new OTP math\ncd OTP\n</code></pre></p> </li> <li> <p>Verfiy Mathlib Dependency.</p> <p>The <code>lakefile.toml</code> should look something like this:</p> <pre><code>name = \"OTP\"\nversion = \"0.1.0\"\nkeywords = [\"math\"]\ndefaultTargets = [\"OTP\"]\n\n[leanOptions]\npp.unicode.fun = true # pretty-prints `fun a \u21a6 b`\nautoImplicit = false\n\n[[require]]\nname = \"mathlib\"\nscope = \"leanprover-community\"\n\n[[lean_lib]]\nname = \"OTP\"\n</code></pre> </li> <li> <p>Fetch Mathlib:     In your terminal (in the <code>otp_formalization</code> directory):     <pre><code>lake update\n</code></pre>     This might take a few minutes the first time. Then build to ensure it's working:     <pre><code>lake build\n</code></pre></p> </li> <li> <p>Create Main File.</p> <ul> <li>The <code>lake new</code> command creates <code>OTP.lean</code> and <code>OTP/Basic.lean</code>.</li> <li>We'll start the formalization in <code>OTP/Basic.lean</code> which is imported into <code>OTP.lean</code>.</li> </ul> </li> </ol>"},{"location":"crypto/otp/otp-lean/#initial-definitions","title":"Initial Definitions \u270d\ufe0f","text":"<p>In <code>OTP/Basic.lean</code>,</p> <pre><code>import Mathlib.Data.Vector.Basic\n\nnamespace OTP\n\n  def Plaintext (n : Nat) := Vector Bool n\n  def Key (n : Nat) := Vector Bool n\n  def Ciphertext (n : Nat) := Vector Bool n\n\n  -- Element-wise XOR for Vectors\n  def xor_vector {n : Nat} (v\u2081 v\u2082 : Vector Bool n) : Vector Bool n :=\n    Vector.zipWith Bool.xor v\u2081 v\u2082\n    -- Or more explicitly:\n    -- Vector.ofFn (fun i =&gt; Bool.xor (v\u2081.get i) (v\u2082.get i))\n\n  def encrypt {n : Nat} (p : Plaintext n) (k : Key n) : Ciphertext n :=\n    xor_vector p k\n\n  def decrypt {n : Nat} (c : Ciphertext n) (k : Key n) : Ciphertext n :=\n    xor_vector c k\n\n  -- Let's test with a simple example if we can construct vectors\n  -- To make this evaluable, we need a concrete n and ways to make vectors.\n  -- For example:\n  def ex_plaintext : Plaintext 3 := \u27e8#[true, false, true], by decide\u27e9 -- Using constructor for clarity\n\n  -- Or using the direct constructor...\n  def ex_plaintext' : Plaintext 3 := \u27e8#[true, false, true], by rfl\u27e9 -- by rfl or by decide usually works for length proofs\n  def ex_key : Key 3 := \u27e8#[false, true, true], by decide\u27e9\n\n  #eval encrypt ex_plaintext ex_key\n  -- Expected output: vector of ![true, true, false] (or similar representation)\n\n  def ex_ciphertext : Ciphertext 3 := encrypt ex_plaintext ex_key\n  #eval decrypt ex_ciphertext ex_key\n  -- Expected output: vector of ![true, false, true]\n\nend OTP\n</code></pre>"},{"location":"crypto/otp/perfect-secrecy/","title":"Perfect Secrecy of the One-time Pad","text":""},{"location":"crypto/otp/perfect-secrecy/#construction","title":"Construction","text":"<p>Definition of _\u2295_</p> <p>_\u2295_ is bitwise XOR: \\(\\quad 0 \u2295 0 = 0, \\quad 0 \u2295 1 = 1, \\quad 1 \u2295 0 = 1, \\quad 1 \u2295 1 = 0\\).</p> <p>For n-bit strings \\(\\; a = a\u2081 \u22ef a_n\\), \\(\\; b = b\u2081 \u22ef b_n\\) , let \\(\\; a \u2295 b = a\u2081 \u2295 b\u2081 \u22ef a_n \u2295 b_n\\).</p> Cayley table of _\u2295_ \u2295 0 1 0 0 1 1 1 0 <p>An important property of _\u2295_</p> <p>\\(a \u2295 b = c \u21d4 a = b \u2295 c\\), for all \\(a\\), \\(b\\), \\(c\\).</p> <p>Fix an integer \\(n &gt; 0\\).</p> <p>Let \\(\u2133\\) be the message space , \\(\ud835\udca6\\) the key space, and \\(\ud835\udc9e\\) the ciphertext space.</p> <p>Assume \\(\u2133\\), \\(\ud835\udca6\\), \\(\ud835\udc9e\\) all equal \\(\\{0, 1\\}^n\\).</p> <ul> <li> <p>Gen (key-generation algorithm) choose key from uniform distribution over \\(\ud835\udca6\\).</p> </li> <li> <p>Enc (encryption algorithm) given \\(k \u2208 \ud835\udca6\\), \\(m \u2208 \u2133\\),  output ciphertext \\(c = k \u2295 m\\).</p> </li> <li> <p>Dec (decryption algorithm) given \\(k \u2208 \ud835\udca6\\), \\(c \u2208 \ud835\udc9e\\), output message \\(m = k \u2295 c\\).</p> </li> </ul>"},{"location":"crypto/otp/perfect-secrecy/#perfect-secrecy-theorem","title":"Perfect Secrecy Theorem","text":"<p>Theorem 2.9 (Katz &amp; Lindell, 2ed)</p> <p>The one-time pad encryption scheme is perfectly secret.</p> Proof of Theorem 2.9 \u270d\ufe0f <ul> <li>Let \\(C\\) and \\(M\\) be r.v.s from arbitrary, fixed distributions over \\(\u2133\\) and \\(\ud835\udc9e\\), resp.</li> <li>Let \\(K\\) be a r.v. from the uniform distribution over \\(\ud835\udca6\\).</li> </ul> <p>Goal \ud83e\udd45</p> <p>If \\(m \u2208 \u2133\\), \\(c \u2208 \ud835\udc9e\\) and \\(\u2119(C = c) &gt; 0\\), then \\(\u2119 (M = m \\; | \\; C = c) = \u2119(M = m)\\).</p> <p>We first show what amounts to \"\\(C\\) is uniform if \\(K\\) is uniform, regardless of \\(M\\).\"</p> <p>Compute \\(\u2119(C = c \\; | \\; M = m )\\) for arbitrary \\(c \u2208 \ud835\udc9e\\) and \\(m \u2208 \u2133\\): \\[\u2119 (C = c \\; | \\; M = m) = \u2119 (\\mathrm{Enc}_k (m) = c) = \u2119(k \u2295 m = c)= \u2119(k = m \u2295 c)= 2^{-n},\\]</p> <p>since \\(k\\) is chosen from a uniform distribution over the set \\(\ud835\udca6\\) of \\(n\\)-bit strings.</p> <p>For \\(c \u2208 \ud835\udc9e\\),</p> <p>\\[\u2119 (C = c) = \u2211_{m \u2208 \u2133} \u2119 (C = c \\; | \\; M = m) \u00b7 \u2119(M = m) = 2^{-n} \u2211_{m \u2208 \u2133} \u2119(M = m) = 2^{-n}.\\]</p> <p>Finally, by Bayes' Theorem,</p> \\[\\begin{align*} \u2119(M = m \\; | \\; C = c) &amp;= \\frac{\u2119(C = c \\; | \\; M = m) \u00b7 \u2119(M = m)}{\u2119(C = c)}\\\\                        &amp;= \\frac{2^{-n} \u00b7 \u2119(M = m)}{2^{-n}} = \u2119(M = m). \\end{align*}\\] <p>\u220e</p>"},{"location":"crypto/otp/slides/","title":"Formalizing Discrete Probability in Lean 4: The One-Time Pad","text":""},{"location":"crypto/otp/slides/#fm-crypto-meeting","title":"FM Crypto Meeting","text":""},{"location":"crypto/otp/slides/#overview","title":"Overview","text":"<ul> <li>\ud83e\udd45 Goal: Formalize basic discrete probability in Lean 4</li> <li>\ud83d\uddc4\ufe0f Case Study: One-Time Pad (OTP) and Perfect Secrecy</li> <li>\ud83d\udd11\ufe0f Key Concepts:</li> <li>Probability Mass Functions (PMFs)</li> <li>Independence and joint distributions</li> <li>Conditional probability</li> <li>Bijections preserving uniform distributions</li> </ul>"},{"location":"crypto/otp/slides/#the-one-time-pad","title":"The One-Time Pad","text":""},{"location":"crypto/otp/slides/#informal-definition","title":"Informal Definition","text":"<ul> <li>Message space: \\(M = \\{0,1\\}^n\\)</li> <li>Key space: \\(K = \\{0,1\\}^n\\)</li> <li>Ciphertext space: \\(C = \\{0,1\\}^n\\)</li> <li>Encryption: \\(\\text{Enc}(m, k) = m \\oplus k\\)</li> <li>Decryption: \\(\\text{Dec}(c, k) = c \\oplus k\\)</li> </ul>"},{"location":"crypto/otp/slides/#key-property","title":"Key Property","text":"\\[\\text{Dec}(\\text{Enc}(m, k), k) = (m \\oplus k) \\oplus k = m\\]"},{"location":"crypto/otp/slides/#lean-4-formalization-types","title":"Lean 4 Formalization: Types","text":"<pre><code>import Mathlib.Data.Vector.Basic\n\ndef Plaintext  (n : Nat) := List.Vector Bool n\ndef Key        (n : Nat) := List.Vector Bool n\ndef Ciphertext (n : Nat) := List.Vector Bool n\n\n-- Element-wise XOR\ndef vec_xor {n : Nat} (v\u2081 v\u2082 : List.Vector Bool n) :=\n  map\u2082 xor v\u2081 v\u2082\n\ndef encrypt {n : Nat} (m : Plaintext n) (k : Key n) : Ciphertext n :=\n  vec_xor m k\n</code></pre>"},{"location":"crypto/otp/slides/#correctness-of-encryptiondecryption","title":"Correctness of Encryption/Decryption","text":"<pre><code>lemma encrypt_decrypt {n : Nat} (m : Plaintext n) (k : Key n) :\n  decrypt (encrypt m k) k = m := by\n  unfold encrypt decrypt vec_xor\n  apply ext  -- vector extensionality\n  intro i    -- prove element-wise\n  simp only [get_map\u2082]\n  -- Goal: xor (xor (get m i) (get k i)) (get k i) = get m i\n  simp  -- Uses xor properties automatically\n</code></pre> <p>Key insight: Reduce vector equality to element-wise boolean equality</p>"},{"location":"crypto/otp/slides/#probability-mass-functions-in-lean-4","title":"Probability Mass Functions in Lean 4","text":""},{"location":"crypto/otp/slides/#mathlibs-pmf-type","title":"Mathlib's PMF type","text":"<pre><code>import Mathlib.Probability.ProbabilityMassFunction.Constructions\n\n-- PMF \u03b1 represents discrete probability distributions over \u03b1\n-- (\u03bc : PMF \u03b1) assigns probability \u03bc a to element a : \u03b1\n</code></pre>"},{"location":"crypto/otp/slides/#uniform-distribution-over-keys","title":"Uniform distribution over keys","text":"<pre><code>noncomputable def \u03bcK {n : \u2115} : PMF (Key n) :=\n  uniformOfFintype (Key n)\n\n-- For any key k: \u03bcK k = 1 / 2^n\n</code></pre>"},{"location":"crypto/otp/slides/#independence-and-joint-distributions","title":"Independence and Joint Distributions","text":""},{"location":"crypto/otp/slides/#independent-product-of-pmfs","title":"Independent product of PMFs","text":"<pre><code>noncomputable def \u03bcMK {n : \u2115} (\u03bcM : PMF (Plaintext n)) :\n  PMF (Plaintext n \u00d7 Key n) :=\n  PMF.bind \u03bcM (fun m =&gt; PMF.map (fun k =&gt; (m, k)) \u03bcK)\n\n-- P(M = m, K = k) = P(M = m) \u00b7 P(K = k)\n</code></pre>"},{"location":"crypto/otp/slides/#ciphertext-distribution","title":"Ciphertext distribution","text":"<pre><code>noncomputable def \u03bcC {n : Nat} (\u03bcM : PMF (Plaintext n)) :\n  PMF (Ciphertext n) :=\n  PMF.bind (\u03bcMK \u03bcM) (fun mk =&gt;\n    PMF.pure (encrypt mk.1 mk.2))\n</code></pre>"},{"location":"crypto/otp/slides/#key-lemma-1-xor-is-a-bijection","title":"Key Lemma 1: XOR is a Bijection","text":"<pre><code>def xorEquiv {n : \u2115} (m : Plaintext n) : Key n \u2243 Ciphertext n where\n  toFun   := encrypt m     -- k \u21a6 m \u2295 k\n  invFun  := vec_xor m     -- c \u21a6 m \u2295 c\n  left_inv := by           -- m \u2295 (m \u2295 k) = k\n    intro k\n    apply ext\n    simp [encrypt, vec_xor, get_map\u2082, xor_aab_eq_b]\n  right_inv := by          -- (m \u2295 c) \u2295 m = c\n    intro c\n    apply ext\n    simp [encrypt, vec_xor, get_map\u2082, xor_aab_eq_b]\n</code></pre> <p>For fixed \\(m\\), the map \\(k \\mapsto m \\oplus k\\) is a bijection!</p>"},{"location":"crypto/otp/slides/#key-lemma-2-bijections-preserve-uniform-distributions","title":"Key Lemma 2: Bijections Preserve Uniform Distributions","text":"<pre><code>lemma map_uniformOfFintype_equiv\n    {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2] [DecidableEq \u03b2]\n    [Nonempty \u03b1] [Nonempty \u03b2] (e : \u03b1 \u2243 \u03b2) :\n    PMF.map e (uniformOfFintype \u03b1) = uniformOfFintype \u03b2\n</code></pre>"},{"location":"crypto/otp/slides/#intuition","title":"Intuition","text":"<ul> <li>If we have a uniform distribution on \\(\\alpha\\)</li> <li>And apply a bijection \\(e : \\alpha \\to \\beta\\)</li> <li>We get a uniform distribution on \\(\\beta\\)</li> <li>Crucial: bijections preserve cardinality!</li> </ul>"},{"location":"crypto/otp/slides/#perfect-secrecy-statement","title":"Perfect Secrecy: Statement","text":""},{"location":"crypto/otp/slides/#informal-version","title":"Informal Version","text":"<p>For all messages \\(m\\) and ciphertexts \\(c\\):</p> \\[P(M = m \\; | \\; C = c) = P(M = m)\\]"},{"location":"crypto/otp/slides/#lean-4-version","title":"Lean 4 Version","text":"<pre><code>theorem perfect_secrecy {n : Nat} (\u03bcM : PMF (Plaintext n))\n  (m\u2080 : Plaintext n) (c\u2080 : Ciphertext n) :\n  (\u03bcC_M m\u2080) c\u2080 * \u03bcM m\u2080 / (\u03bcC \u03bcM) c\u2080 = \u03bcM m\u2080\n</code></pre> <p>Where:</p> <ul> <li><code>\u03bcC_M m\u2080</code> is the conditional distribution \\(P(C \\; | \\; M = m_0)\\)</li> <li><code>\u03bcC \u03bcM</code> is the marginal distribution \\(P(C)\\)</li> </ul>"},{"location":"crypto/otp/slides/#proof-strategy","title":"Proof Strategy","text":"<ol> <li> <p>Show conditional distribution is uniform:</p> \\[P(C = c \\; | \\; M = m) = 2^{-n}\\] </li> <li> <p>Show marginal distribution is uniform:</p> \\[P(C = c) = 2^{-n}\\] </li> <li> <p>Apply Bayes' theorem:</p> \\[\\begin{align*} P(M = m | C = c) =&amp; \\frac{P(C = c \\; | \\; M = m) \u00b7 P(M = m)}{P(C = c)}\\\\[8pt] &amp;= \\frac{2^{-n} \u00b7 P(M = m)}{2^{-n}}\\\\[8pt] &amp;= P(M = m) \\end{align*}\\] </li> </ol>"},{"location":"crypto/otp/slides/#step-1-conditional-distribution-is-uniform","title":"Step 1: Conditional Distribution is Uniform","text":"<pre><code>lemma C_given_M_eq_inv_card_key {n : \u2115}\n  (m : Plaintext n) (c : Ciphertext n) :\n  (\u03bcC_M m) c = 1 / card (Key n) := by\n  -- \u03bcC_M m = map (encrypt m) \u03bcK\n  -- encrypt m is a bijection (xorEquiv m)\n  -- So map (encrypt m) \u03bcK = uniformOfFintype (Ciphertext n)\n  have h\u03bc : \u03bcC_M m = uniformOfFintype (Ciphertext n) := by\n    apply map_uniformOfFintype_equiv (xorEquiv m)\n  simpa [h\u03bc, uniformOfFintype_apply]\n    using card_congr (xorEquiv m)\n</code></pre>"},{"location":"crypto/otp/slides/#step-2-marginal-distribution-is-uniform","title":"Step 2: Marginal Distribution is Uniform","text":"<pre><code>lemma prob_C_uniform_ennreal {n : Nat} (\u03bcM : PMF (Plaintext n))\n  (c : Ciphertext n) :\n  (\u03bcC \u03bcM) c = (card (Key n) : ENNReal)\u207b\u00b9\n</code></pre>"},{"location":"crypto/otp/slides/#key-insight","title":"Key insight:","text":"<ul> <li>For each \\(m\\), there's exactly one \\(k\\) such that \\(m \\oplus k = c\\)</li> <li>Namely, \\(k = m \\oplus c\\)</li> <li>So we can rewrite the sum over \\((m,k)\\) pairs as a sum over \\(m\\) alone</li> </ul>"},{"location":"crypto/otp/slides/#working-with-ennreal","title":"Working with ENNReal","text":""},{"location":"crypto/otp/slides/#challenge-division-in-probability","title":"Challenge: Division in probability","text":"<ul> <li>PMFs use <code>NNReal</code> (non-negative reals)</li> <li>Division requires <code>ENNReal</code> (extended non-negative reals)</li> <li>Need to handle \\(0\\) and \\(\\infty\\) carefully</li> </ul>"},{"location":"crypto/otp/slides/#key-properties-used","title":"Key properties used:","text":"<pre><code>-- For x \u2260 0 and x \u2260 \u221e:\nx * y / x = y\n\n-- Uniform distribution has probability 1/|S|\n(uniformOfFintype S) s = (card S)\u207b\u00b9\n</code></pre>"},{"location":"crypto/otp/slides/#lessons-learned","title":"Lessons Learned","text":""},{"location":"crypto/otp/slides/#1-type-classes-matter","title":"1. Type Classes Matter","text":"<ul> <li><code>Fintype</code> for finite types</li> <li><code>Nonempty</code> to avoid division by zero</li> <li><code>DecidableEq</code> for computability</li> </ul>"},{"location":"crypto/otp/slides/#2-bijections-are-powerful","title":"2. Bijections are Powerful","text":"<ul> <li>XOR with fixed value is a bijection</li> <li>Bijections preserve uniform distributions</li> <li>Can transform complex sums using bijections</li> </ul>"},{"location":"crypto/otp/slides/#3-pmf-library-is-well-designed","title":"3. PMF Library is Well-Designed","text":"<ul> <li><code>bind</code> for dependent distributions</li> <li><code>map</code> for transforming distributions</li> <li>Uniform distributions built-in</li> </ul>"},{"location":"crypto/otp/slides/#challenges-in-formalization","title":"Challenges in Formalization","text":""},{"location":"crypto/otp/slides/#1-vector-equality","title":"1. Vector Equality","text":"<ul> <li>Must use extensionality (<code>ext</code>)</li> <li>Reduce to element-wise proofs</li> <li><code>simp</code> is very helpful with <code>get_map\u2082</code></li> </ul>"},{"location":"crypto/otp/slides/#2-infinite-sums","title":"2. Infinite Sums","text":"<ul> <li><code>tsum</code> requires careful manipulation</li> <li>Product types need <code>tsum_prod'</code></li> <li>Conditional sums use <code>tsum_ite_eq</code></li> </ul>"},{"location":"crypto/otp/slides/#3-real-number-arithmetic","title":"3. Real Number Arithmetic","text":"<ul> <li>Coercion between <code>Nat</code>, <code>NNReal</code>, <code>ENNReal</code></li> <li>Division requires non-zero denominators</li> <li>Must track when values are finite</li> </ul>"},{"location":"crypto/otp/slides/#demo-interactive-proof-development","title":"Demo: Interactive Proof Development","text":"<p>Let's see how Lean 4's tactics work in practice:</p> <pre><code>example {n : Nat} (m : Plaintext n) (k : Key n) :\n  encrypt m k = encrypt m k := by\n  -- Lean's proof state shows current goal\n  rfl  -- reflexivity\n\nexample {n : Nat} (m : Plaintext n) (k\u2081 k\u2082 : Key n)\n  (h : encrypt m k\u2081 = encrypt m k\u2082) : k\u2081 = k\u2082 := by\n  -- Use key uniqueness\n  have h_unique := key_uniqueness m k\u2081 (encrypt m k\u2082)\n  rw [h_unique.mp h]\n  -- Alternative: use xorEquiv directly\n</code></pre>"},{"location":"crypto/otp/slides/#future-directions","title":"Future Directions","text":""},{"location":"crypto/otp/slides/#extensions","title":"Extensions","text":"<ol> <li> <p>Other Cryptographic Constructions</p> <ul> <li>Stream ciphers</li> <li>Block ciphers (with appropriate modes)</li> <li>Public key encryption</li> </ul> </li> <li> <p>Advanced Probability</p> <ul> <li>Computational indistinguishability</li> <li>Negligible functions</li> <li>Probabilistic polynomial time</li> </ul> </li> <li> <p>Security Proofs</p> <ul> <li>Semantic security</li> <li>CPA/CCA security</li> <li>Reduction proofs</li> </ul> </li> </ol>"},{"location":"crypto/otp/slides/#takeaways","title":"Takeaways","text":"<ul> <li>Lean 4 + Mathlib provides excellent support for probability</li> <li>Type-driven development helps catch errors early</li> <li>Bijections are a key tool in cryptographic proofs</li> <li>Perfect secrecy is elegantly expressible and provable</li> </ul>"},{"location":"crypto/otp/slides/#resources","title":"Resources","text":"<ul> <li>Slides https://formalmethods.io/crypto</li> <li> <p>Code https://github.com/formalverification/lean4crypto/</p> </li> <li> <p>Lean https://lean-lang.org/</p> </li> <li>Mathlib docs https://leanprover-community.github.io/mathlib4_docs/</li> <li>Mathlib source https://github.com/leanprover-community/mathlib4</li> </ul>"},{"location":"crypto/otp/slides/#questions","title":"Questions?","text":""},{"location":"crypto/otp/slides/#quick-reference","title":"Quick Reference","text":"<ul> <li><code>PMF \u03b1</code> - Probability mass function over type <code>\u03b1</code></li> <li><code>uniformOfFintype</code> - Uniform distribution</li> <li><code>List.Vector</code> - Fixed-length vectors</li> <li><code>ENNReal</code> - Extended non-negative reals</li> <li><code>\u2243</code> - Type equivalence (bijection)</li> </ul> <p>Thank you!</p>"},{"location":"mkdocs/admonitions/","title":"Admonitions","text":"<p>From the markdown...</p> <p><pre><code>!!! note \"Title of the callout\"\n\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n    nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n    massa, nec semper lorem quam in massa.\n</code></pre> ...MkDocs produces:</p> <p>Title of the callout</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"mkdocs/admonitions/#collapsible-callouts","title":"Collapsible callouts","text":"<p>From the markdown... </p> <pre><code>??? info \"Collapsible callout\"\n\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n    nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n    massa, nec semper lorem quam in massa.\n</code></pre> <p>... MkDocs produces:</p> Collapsible callout <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"mkdocs/code-blocks/","title":"Code blocks","text":"<pre><code>    ```py title=\"add_numbers.py\" linenums=\"1\" hl_lines=\"2-4\"\n    # Function to add two numbers\n    def add_two_numbers(num1, num2):\n        return num1 + num2\n\n    # Example usage\n    result = add_two_numbers(5, 3)\n    print('The sum is:', result)\n    ```\n</code></pre> <p>produces</p> add_numbers.py<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre>"},{"location":"mkdocs/content-tabs/","title":"Content tabs","text":""},{"location":"mkdocs/content-tabs/#generic-content","title":"Generic Content","text":"<p>From the markdown...</p> <pre><code>=== \"Plain text\"\n\n    This is some plain text\n\n=== \"Unordered list\"\n\n    * First item\n    * Second item\n    * Third item\n\n=== \"Ordered list\"\n\n    1. First item\n    2. Second item\n    3. Third item\n</code></pre> <p>...MkDocs produces</p> Plain textUnordered listOrdered list <p>This is some plain text</p> <ul> <li>First item</li> <li>Second item</li> <li>Third item</li> </ul> <ol> <li>First item</li> <li>Second item</li> <li>Third item</li> </ol>"},{"location":"mkdocs/content-tabs/#code-blocks-in-content-tabs","title":"Code Blocks in Content Tabs","text":"<p>From the markdown...</p> <pre><code>=== \"Python\"\n\n    ```py\n    def main():\n        print(\"Hello world!\")\n\n    if __name__ == \"__main__\":\n        main()\n    ```\n\n=== \"JavaScript\"\n\n    ```js\n    function main() {\n        console.log(\"Hello world!\");\n    }\n\n    main();\n    ```\n</code></pre> <p>...MkDocs produces</p> PythonJavaScript <pre><code>def main():\n    print(\"Hello world!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>function main() {\n    console.log(\"Hello world!\");\n}\n\nmain();\n</code></pre>"},{"location":"mkdocs/diagrams/","title":"Diagram Examples","text":""},{"location":"mkdocs/diagrams/#flowcharts","title":"Flowcharts","text":"<p>From the markdown...</p> <pre><code>    ```mermaid\n    graph LR\n      A[Start] --&gt; B{Failure?};\n      B --&gt;|Yes| C[Investigate...];\n      C --&gt; D[Debug];\n      D --&gt; B;\n      B ----&gt;|No| E[Success!];\n    ```\n</code></pre> <p>...MkDocs produces</p> <pre><code>graph LR\n  A[Start] --&gt; B{Failure?};\n  B --&gt;|Yes| C[Investigate...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Success!];</code></pre>"},{"location":"mkdocs/diagrams/#sequence-diagrams","title":"Sequence Diagrams","text":"<p>From the markdown...</p> <p><pre><code>    ```mermaid\n    sequenceDiagram\n      autonumber\n      Server-&gt;&gt;Terminal: Send request\n      loop Health\n          Terminal-&gt;&gt;Terminal: Check for health\n      end\n      Note right of Terminal: System online\n      Terminal--&gt;&gt;Server: Everything is OK\n      Terminal-&gt;&gt;Database: Request customer data\n      Database--&gt;&gt;Terminal: Customer data\n    ```\n</code></pre> ...MkDocs produces</p> <pre><code>sequenceDiagram\n  autonumber\n  Server-&gt;&gt;Terminal: Send request\n  loop Health\n      Terminal-&gt;&gt;Terminal: Check for health\n  end\n  Note right of Terminal: System online\n  Terminal--&gt;&gt;Server: Everything is OK\n  Terminal-&gt;&gt;Database: Request customer data\n  Database--&gt;&gt;Terminal: Customer data</code></pre>"}]}